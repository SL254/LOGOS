<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LOGOS</title>

    <style>
      @font-face {
        font-family: "font"; /* CSS에서 사용할 폰트 이름을 지정 */
        src: url("assets/font.ttf") format("truetype"); /* 폰트 파일의 경로와 형식 */
      }
      body {
        font-family: "font", "Malgun Gothic", "Segoe UI", sans-serif;
        background-color: #f4f7f9;
        color: #333;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
        font-size: 15px;
        /* 1. 이미지 파일 불러오기 */
        background-image: url("assets/sky.png"); /* 👈 사용할 단일 이미지 경로 */
        background-repeat: no-repeat; /* 👈 이미지 반복 안 함 */
        background-size: cover; /* 👈 박스를 덮도록 크기 조절 (또는 contain) */
        background-position: center; /* 👈 이미지를 중앙에 배치 */
        image-rendering: pixelated;
      }
      .container {
        display: grid;
        grid-template-columns: 1fr 2fr 1fr;
        grid-template-rows: auto auto 1fr auto;
        row-gap: 0;
        column-gap: 0px;
        width: 100%;
        max-width: 1400px;
        height: 90vh;
        visibility: hidden; /* Initially hidden until language is selected */
        position: relative;
        z-index: 1;
      }
      .container.ready {
        visibility: visible;
      }
      header {
        grid-column: 1 / -1;
        text-align: center;
        padding: 25px 15px;
        color: black;
        margin: 0 -40px;
        background-image: url("assets/roof.png"); /* 👈 사용할 단일 이미지 경로 */
        background-repeat: no-repeat; /* 👈 이미지 반복 안 함 */
        background-size: cover; /* 👈 박스를 덮도록 크기 조절 (또는 contain) */
        background-position: center; /* 👈 이미지를 중앙에 배치 */
        image-rendering: pixelated;
      }
      header h1 {
        color: #9a4b37;
        margin: 0;
        font-size: 38px;
      }

      #info-box {
        padding: 15px 55px;
        grid-column: 1 / -1;
        display: flex;
        justify-content: space-between;
        align-items: center;
        position: relative;
        margin: 0 -40px;
        background-image: url("assets/roo.png"); /* 👈 사용할 단일 이미지 경로 */
        background-repeat: no-repeat; /* 👈 이미지 반복 안 함 */
        background-size: cover; /* 👈 박스를 덮도록 크기 조절 (또는 contain) */
        background-position: center; /* 👈 이미지를 중앙에 배치 */
        image-rendering: pixelated;
      }
      .header-buttons-left,
      .header-buttons-right {
        display: flex;
        gap: 10px;
      }
      .header-buttons-left button,
      .header-buttons-right button {
        padding: 4px 8px;
        border: none;

        cursor: pointer;
        transition: background-color 0.2s;
        font-size: 1em;
      }
      #new-game-btn {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/new.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #new-game-btn:hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/new_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #fullscreen-btn {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/full.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #fullscreen-btn:hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/full_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }

      #main-menu-btn {
        border-width: 5px;
        border-style: solid;
        border-color: transparent;
        border-image-source: url("assets/full.png");
        border-image-slice: 6 fill;
        border-image-repeat: round;
        background-color: transparent;
      }
      #main-menu-btn:hover {
        border-image-source: url("assets/full_hover.png");
      }
      #tutorial-btn {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/tuto.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #tutorial-btn:hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/tuto_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      .mode-selector button {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/tuto.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }

      .mode-selector button:not(.active):hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/tuto_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }

      .round-display {
        /* position, left, transform 속성 제거 */
        font-size: 1.4em;
        font-weight: normal;
        color: #9a4b37;
      }
      .player-area {
        background-color: #b95941;
        padding: 15px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        display: flex;
        flex-direction: column;
        transition: opacity 0.3s, box-shadow 0.3s;
        border: 4px solid transparent;
      }
      .player-area.disabled {
        background-color: #b95941;
      }

      .player-area h3 {
        font-weight: normal;
        margin: 0;
      }
      .hand {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-content: flex-start;
        height: 500px; /* 원하는 고정 높이값 (조정 가능) */
        overflow-y: auto; /* 내용이 넘칠 경우 스크롤 생성 */

        padding: 10px; /* 카드 효과가 그려질 내부 여백 확보 */
        box-sizing: border-box; /* padding이 높이 계산에 포함되도록 설정 */
        background-color: rgba(238, 218, 165, 0.65); /* 반투명 흰색 배경 */
      }
      .card {
        padding: 10px 15px;
        cursor: pointer;
        transition: all 0.2s;
      }
      .card.ai-hand {
        cursor: default;
      }
      .card-white {
        /* 카드 내용물을 위한 안쪽 여백 */
        padding: 7px;

        /* border-image를 위한 설정 */
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/card_white.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
      }
      .card-white:hover:not(.ai-hand) {
        /* 카드 내용물을 위한 안쪽 여백 */
        padding: 7px;

        /* border-image를 위한 설정 */
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/card_white_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
      }
      .card-black {
        color: white;
        /* 카드 내용물을 위한 안쪽 여백 */
        padding: 7px;

        /* border-image를 위한 설정 */
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/card_black.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
      }
      .card-black:hover:not(.ai-hand) {
        color: white;
        /* 카드 내용물을 위한 안쪽 여백 */
        padding: 7px;

        /* border-image를 위한 설정 */
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/card_black_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
      }
      .game-board {
        display: flex;
        flex-direction: column;
        gap: 0px;
        min-height: 0;
        position: relative;
      }
      #current-proposition {
        /* 카드 내용물을 위한 안쪽 여백 */
        padding: 7px;

        /* border-image를 위한 설정 */
        border-width: 20px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/papiru.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
      }
      #current-proposition {
        min-height: 120px;
        display: flex;
        flex-direction: column;
      }

      #background-box {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 300px; /* 👈 높이를 고정값으로 직접 지정 */
        z-index: -1;
        /* 1. 이미지 파일 불러오기 */
        background-image: url("assets/cloud.png"); /* 👈 여기에 파일 경로를 입력하세요 */
        background-size: 340px 340px; /* 👈 64px에서 128px로 2배 확대 */
        image-rendering: pixelated; /* 👈 이미지를 선명하게 유지하는 핵심 속성 */

        background-repeat: repeat; /* 배경 이미지를 바둑판식으로 반복 */
      }
      #proposition-display {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        min-height: 50px;
        flex-grow: 1;
        align-items: center;
      }
      #proposition-controls {
        margin-top: 10px;
        display: flex;
        gap: 10px;
      }
      #complete-btn {
        color: white;
        padding: 0;
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/complete.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        image-rendering: pixelated;
      }
      #complete-btn:hover:not(:disabled) {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/complete_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        image-rendering: pixelated;
      }
      #undo-btn {
        color: white;
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/undo.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        image-rendering: pixelated;
      }
      #undo-btn:hover:not(:disabled) {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/undo_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        image-rendering: pixelated;
      }
      #end-turn-btn {
        color: white;
        margin-left: auto;
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/end.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        image-rendering: pixelated;
      }
      #end-turn-btn:hover:not(:disabled) {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/end_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        image-rendering: pixelated;
      }
      #true-propositions {
        /* 카드 내용물을 위한 안쪽 여백 */
        padding: 15px;

        /* border-image를 위한 설정 */
        border-width: 20px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/papiru_1.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        image-rendering: pixelated;

        /* --- 수정된 부분 --- */
        flex-grow: 1; /* 남는 공간을 차지하려는 성질 */
        flex-shrink: 1; /* 공간이 부족할 때 줄어들려는 성질 */
        flex-basis: 0; /* 핵심: 내용물 크기를 무시하고 0에서부터 공간을 계산하도록 설정 */
        /* ------------------ */

        overflow-y: auto;
        min-height: 0;
      }

      #true-propositions h3 {
        margin-top: 0;
      }
      #true-propositions ul {
        padding-left: 0;
        list-style-type: none;
        margin: 0;
      }
      #true-propositions li {
        margin-bottom: 8px;
        padding: 8px;
        background-color: #fff;

        border-left: 4px solid #3498db;
      }
      #true-propositions li.victory-condition {
        border-left-color: #f1c40f;
        font-weight: normal;
        background-color: #fef9e7;
      }
      #true-propositions li.axiom-wrapper {
        padding: 0;
        border-left: none;
      }
      #true-propositions li.theorem {
        border-left-color: #8e44ad;
        font-style: italic;
        background-color: #f5eef8;
      }
      .word-a {
        color: #7f8c8d;
      }
      .word-b {
        color: #2c3e50;
      }
      details {
        background-color: #fff;

        margin-bottom: 8px;
      }
      summary {
        padding: 5px;
        cursor: pointer;
        font-weight: normal;
      }
      .axiom-list {
        padding: 5px 15px 15px 35px;
        background-color: #fafafa;
        border-top: 1px solid #eee;
      }
      .axiom-list p {
        margin: 4px 0;
        font-size: 14px;
      }
      .status-bar {
        height: 46px; /* 고정 높이 부여 (값은 적절히 조절) */
        display: flex; /* 내부 요소를 flexbox로 정렬 */
        align-items: center; /* 세로 중앙 정렬 */
        justify-content: center; /* 가로 중앙 정렬 */
        grid-column: 1 / -1;
        text-align: center;
        padding: 15px;
        font-weight: normal;
        font-size: 1.2em;
        background-color: transparent;
        margin: 0 -40px;
        min-height: 40px; /* Give it some default height */
        background-image: url("assets/bottom.png"); /* 👈 사용할 단일 이미지 경로 */
        background-repeat: no-repeat; /* 👈 이미지 반복 안 함 */
        background-size: cover; /* 👈 박스를 덮도록 크기 조절 (또는 contain) */
        background-position: center; /* 👈 이미지를 중앙에 배치 */
        image-rendering: pixelated;
      }
      /* 이 코드를 style 태그 안에 추가하세요 */
      .player-title-box {
        padding: 10px; /* 내부 여백 */
        text-align: center; /* 텍스트 가운데 정렬 */
        margin-bottom: 15px; /* 카드 목록(hand)과의 간격 */
        background-image: url("assets/player.png"); /* 👈 사용할 단일 이미지 경로 */
        background-repeat: no-repeat; /* 👈 이미지 반복 안 함 */
        background-size: contain; /* 👈 박스를 덮도록 크기 조절 (또는 contain) */
        background-position: center; /* 👈 이미지를 중앙에 배치 */
        image-rendering: pixelated;
      }
      .eureka-btn {
        margin-top: auto;
        padding: 10px 15px;
        border: none;
        color: #333;
        font-size: 1.1em;
        cursor: pointer;
        transition: background-color 0.2s;
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/eureka.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      .eureka-btn:hover:not(:disabled) {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/eureka_1.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      .eureka-btn:disabled {
        cursor: not-allowed;
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/eureka_disabled.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #proposition-controls button:disabled {
        color: #464646;
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/disabled.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        cursor: not-allowed;
      }
      .modal {
        position: fixed;
        z-index: 100;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.6);
        display: none;
        align-items: center;
        justify-content: center;
      }
      .modal.visible {
        display: flex;
      }
      .modal-content {
        padding: 20px;

        border-width: 20px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/papiru_3.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */

        width: 80%;
        max-width: 800px;
        position: relative;
      }
      .modal-content-small {
        border-width: 20px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/papiru_3.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */

        padding: 30px;
        text-align: center;
        max-width: 500px;
        width: 90%;
      }
      .close-button {
        color: #000000;
        position: absolute;
        padding: 15px;
        top: 17px;
        right: 33px;
        font-size: 20px;
        font-weight: normal;
        cursor: pointer;
        background-image: url("assets/close.png"); /* 👈 아이콘은 background-image로 설정해야 합니다. */
        background-repeat: no-repeat; /* 👈 아이콘이 반복되지 않도록 설정 */
        background-size: contain; /* 👈 버튼 크기에 맞춰 아이콘 크기 조절 */
        background-position: center; /* 👈 아이콘을 중앙에 배치 */
        image-rendering: pixelated;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        border: none; /* 테두리 제거 */
        z-index: 10;
      }
      .close-button:hover {
        background-image: url("assets/close_hover.png"); /* 👈 아이콘은 background-image로 설정해야 합니다. */
        background-repeat: no-repeat; /* 👈 아이콘이 반복되지 않도록 설정 */
        background-size: contain; /* 👈 버튼 크기에 맞춰 아이콘 크기 조절 */
        background-position: center; /* 👈 아이콘을 중앙에 배치 */
        image-rendering: pixelated;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        border: none; /* 테두리 제거 */
        color: black;
      }
      .proof-container {
        background-color: #eedaa5;
        display: flex;
        gap: 20px;
        margin-top: 15px;
      }
      .premise-selection {
        flex: 1;
        background-color: #eedaa5;
        padding: 15px;

        height: 50vh;
        overflow-y: auto;
      }
      .premise-selection ul {
        list-style-type: none;
        padding: 0;
      }
      .premise-selection li {
        margin-bottom: 5px;
        padding: 8px;
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/pre_li.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */

        width: 80%;
        max-width: 800px;
        position: relative;

        cursor: pointer;
      }

      .premise-selection li.assumption-dependent {
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/pre_li_assu.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        font-style: italic;
      }
      .premise-selection li.assumption-itself {
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/pre_li_assu.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        font-style: italic;
      }
      .premise-selection li:hover {
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/pre_li_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #modal-confirm-btn {
        color: white;
        margin-top: 20px;
        padding: 12px 25px;
        font-size: 1.2em;
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/confirm.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */

        cursor: pointer;
      }
      #modal-confirm-btn:hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/confirm_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #workbench-controls {
        display: flex;
        gap: 10px;
        align-items: center;
        justify-content: center;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 1px solid #eee;
      }
      #apply-rule-btn {
        color: black;
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/full.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */

        cursor: pointer;
      }
      #apply-rule-btn:hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/full_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */

        cursor: pointer;
      }
      #add-assumption-btn {
        color: black;
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/tuto.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */

        cursor: pointer;
      }
      #add-assumption-btn:hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/tuto_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #add-assumption-btn:disabled {
        display: none;
        cursor: not-allowed;
      }
      #cancel-assumption-btn {
        color: black;
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/undo.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #cancel-assumption-btn:hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/undo_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #thinking-time-controls {
        display: none;
        text-align: center;
        /* 카드 내용물을 위한 안쪽 여백 */
        padding: 15px;

        /* border-image를 위한 설정 */
        border-width: 20px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/papiru_1.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;

        margin-top: 0;
      }
      #end-thinking-time-btn {
        margin-top: 10px;
        padding: 10px 20px;
        font-size: 1.1em;
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/think.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        color: black;

        cursor: pointer;
      }
      #end-thinking-time-btn:hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/think_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #prompt-input {
        width: 100%;
        padding: 8px;
        margin-top: 15px;
        margin-bottom: 15px;
      }
      .modal-buttons {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 20px;
      }
      .modal-buttons button {
        padding: 8px 16px;

        border: none;
        cursor: pointer;
        font-weight: normal;
      }

      #alert-ok-btn {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/tuto.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #alert-ok-btn:hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/tuto_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #prompt-confirm-btn {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/complete.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #prompt-confirm-btn:hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/complete_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #prompt-cancel-btn {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/undo.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #prompt-cancel-btn:hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/undo_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #tutorial-modal .modal-content {
        max-width: 800px;
        height: 70vh;
        overflow-y: auto;
      }
      #tutorial-modal h3 {
        border-bottom: 2px solid #eee;
        padding-bottom: 10px;
        margin-top: 20px;
      }
      #tutorial-modal ul {
        list-style-position: inside;
        padding-left: 10px;
      }
      #tutorial-modal li {
        margin-bottom: 10px;
        line-height: 1.6;
      }
      #tutorial-modal code {
        background-color: #e9ecef;
        padding: 2px 6px;
      }
      /* Modal Styles */
      #language-modal .modal-content-small,
      #character-select-modal .modal-content-small {
        border-width: 20px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/papiru_3.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      .selection-buttons {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 25px;
      }
      .selection-buttons button {
        padding: 15px 30px;
        font-size: 1.2em;
        font-weight: normal;
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/tuto.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */

        cursor: pointer;
        transition: all 0.3s ease;
      }
      .selection-buttons button:hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/tuto_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        transform: translateY(-3px);
      }

      /* Tutorial Styles */
      .tutorial-highlight {
        box-shadow: 0 0 0 4px #639bff, 0 0 20px #6da2ff; /* 👈 파란색으로 변경 */

        transition: box-shadow 0.3s ease-in-out;
        position: relative;
        z-index: 101; /* Ensure it's above other elements */
      }
      #tutorial-guide {
        position: fixed; /* 👈 absolute에서 fixed로 변경된 것이 핵심입니다. */
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(44, 62, 80, 0.9);
        color: white;
        padding: 20px;
        width: 80%;
        max-width: 700px;
        text-align: center;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        z-index: 200; /* 이 값은 코드 하단의 !important 규칙으로 덮어써집니다. */
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
        transition: top 0.3s ease-in-out, bottom 0.3s ease-in-out;
      }
      #tutorial-guide.top {
        top: 20px;
        bottom: auto;
      }
      #tutorial-guide p {
        margin: 0;
        font-size: 1.1em;
        line-height: 1.6;
      }
      #tutorial-guide button {
        padding: 10px 25px;
        font-size: 1em;
        font-weight: normal;
        border: none;

        cursor: pointer;
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/tuto.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        transform: translateY(-3px);
        color: #2c3e50;
      }
      #tutorial-guide button:hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/tuto_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      .hidden {
        display: none !important;
      }
      #bottom-background-box {
        position: fixed; /* 화면 하단에 고정 */
        bottom: 0;
        left: 0;
        width: 100%; /* 좌우 꽉 채우기 */
        height: 40px; /* 상태표시줄 중간까지의 높이 (조정 가능) */
        z-index: -1; /* 다른 요소들 뒤로 보내기 */

        /* 1. 이미지 파일 불러오기 */
        background-image: url("assets/grass.png"); /* 👈 여기에 파일 경로를 입력하세요 */
        background-size: 150px 150px; /* 👈 64px에서 128px로 2배 확대 */
        image-rendering: pixelated; /* 👈 이미지를 선명하게 유지하는 핵심 속성 */

        background-repeat: repeat; /* 배경 이미지를 바둑판식으로 반복 */
      }

      .turn-indicator {
        display: inline-block;
        padding: 8px 20px; /* 내부 여백 *
        transition: all 0.3s ease; /* 부드러운 전환 효과 */
        text-align: center; /* 텍스트 가운데 정렬 */
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/indi.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        image-rendering: pixelated;
      }

      button,
      select {
        font-family: inherit;
      }
      #info-box > div {
        position: relative; /* 위치를 상대적으로 조정하도록 설정 */
        top: 6px; /* 👈 원래 위치에서 5px 아래로 이동 */
      }
      .header-buttons-left,
      .header-buttons-right {
        flex: 1; /* 양쪽 컨테이너가 동일한 너비를 갖도록 설정 */
      }

      /* 오른쪽 버튼들을 오른쪽 끝으로 정렬 */
      .header-buttons-right {
        justify-content: flex-end;
      }
      /* 승리 조건 텍스트의 strong 태그 볼드체 제거 */
      #true-propositions li.victory-condition strong {
        font-weight: normal;
      }
      /* 기존 코드 */
      #proposition-controls button {
        padding: 8px 15px;
        cursor: pointer;
        font-size: 14px;
        font-weight: normal;
        transition: background-color 0.2s;
        /* 👇 아래 속성 추가 */
        min-width: 100px; /* 원하는 최소 너비로 조절 (예: 100px) */
        box-sizing: border-box; /* padding을 너비에 포함시켜 계산 */
      }
      /* 튜토리얼 대화창을 강제로 최상단에 표시하기 위한 규칙 */
      #tutorial-guide {
        z-index: 9999 !important;
      }
      /* 새로 추가: 턴이 아닐 때 카드에 직접 흐림 및 반투명 효과 적용 */
      /* 턴이 아닐 때 카드의 밝기와 대비를 조절 */
      .player-area.disabled .card {
        filter: brightness(0.7) contrast(0.7);
      }
      #workbench-controls select,
      #workbench-controls button {
        font-size: 16px; /* 글자 크기를 14px에서 16px로 키웁니다 */
        padding: 10px 20px; /* 버튼의 상하, 좌우 여백을 늘립니다 */
      }

      #game-over-modal {
        display: none; /* 기본적으로 숨김 */
        position: fixed; /* 화면에 고정 */
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: transparent;
        z-index: 100; /* 다른 요소보다 위에 표시 */
        align-items: center;
        justify-content: center;
      }

      /* index.html 파일의 <style> 태그 안 */

      /* 기준점이 되는 부모 요소 */
      .game-over-content {
        position: relative; /* ★★★★★ 가장 중요! 이게 없으면 오버레이가 엉뚱한 곳에 표시됩니다. */
        width: 80vw;
        max-width: 1024px;
        aspect-ratio: 13 / 9;
        padding: 0;
        border: none;
        background-color: transparent;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
      }

      /* 기본 배경 이미지 스타일 */
      .game-over-image {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }

      /* 덧씌울 이미지들을 담는 컨테이너 */
      #overlay-container {
        position: absolute; /* 부모 위에 겹치도록 설정 */
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      /* 덧씌울 개별 이미지 */
      .overlay-image {
        position: absolute; /* 컨테이너 위에 겹치도록 설정 */
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: contain;
      }

      /* 이미지를 숨기는 핵심 클래스 */
      .hidden {
        display: none !important; /* ★★★★★ 가장 중요! */
      }
      #socrates-wise-overlay,
      #socrates-foolish-overlay,
      #socrates-good-overlay,
      #socrates-evil-overlay,
      #plato-wise-overlay,
      #plato-foolish-overlay,
      #plato-good-overlay,
      #plato-evil-overlay,
      #socrates-bird-overlay,
      #socrates-fish-overlay,
      #plato-bird-overlay,
      #plato-fish-overlay,
      #socrates-win-overlay,
      #plato-win-overlay {
        z-index: 1;
      }
      #socrates-dog-overlay,
      #plato-dog-overlay {
        z-index: 2;
      }

      #player-a-area {
        /* 1. 이미지 파일 불러오기 */
        background-image: url("assets/paper_1.png"); /* 👈 사용할 단일 이미지 경로 */
        background-repeat: no-repeat; /* 👈 이미지 반복 안 함 */
        background-size: cover; /* 👈 박스를 덮도록 크기 조절 (또는 contain) */
        background-position: center; /* 👈 이미지를 중앙에 배치 */
        image-rendering: pixelated;
      }

      #player-b-area {
        /* 1. 이미지 파일 불러오기 */
        background-image: url("assets/paper.png"); /* 👈 사용할 단일 이미지 경로 */
        background-repeat: no-repeat; /* 👈 이미지 반복 안 함 */
        background-size: cover; /* 👈 박스를 덮도록 크기 조절 (또는 contain) */
        background-position: center; /* 👈 이미지를 중앙에 배치 */
        image-rendering: pixelated;
      }
      /* style 태그 안, 가장 아래쪽에 추가 */
      body::after {
        position: absolute;
        width: 0;
        height: 0;
        overflow: hidden;
        z-index: -1; /* 화면에 보이지 않게 처리 */
        content: url("assets/new_hover.png") url("assets/full_hover.png")
          url("assets/tuto_hover.png") url("assets/mode_hover.png")
          url("assets/card_white_hover.png") url("assets/card_black_hover.png")
          url("assets/complete_hover.png") url("assets/undo_hover.png")
          url("assets/end_hover.png") url("assets/eureka_1.png")
          url("assets/close_hover.png") url("assets/confirm_hover.png")
          url("assets/think_hover.png"); /* 깜빡이는 모든 hover 이미지 경로 추가 */
      }

      /* ...existing code... */
      .main-center-bg {
        position: absolute;
        inset: 0; /* top:0; right:0; bottom:0; left:0; */
        width: 96%;
        height: 96%;
        background: transparent;
        z-index: 1; /* 배경 역할 */
        pointer-events: auto;
        border-width: 15px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/papiru_1.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: round;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .main-center-buttons {
        display: flex;
        flex-direction: column; /* 세로로 배치 */
        gap: 24px;
        align-items: center;
        z-index: 2;
        position: relative;
      }

      .main-center-buttons {
        display: flex;
        flex-direction: column;
        gap: 24px;
        align-items: center;
        z-index: 2;
        position: relative;
      }

      .mode-selector {
        display: flex;
        flex-direction: column; /* 버튼을 세로로 배치 */
        gap: 30px; /* 버튼 사이 넉넉하게 */
        width: 100%;
      }

      .mode-selector button,
      #tutorial-btn {
        min-width: 0;
        width: 100%;
        max-width: 1000px;
        padding: 8px 50px; /* 위아래 좁게, 좌우 넓게 */
        font-size: 1.5em;
        box-sizing: border-box;
      }

      .main-center-bg.hidden {
        display: none !important;
      }

      /* Add these CSS rules inside the <style> tag */

      #character-selection-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 500;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 40px;
        box-sizing: border-box;
      }

      #character-selection-screen.hidden {
        display: none !important;
      }

      .player-display-area {
        width: 28%;
        height: 80%;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
        box-sizing: border-box;
        border: 4px solid #b95941;
        background-color: rgba(238, 218, 165, 0.85);
        position: relative;
      }

      .portrait-area {
        width: 100%;
        height: 50%;
        background-color: #333;
        background-size: contain;
        background-position: center;
        background-repeat: no-repeat;
        image-rendering: pixelated;
        border: 2px solid #9a4b37;
      }

      .philosopher-name {
        font-size: 2.5em;
        color: #9a4b37;
        margin-top: 20px;
        font-weight: bold;
      }

      .skill-area {
        width: 100%;
        margin-top: 20px;
        text-align: left;
      }

      .skill-title {
        font-size: 1.5em;
        color: #333;
        border-bottom: 2px solid #b95941;
        padding-bottom: 5px;
        margin-bottom: 10px;
      }

      #p1-skill-desc,
      #p2-skill-desc {
        font-size: 1.1em;
        line-height: 1.6;
      }

      .ready-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(44, 62, 80, 0.8);
        color: #f1c40f;
        font-size: 8em;
        display: none; /* Initially hidden */
        align-items: center;
        justify-content: center;
        font-weight: bold;
        text-shadow: 4px 4px 0 #000;
      }

      .ready-overlay.visible {
        display: flex;
      }

      .shared-selection-area {
        width: 40%;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 30px;
      }

      .char-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr); /* 4열 그리드, 필요시 조정 */
        gap: 15px;
        width: 100%;
        padding: 20px;
        background-color: rgba(0, 0, 0, 0.3);
        border: 2px solid #fff;
      }

      .char-icon {
        aspect-ratio: 1 / 1;
        background-size: cover;
        background-position: center;
        border: 4px solid transparent;
        cursor: pointer;
        transition: all 0.2s ease;
        image-rendering: pixelated;
      }

      .char-icon:hover {
        border-color: #f1c40f;
        transform: scale(1.05);
      }

      .char-icon.selected {
        border-color: #e74c3c;
        box-shadow: 0 0 15px #e74c3c;
      }

      #confirm-selection-btn {
        padding: 15px 50px;
        font-size: 1.8em;
        border: none;
        cursor: pointer;
        background-color: #2ecc71;
        color: white;
        transition: background-color 0.2s;
      }

      #confirm-selection-btn:hover:not(:disabled) {
        background-color: #27ae60;
      }

      #confirm-selection-btn:disabled {
        background-color: #7f8c8d;
        cursor: not-allowed;
      }

      #turn-order-modal .modal-content-small h2 {
        font-size: 1.8em;
        margin-bottom: 25px;
      }
    </style>
  </head>
  <body>
    <!-- Language Selection Modal -->
    <div id="background-box"></div>
    <div id="background-box_1"></div>
    <div id="bottom-background-box"></div>
    <div id="language-modal" class="modal visible">
      <div class="modal-content-small">
        <h2>Choose Language / 언어 선택</h2>
        <div id="language-buttons" class="selection-buttons">
          <button id="lang-en">English</button>
          <button id="lang-ko">한국어</button>
        </div>
      </div>
    </div>

    <!-- Character Selection Modal -->
    <div id="character-select-modal" class="modal">
      <div class="modal-content-small">
        <h2 id="character-select-title"></h2>
        <div id="character-buttons" class="selection-buttons">
          <button id="select-socrates"></button>
          <button id="select-plato"></button>
        </div>
      </div>
    </div>

    <div id="character-selection-screen" class="hidden">
      <div class="player-display-area" id="p1-display">
        <div class="portrait-area" id="p1-portrait"></div>
        <div class="philosopher-name" id="p1-philosopher-name"></div>
        <div class="skill-area" id="p1-skill">
          <h3 class="skill-title">고유 능력</h3>
          <p id="p1-skill-desc"></p>
        </div>
        <div class="ready-overlay" id="p1-ready-overlay">READY</div>
      </div>

      <div class="shared-selection-area">
        <div class="char-grid" id="shared-char-grid"></div>
        <button id="confirm-selection-btn" disabled>확 인</button>
      </div>

      <div class="player-display-area" id="p2-display">
        <div class="portrait-area" id="p2-portrait"></div>
        <div class="philosopher-name" id="p2-philosopher-name"></div>
        <div class="skill-area" id="p2-skill">
          <h3 class="skill-title">고유 능력</h3>
          <p id="p2-skill-desc"></p>
        </div>
        <div class="ready-overlay" id="p2-ready-overlay">READY</div>
      </div>
    </div>

    <div id="turn-order-modal" class="modal">
      <div class="modal-content-small">
        <h2 id="turn-order-title">대전 순서를 선택하세요</h2>
        <div id="turn-order-buttons" class="selection-buttons">
          <button id="select-first-player">선공</button>
          <button id="select-second-player">후공</button>
        </div>
      </div>
    </div>

    <div class="container" id="container">
      <header>
        <h1 id="main-title">LOGOS</h1>
      </header>

      <div id="info-box">
        <div class="header-buttons-left">
          <button id="new-game-btn"></button>
        </div>
        <div class="round-display" id="round-display"></div>
        <div class="header-buttons-right">
          <button id="main-menu-btn"></button>
          <button id="fullscreen-btn"></button>
        </div>
      </div>

      <div class="player-area" id="player-a-area">
        <div class="player-title-box">
          <h3 id="player-a-title"></h3>
        </div>
        <div class="hand" id="player-a-hand"></div>
        <button class="eureka-btn" id="eureka-a"></button>
      </div>

      <div class="game-board">
        <div class="main-center-bg">
          <div class="main-center-buttons">
            <div class="mode-selector">
              <button id="vs-player-btn"></button>
              <button id="vs-ai-btn"></button>
            </div>
            <button id="tutorial-btn"></button>
          </div>
        </div>
        <div id="current-proposition">
          <h3 id="current-proposition-title"></h3>
          <div id="proposition-display"></div>
          <div id="proposition-controls">
            <button id="complete-btn"></button>
            <button id="undo-btn"></button>
            <button id="end-turn-btn"></button>
          </div>
        </div>
        <div id="true-propositions">
          <h3 id="true-propositions-title"></h3>
          <ul id="true-list"></ul>
        </div>
        <div id="thinking-time-controls">
          <h2 id="thinking-time-title"></h2>
          <p id="thinking-time-desc"></p>
          <button id="end-thinking-time-btn"></button>
        </div>
      </div>

      <div class="player-area" id="player-b-area">
        <div class="player-title-box">
          <h3 id="player-b-title"></h3>
        </div>
        <div class="hand" id="player-b-hand"></div>
        <button class="eureka-btn" id="eureka-b"></button>
      </div>

      <div class="status-bar" id="status"></div>
    </div>

    <div id="character-selection-screen" class="hidden">
      <div class="player-display-area" id="p1-display">
        <div class="portrait-area" id="p1-portrait"></div>
        <div class="skill-area" id="p1-skill">
          <h3>스킬 설명</h3>
          <p id="p1-skill-desc"></p>
        </div>
      </div>

      <div class="shared-selection-area">
        <div class="char-grid" id="shared-char-grid"></div>
        <button id="confirm-selection-btn" disabled>확인</button>
      </div>

      <div class="player-display-area" id="p2-display">
        <div class="portrait-area" id="p2-portrait"></div>
        <div class="skill-area" id="p2-skill">
          <h3>스킬 설명</h3>
          <p id="p2-skill-desc"></p>
        </div>
      </div>
    </div>

    <!-- Main Eureka Modal -->
    <div id="eureka-modal" class="modal">
      <div class="modal-content">
        <span class="close-button" id="close-eureka-modal-btn">&times;</span>
        <h2 id="eureka-title"></h2>
        <div id="workbench-controls">
          <select id="inference-rule-select"></select>
          <button id="apply-rule-btn"></button>
          <button id="add-assumption-btn"></button>
          <button id="cancel-assumption-btn"></button>
        </div>
        <div class="proof-container">
          <div class="premise-selection">
            <h3 id="premise-selection-title"></h3>
            <ul id="premise-list"></ul>
          </div>
        </div>
        <button id="modal-confirm-btn"></button>
      </div>
    </div>

    <!-- Tutorial Modal (previously Rules Modal) -->
    <div id="tutorial-modal" class="modal">
      <div class="modal-content">
        <span class="close-button" id="close-tutorial-modal-btn">&times;</span>
        <h2 id="tutorial-modal-title"></h2>
        <div id="tutorial-content">
          <!-- Tutorial content will be generated here by JavaScript -->
        </div>
      </div>
    </div>

    <!-- Custom Alert Modal -->
    <div id="alert-modal" class="modal">
      <div class="modal-content-small">
        <p id="alert-message"></p>
        <div class="modal-buttons">
          <button id="alert-ok-btn"></button>
        </div>
      </div>
    </div>

    <!-- Custom Prompt Modal -->
    <div id="prompt-modal" class="modal">
      <div class="modal-content-small">
        <p id="prompt-message"></p>
        <input type="text" id="prompt-input" />
        <div class="modal-buttons">
          <button id="prompt-cancel-btn"></button>
          <button id="prompt-confirm-btn"></button>
        </div>
      </div>
    </div>

    <!-- Tutorial Guide UI -->
    <div id="tutorial-guide" class="hidden">
      <p id="tutorial-text"></p>
      <button id="tutorial-next-btn"></button>
    </div>

    <div id="game-over-modal" class="modal">
      <div class="game-over-content">
        <button class="close-button" onclick="closeGameOverModal()">X</button>

        <img src="assets/endgame.png" alt="게임 종료" class="game-over-image" />

        <div id="overlay-container">
          <img
            id="socrates-bird-overlay"
            src="assets/so_bird.png"
            class="overlay-image hidden"
          />
          <img
            id="socrates-dog-overlay"
            src="assets/so_dog.png"
            class="overlay-image hidden"
          />
          <img
            id="socrates-fish-overlay"
            src="assets/so_fish.png"
            class="overlay-image hidden"
          />
          <img
            id="socrates-wise-overlay"
            src="assets/so_wise.png"
            class="overlay-image hidden"
          />
          <img
            id="socrates-foolish-overlay"
            src="assets/so_foolish.png"
            class="overlay-image hidden"
          />
          <img
            id="socrates-good-overlay"
            src="assets/so_good.png"
            class="overlay-image hidden"
          />
          <img
            id="socrates-evil-overlay"
            src="assets/so_evil.png"
            class="overlay-image hidden"
          />
          <img
            id="socrates-win-overlay"
            src="assets/so_wins.png"
            class="overlay-image hidden"
          />

          <img
            id="plato-win-overlay"
            src="assets/pl_wins.png"
            class="overlay-image hidden"
          />
          <img
            id="plato-bird-overlay"
            src="assets/pl_bird.png"
            class="overlay-image hidden"
          />
          <img
            id="plato-fish-overlay"
            src="assets/pl_fish.png"
            class="overlay-image hidden"
          />
          <img
            id="plato-dog-overlay"
            src="assets/pl_dog.png"
            class="overlay-image hidden"
          />
          <img
            id="plato-wise-overlay"
            src="assets/pl_wise.png"
            class="overlay-image hidden"
          />
          <img
            id="plato-foolish-overlay"
            src="assets/pl_foolish.png"
            class="overlay-image hidden"
          />
          <img
            id="plato-good-overlay"
            src="assets/pl_good.png"
            class="overlay-image hidden"
          />
          <img
            id="plato-evil-overlay"
            src="assets/pl_evil.png"
            class="overlay-image hidden"
          />
        </div>
      </div>
    </div>

    <script>
      // --- MULTILINGUAL TEXT DATA ---
      const TEXTS = {
        ko: {
          langCode: "ko",
          ui: {
            title: "LOGOS",
            tutorialButton: "튜토리얼",
            endTutorialButton: "튜토리얼 종료",
            newGameButton: "새 게임",
            vsAIButton: "1인 대전",
            vsPlayerButton: "2인 대전",
            fullscreenButton: "전체화면",
            playerAName: "소크라테스",
            playerAColor: "⚪️ 백",
            playerBName: "플라톤",
            playerBColor: "⚫️ 흑",
            currentPropositionTitle: "현재 명제",
            completeButton: "명제 완성",
            undoButton: "되돌리기",
            endTurnButton: "턴 종료",
            truePropositionsTitle: "참 명제 목록",
            eurekaButton: "유레카!",
            addTheoremButton: "정리 추가 ➕",
            roundDisplay: "제 {round} 라운드",
            axiomTitle: "기본 공리 (펼쳐보기)",
            statusTurn: "의 턴입니다.",
            statusAITurn: "AI가 생각 중입니다...",
            thinkingTimeStatus: "사유 시간입니다. 새로운 정리를 도출하세요.",
            thinkingTimeTitle: "사유(思惟) 시간",
            thinkingTimeDesc:
              "새로운 정리를 도출하고 '정리 추가' 버튼으로 목록에 반영하세요.<br>준비되면 아래 버튼을 눌러 다음 라운드를 시작합니다.",
            endThinkingTimeButton: "사유 시간 종료 & 다음 라운드 시작",
            victoryMessage: "플레이어의 승리!",
            victorySubMessage: "논리적인 증명에 성공했습니다!",
            okButton: "확인",
            cancelButton: "취소",
            nextButton: "다음",
            cancelAssumptionButton: "가정 취소",
          },
          modals: {
            characterSelectTitle: "철학자 선택",
            selectSocrates: "소크라테스 (백) ⚪️",
            selectPlato: "플라톤 (흑) ⚫️",
            eurekaTitleVictory: "유레카! 논증 구성",
            eurekaTitleTheorem: "사유 시간: 정리(Theorem) 구성",
            premiseSelectionTitle: "사용 가능한 전제 목록",
            applyRuleButton: "규칙 적용",
            addAssumptionButton: "가정하기",
            confirmVictoryButton: "이 논증으로 승리 증명!",
            confirmTheoremButton: "선택한 정리들을 참 목록에 추가 ➕",
            tutorialTitle: "LOGOS 튜토리얼",
            promptInputPlaceholder: "명제를 입력하세요...",
          },
          tutorial: [
            // Stage 1 (Index 0)
            [
              "LOGOS에 오신 것을 환영합니다!",
              "시작하기 전에, 몇 가지 핵심 규칙을 알려드릴게요.",
              "<strong>승리 조건:</strong> 매 게임 시작 시, 각자 고유하고 무작위로 정해진 <strong>승리 조건</strong>을 받습니다.<br><br><strong>유레카!</strong>를 선언하여 <strong>자신의 승리</strong>를 증명하거나 <strong>상대의 패배</strong>를 증명하면 이깁니다.<br><br>예를 들어, 당신의 철학자가 소크라테스라면<br><strong>소크라테스는 승리한다</strong>나 <strong>플라톤은 승리한다 는 거짓이다</strong>를 증명하면 됩니다.",
              "<strong>첫 턴:</strong> 첫 라운드는 언제나 소크라테스(백)가 먼저 시작합니다.<br><br><strong>선공 교대:</strong> 라운드가 바뀔 때마다 선공하는 플레이어가 교대됩니다.",
              "그럼, 가장 기본인 <strong>명제</strong>를 만드는 법부터 배워보죠.",
              "이곳이 당신의 <strong>패</strong>입니다. 여러 단어 카드가 있죠.",
              "카드를 이곳으로 옮겨 <strong>명제</strong>를 만들게 됩니다.",
              "카드를 클릭해서 <strong>현재 명제</strong> 영역으로 옮겨보세요.",
              "아주 좋습니다! <strong>소크라테스는</strong> 같은 <strong>고유 명사</strong>는 바로 명제를 시작할 수 있습니다.",
              "하지만 <strong>개는</strong>, <strong>새는</strong>, <strong>물고기는</strong> 같은 <strong>개체</strong> 카드는, 반드시 <strong>모든</strong>이나 <strong>어떤</strong>과 같은 <strong>양화사</strong> 카드 뒤에만 놓을 수 있습니다. 이 점을 꼭 기억해주세요!",
              "자, 이제 턴을 마쳐볼까요? LOGOS에서는 반드시 한 턴에 한 장의 카드를 내야 합니다.",
              "<strong>턴 종료</strong> 버튼을 눌러 상대에게 턴을 넘겨주세요.",
              "규칙을 잘 이해하셨군요!<br><br>이제 상대방이 완성한 명제에 어떻게 대응하는지 배워보겠습니다.",
            ],
            // Stage 2 (Index 1)
            [
              "상대방의 턴이 끝났습니다. 다시 당신의 턴입니다.",
              "상대방이 만든 명제가 문법적으로 완성되었네요. 이때 여러 행동을 선택할 수 있습니다.",
              "<strong>첫 번째 선택: 명제 완성.</strong> 상대방의 주장을 <strong>참</strong>으로 인정하는 것입니다. 지금은 아무런 모순이 없으니, <strong>명제 완성</strong> 버튼을 눌러 <strong>참 명제 목록</strong>에 추가해 봅시다.",
              "훌륭합니다! 하지만 명제가 추가되려면 두 가지 중요한 조건이 있습니다.",
              "첫째, 완전히 같은 명제가 이미 존재한다면 다시 추가할 수 없습니다.",
              "둘째, 기존의 진리와 모순되는 명제는 추가할 수 없습니다.",
              "이제 명제 완성의 규칙을 완전히 이해하셨습니다.<br>명제를 완성하는 대신, 다른 선택도 가능합니다.",
              "<strong>두 번째 선택: 확장하기.</strong> <strong>그리고</strong>, <strong>또는</strong>, <strong>라면</strong> 같은 <strong>연결사</strong> 카드를 추가하여 명제를 더 복잡하게 만들 수도 있습니다. 단, 연결사는 하나의 명제에 한 번만 사용할 수 있다는 점을 기억하세요.",
              "<strong>세 번째 선택: 부정하기.</strong> 자신에게 불리한 명제라면, 손패의 <strong>는 거짓이다</strong> 카드를 추가하여 명제를 부정할 수 있습니다.<br>하지만 조심하세요! 만약 상대방도 부정 카드를 낸다면, <strong>이중 부정</strong> 규칙에 따라 당신의 부정이 바로 무효화될 수 있습니다.<br><br>또한, 연결사로 연결된 문장에 <strong>는 거짓이다</strong>가 붙으면, 문장 전체가 아닌 연결사가 결합된 최소 단위 명제만 부정됩니다.<br><br>예를 들어, <strong>어떤 개는 선하다 그리고 소크라테스는 악하다 는 거짓이다</strong>에서 부정되는 부분은 <strong>소크라테스는 악하다</strong> 뿐입니다.",
              "이제 상대의 명제에 대응하는 여러 방법을 배웠습니다. 다음으로, 우리가 논증의 기반으로 삼을 수 있는 <strong>기본 공리</strong>에 대해 알아봅시다.",
            ],
            // Stage 3 (Index 2)
            [
              "참 명제 목록에는 우리가 만든 명제뿐만 아니라, 모든 논증의 기반이 되는 <strong>기본 공리</strong>가 들어있습니다.",
              "이 항목을 클릭해서 어떤 공리들이 있는지 확인해 보세요.",
              "공리는 증명할 필요 없이 참으로 받아들여지는 명제들입니다. 예를 들어 '모든 개는 개이다' 와 같은 것들이죠.",
              "공리에 따라, 동일한 개체가 '선하다'와 '악하다'처럼 <strong>두 가지 상반된 속성을 동시에 가질 수 없습니다</strong>.",
              "논증을 구성할 때, 이 공리들을 중요한 전제로 사용할 수 있습니다.",
              "이제 기본적인 진리들을 확인했으니, 카드를 낼 수 없을 때 어떤 일이 일어나는지 알아봅시다.",
            ],
            // Stage 4 (Index 3)
            [
              "턴이 돌아온 플레이어가 할 수 있는 행동이 없다면 라운드가 종료되고 <strong>사유 시간</strong>이 시작됩니다.",
              "사유 시간에는 <strong>유레카!</strong> 버튼이 <strong>정리 추가</strong> 버튼으로 바뀝니다.",
              "이 버튼을 눌러, 이미 증명된 진리들을 바탕으로 새로운 <strong>정리</strong>를 만들어낼 수 있습니다. 버튼을 눌러보세요.",
              "논증 구성창이 열렸습니다. 이제 <strong>보편 적용</strong> 규칙을 사용해 새로운 정리를 만들어 봅시다.",
              "전제 목록에서 <strong>소크라테스는 개이다</strong>와 <strong>모든 개는 지혜롭다</strong>를 선택하세요.",
              "추론 규칙에서 <strong>보편 적용</strong>을 선택하고, <strong>규칙 적용</strong> 버튼을 누르세요.",
              "좋습니다! <strong>소크라테스는 지혜롭다</strong>라는 새로운 정리가 도출되었습니다.<br><br>이제 이 정리를 선택하고 <strong>선택한 정리들을 참 목록에 추가</strong> 버튼을 눌러 증명을 마칩시다.",
              "새로운 정리가 <strong>참 명제 목록</strong>에 추가되었습니다!<br><br>이제 <strong>사유 시간 종료</strong> 버튼을 눌러 다음 라운드를 시작하세요.<br>라운드가 새로 시작되면 냈던 모든 카드를 돌려받으며, 참 명제 목록은 그대로 유지됩니다.",
            ],
            // Stage 5 (Index 4) - UPDATED & EXPANDED
            [
              "지금까지 게임의 흐름을 배웠습니다. 마지막으로, 승리를 위해 가장 중요한 <strong>추론 규칙</strong>들을 하나씩 익혀봅시다. <strong>유레카!</strong> 버튼을 눌러 논증 구성창을 여세요.",
              // 1. Modus Ponens
              "먼저 <strong>전건 긍정</strong>입니다. (P, P→Q)이면 Q를 도출하는, 가장 직관적인 규칙이죠.",
              "전제 목록에서 <strong>소크라테스는 선하다</strong>와 <strong>소크라테스는 선하다 라면 소크라테스는 승리한다</strong>를 선택하세요.",
              "규칙 목록에서 <strong>전건 긍정</strong>을 선택하고 <strong>규칙 적용</strong> 버튼을 누르세요.",
              // 2. Modus Tollens
              "좋습니다. <strong>소크라테스는 승리한다</strong>는 결론이 도출되었습니다. 이번에는 <strong>후건 부정</strong>을 연습해 봅시다.",
              "전제 목록에서 <strong>플라톤은 지혜롭다 는 거짓이다</strong>와 <strong>플라톤은 승리한다 라면 플라톤은 지혜롭다</strong>를 선택하세요.",
              "규칙 목록에서 <strong>후건 부정</strong>을 선택하고 <strong>규칙 적용</strong> 버튼을 누르세요.",
              // 3. Disjunctive Syllogism
              "훌륭합니다! <strong>플라톤은 승리한다 는 거짓이다</strong>라는 결론이 나왔군요. 다음은 <strong>선언적 삼단논법</strong>입니다.",
              "전제 목록에서 <strong>어떤 새는 물고기이다 또는 어떤 새는 새이다</strong>와 <strong>어떤 새는 물고기이다 는 거짓이다</strong>를 선택하세요. <strong>또는</strong>으로 연결된 것 중 하나가 거짓이면, 나머지는 참이겠죠?",
              "규칙 목록에서 <strong>선언적 삼단논법</strong>을 선택하고 <strong>규칙 적용</strong> 버튼을 누르세요.",
              // 4. Hypothetical Syllogism
              "<strong>어떤 새는 새이다'</strong>가 도출되었습니다. 이번엔 <strong>가설적 삼단논법</strong>입니다. 꼬리물기처럼 이어지는 두 명제를 하나로 합쳐봅시다.",
              "전제 목록에서 <strong>플라톤은 개이다 라면 플라톤은 선하다</strong>와 <strong>플라톤은 선하다 라면 플라톤은 승리한다</strong>를 선택하세요.",
              "규칙 목록에서 <strong>가설적 삼단논법</strong>을 선택하고 <strong>규칙 적용</strong> 버튼을 누르세요.",
              // 5. Conjunction Elimination (Simplification)
              "좋습니다! <strong>플라톤은 개이다 라면 플라톤은 승리한다</strong>라는 더 간결한 명제가 만들어졌습니다. 다음은 <strong>단순화</strong> 규칙입니다.",
              "<strong>그리고</strong>로 연결된 명제는 각각이 참입니다. 전제 목록에서 <strong>소크라테스는 지혜롭다 그리고 플라톤은 어리석다</strong>를 선택하세요.",
              "규칙 목록에서 <strong>단순화</strong>를 선택하고 <strong>규칙 적용</strong> 버튼을 눌러보세요. 두 개의 명제가 한 번에 도출될 겁니다.",
              // 6. Double Negation Elimination
              "보시다시피 두 명제가 각각 분리되었습니다. 이제 <strong>이중 부정 제거</strong> 규칙을 배워봅시다. 부정을 두 번 하면 긍정이 되죠.",
              "전제 목록에서 <strong>어떤 물고기는 선하다 는 거짓이다 는 거짓이다</strong>를 선택하세요.",
              "규칙 목록에서 <strong>이중 부정 제거</strong>를 선택하고 <strong>규칙 적용</strong> 버튼을 누르세요.",
              // 7. Universal Application
              "원래의 긍정 명제로 돌아왔습니다. 다음은 <strong>보편 적용</strong> 규칙입니다. 보편적인 규칙은 개별 사례에도 적용됩니다.",
              "전제 목록에서 <strong>모든 새는 선하다</strong>와 <strong>플라톤은 새이다</strong>를 선택하세요.",
              "규칙 목록에서 <strong>보편 적용</strong>을 선택하고 <strong>규칙 적용</strong> 버튼을 누르세요.",
              // 8. Existential Instantiation
              "정확합니다. 마지막으로 <strong>존재화</strong> 규칙입니다. <strong>모든</strong>이 참이라면, <strong>어떤</strong> 일부도 당연히 참입니다.",
              "전제 목록에서 <strong>모든 개는 선하다</strong>를 선택하세요.",
              "규칙 목록에서 <strong>존재화</strong>를 선택하고 <strong>규칙 적용</strong> 버튼을 누르세요.",
              // End of Stage 5
              "훌륭합니다! 이제 LOGOS의 모든 기본 추론 규칙을 마스터하셨습니다. 다음으로 여러 개의 명제를 한번에 조합하는 강력한 규칙을 배워봅시다.",
            ],
            // Stage 6 (Index 5)
            [
              "이번에 배울 <strong>경우 논증</strong>은 여러 갈래의 길을 하나의 결론으로 모으는 강력한 규칙입니다.",
              "<strong>플라톤은 선하거나 악하다</strong>는 두 가지 경우가 있습니다. 그런데 어느 경우든 <strong>플라톤은 지혜롭다</strong>는 결론에 도달하는군요. 먼저, 필요한 전제 세 가지를 모두 선택해주세요.",
              "좋습니다. 이제 추론 규칙 목록에서 <strong>경우 논증</strong>을 선택하고 <strong>규칙 적용</strong> 버튼을 눌러 결론을 도출하세요.",
              "완벽합니다! <strong>플라톤은 지혜롭다</strong>는 결론이 도출되었습니다. 기본적인 규칙들에 익숙해지셨군요. 다음은 논리학의 꽃이라 불리는 <strong>가정</strong>을 사용하는 규칙입니다.",
            ],
            // Stage 7 (Index 6) - ★★★ MODIFIED SECTION ★★★
            [
              "때로는 증명을 위해 무언가를 <strong>만약 ~라면</strong> 하고 가정해야 할 때가 있습니다. 이번에는 두 개의 전제를 논리적으로 연결해 봅시다.",
              "<strong>가정하기</strong> 버튼을 눌러 <strong>소크라테스는 지혜롭다</strong>를 입력해 가정해 보세요.",
              "좋습니다. 이제 가정과 첫 번째 전제인 <strong>소크라테스는 지혜롭다 라면 플라톤은 개이다</strong>를 선택하세요.",
              "<strong>전건 긍정</strong> 규칙을 적용해 중간 결론을 도출하세요.",
              "훌륭합니다! 이제 방금 얻은 중간 결론과 두 번째 전제인 <strong>플라톤은 개이다 라면 플라톤은 선하다</strong>를 선택하세요.",
              "다시 <strong>전건 긍정</strong> 규칙을 적용해 최종 결론을 이끌어내세요.",
              "완벽합니다! 이제 <strong>조건문 도입</strong>의 마법을 볼 시간입니다. 최종 결과물인 <strong>플라톤은 선하다</strong>를 선택하세요.",
              "마지막으로, <strong>조건문 도입</strong> 규칙을 적용하세요. 그러면 <strong>소크라테스는 지혜롭다 라면 플라톤은 선하다</strong>라는 새로운 정리가 완성됩니다!",
              "훌륭합니다! 이제 귀류법에 대해 알아봅시다.",
            ],
            // Stage 8 (Index 7) - NEWLY ADDED
            [
              "<strong>귀류법</strong>은 증명하고 싶은 것의 <strong>반대</strong>를 가정하여 모순을 이끌어내는 방법입니다.",
              "우리의 목표는 <strong>소크라테스는 악하다</strong>를 증명하는 것입니다. <strong>가정하기</strong>로 그 반대인 <strong>소크라테스는 악하다 는 거짓이다</strong>를 가정하세요.",
              "가정이 추가되었습니다. 이제 이 가정을 이용해 명백한 모순, 즉 'P'와 '~P' 형태의 한 쌍을 만들어 봅시다. 방금 만든 가정과 다른 전제를 선택하고 <strong>전건 긍정</strong> 규칙을 적용해 보세요.",
              "보세요! <strong>플라톤은 지혜롭다</strong>가 도출되었습니다. 하지만 이미 참인 명제 목록에 <strong>플라톤은 지혜롭다 는 거짓이다</strong>가 있었죠. 이것이 바로 모순입니다!",
              "이제 모순되는 두 명제를 모두 선택하고 <strong>귀류법</strong> 규칙을 적용하세요.",
              "최초의 가정이 틀렸다는 것이 증명되었습니다! 이제 마지막으로 <strong>이중 부정 제거</strong> 규칙을 적용하여 최종 결론을 얻어내세요.",
              "완벽합니다! 이제 LOGOS의 모든 것을 배우셨습니다. 직접 논리의 대결에 참여하여 당신의 지혜를 증명해 보세요!",
            ],
          ],
          inferenceRules: {
            basic: "기본 규칙",
            modusPonens: "전건 긍정 (P, P→Q ∴ Q)",
            modusTollens: "후건 부정 (~Q, P→Q ∴ ~P)",
            hypotheticalSyllogism: "가설적 삼단논법 (P→Q, Q→R ∴ P→R)",
            disjunctiveSyllogism: "선언적 삼단논법 (P∨Q, ~P ∴ Q)",
            universalApplication: "보편 적용 (A는 P다, 모든 P는 Q다 ∴ A는 Q다)",
            existentialInstantiation: "존재화 (모든 P는 Q다 ∴ 어떤 P는 Q다)",
            conjunctionElimination: "단순화 (P∧Q ∴ P, Q)",
            doubleNegationElimination: "이중 부정 제거 (~(~P) ∴ P)",
            assumptionBased: "가정 기반 규칙",
            conditionalIntroduction: "조건문 도입 (P 가정, Q 도출 ∴ P→Q)",
            reductioAdAbsurdum: "귀류법 (P 가정, 모순 도출 ∴ ~P)",
            advanced: "고급 규칙",
            proofByCases: "경우 논증 (P∨Q, P→R, Q→R ∴ R)",
          },
          alerts: {
            invalidCard: "규칙에 맞지 않는 카드입니다!",
            incompleteProposition:
              "완성되지 않은 명제이거나 파싱에 실패했습니다.",
            duplicateProposition: "같은 명제가 이미 존재합니다.",
            contradictionFound:
              "모순이 발견되었습니다! 이 명제는 기존의 참 명제들과 양립할 수 없습니다.",
            undoLastCard: "마지막으로 놓은 카드를 되돌렸습니다.",
            undoLastProposition: "마지막으로 완성된 명제를 되돌렸습니다.",
            nothingToUndo: "되돌릴 수 있는 완성된 명제가 없습니다.",
            roundEndNoMoves:
              "'{player}' 플레이어가 더 이상 낼 수 있는 카드가 없어 라운드를 종료합니다.",
            criticalErrorUndo:
              "진리 체계를 재구성하는 중 심각한 오류가 발생했습니다. 게임을 새로 시작해야 할 수 있습니다.",
            oneAssumptionOnly: "가정은 한 번에 하나만 할 수 있습니다.",
            parsingFailed:
              "명제를 파싱할 수 없습니다. 올바른 형식으로 입력해주세요.",
            premiseNeededForIntro:
              "조건문 도입 규칙은 가정으로부터 도출된 '결론' 명제 하나만 선택해야 합니다.",
            assumptionNeededForIntro:
              "조건문 도입 규칙을 사용하려면 먼저 '가정하기'를 통해 가정을 해야 합니다.",
            premiseNotFromAssumption:
              "선택한 명제는 현재 가정과 무관합니다. 가정으로부터 파생된 명제를 선택하세요.",
            premiseCountError: "이 규칙은 {count}개의 전제가 필요합니다.",
            contradictionNeededForRAA:
              "귀류법은 서로 모순되는 2개의 전제가 필요합니다.",
            assumptionNeededForRAA:
              "귀류법을 적용하려면 먼저 '가정하기'를 통해 가정을 해야 합니다.",
            notAContradiction:
              "모순 관계가 아닙니다. 귀류법을 적용할 수 없습니다.",
            ruleFailed: "규칙 적용에 실패했습니다. 전제들을 확인해주세요.",
            noTheoremsToAdd: "추가할 새로운 정리가 없습니다.",
            proofIncomplete:
              "증명이 완료되지 않았습니다.\n자신의 승리 [{myGoal}] 또는\n상대의 패배 [{opponentGoal}] 를 도출해야 합니다.",
            oneCardPerTurn: "한 턴에 한 장의 카드만 낼 수 있습니다.",
            aiEurekaDeclared: "AI가 '유레카!'를 선언했습니다!",
          },
          keywords: {
            if: "라면",
            and: "그리고",
            or: "또는",
            not: "는 거짓이다",
            wins: "승리한다",
            socrates: "소크라테스는",
            plato: "플라톤은",
            universal_q: "모든",
            existential_q: "어떤",
          },
          cards: [
            { type: "양화사", text: "어떤" },
            { type: "양화사", text: "모든" },
            { type: "연산자", text: "라면" },
            { type: "연산자", text: "그리고" },
            { type: "연산자", text: "또는" },
            { type: "연산자", text: "는 거짓이다" },
            { type: "개체", text: "새는" },
            { type: "개체", text: "물고기는" },
            { type: "개체", text: "개는" },
            { type: "고유명사", text: "소크라테스는" },
            { type: "고유명사", text: "플라톤은" },
            { type: "서술어", text: "선하다" },
            { type: "서술어", text: "악하다" },
            { type: "서술어", text: "지혜롭다" },
            { type: "서술어", text: "어리석다" },
            { type: "서술어", text: "새이다" },
            { type: "서술어", text: "물고기이다" },
            { type: "서술어", text: "개이다" },
            { type: "서술어", text: "승리한다" },
          ],
          cardTypes: ["고유명사", "양화사", "개체", "서술어", "연산자"],
          axiom_templates: {
            identity: [
              "어떤 새는 새이다",
              "어떤 물고기는 물고기이다",
              "어떤 개는 개이다",
              "모든 새는 새이다",
              "모든 물고기는 물고기이다",
              "모든 개는 개이다",
            ],
            opposition_subjects: [
              "{S} 선하다 또는 {S} 악하다",
              "{S} 선하다 라면 {S} 악하다 는 거짓이다",
              "{S} 지혜롭다 또는 {S} 어리석다",
              "{S} 지혜롭다 라면 {S} 어리석다 는 거짓이다",
            ],
            opposition_quantifiers: [
              "모든 새는 선하다 라면 어떤 새는 악하다 는 거짓이다",
              "모든 새는 악하다 라면 어떤 새는 선하다 는 거짓이다",
              "모든 물고기는 선하다 라면 어떤 물고기는 악하다 는 거짓이다",
              "모든 물고기는 악하다 라면 어떤 물고기는 선하다 는 거짓이다",
              "모든 개는 선하다 라면 어떤 개는 악하다 는 거짓이다",
              "모든 개는 악하다 라면 어떤 개는 선하다 는 거짓이다",
              "모든 새는 지혜롭다 라면 어떤 새는 어리석다 는 거짓이다",
              "모든 새는 어리석다 라면 어떤 새는 지혜롭다 는 거짓이다",
              "모든 물고기는 지혜롭다 라면 어떤 물고기는 어리석다 는 거짓이다",
              "모든 물고기는 어리석다 라면 어떤 물고기는 지혜롭다 는 거짓이다",
              "모든 개는 지혜롭다 라면 어떤 개는 어리석다 는 거짓이다",
              "모든 개는 어리석다 라면 어떤 개는 지혜롭다 는 거짓이다",
              "어떤 새는 선하다 는 거짓이다 라면 모든 새는 악하다",
              "어떤 새는 악하다 는 거짓이다 라면 모든 새는 선하다",
              "어떤 물고기는 선하다 는 거짓이다 라면 모든 물고기는 악하다",
              "어떤 물고기는 악하다 는 거짓이다 라면 모든 물고기는 선하다",
              "어떤 개는 선하다 는 거짓이다 라면 모든 개는 악하다",
              "어떤 개는 악하다 는 거짓이다 라면 모든 개는 선하다",
              "어떤 새는 지혜롭다 는 거짓이다 라면 모든 새는 어리석다",
              "어떤 새는 어리석다 는 거짓이다 라면 모든 새는 지혜롭다",
              "어떤 물고기는 지혜롭다 는 거짓이다 라면 모든 물고기는 어리석다",
              "어떤 물고기는 어리석다 는 거짓이다 라면 모든 물고기는 지혜롭다",
              "어떤 개는 지혜롭다 는 거짓이다 라면 모든 개는 어리석다",
              "어떤 개는 어리석다 는 거짓이다 라면 모든 개는 지혜롭다",
            ],
          },
          victoryPredicates: ["선하다", "악하다", "지혜롭다", "어리석다"],
          contradictoryPredicates: { 선하다: "악하다", 지혜롭다: "어리석다" },
          labels: {
            proposition: "[명제]",
            axiom: "[공리]",
            victory_condition: "[승리 조건]",
            theorem: "[정리]",
            assumption: "[가정]",
            ci_theorem: "[조건문 도입]",
            raa_theorem: "[귀류법 증명]",
            theorem_source: "[정리] {text} (R{round} 사유)",
            victory_text: "{owner} 승리 조건: <strong>{text}</strong>",
          },
        },
        en: {
          langCode: "en",
          ui: {
            title: "LOGOS",
            tutorialButton: "Tutorial",
            endTutorialButton: "End Tutorial",
            newGameButton: "New Game",
            fullscreenButton: "Fullscreen",
            vsAIButton: "1P vs AI",
            vsPlayerButton: "1P vs 2P",
            playerAName: "Socrates",
            playerAColor: "⚪️ White",
            playerBName: "Plato",
            playerBColor: "⚫️ Black",
            currentPropositionTitle: "Current Proposition",
            completeButton: "Complete",
            undoButton: "Undo",
            endTurnButton: "End Turn",
            truePropositionsTitle: "True Propositions",
            eurekaButton: "Eureka!",
            addTheoremButton: "Add Theorem ➕",
            roundDisplay: "Round {round}",
            axiomTitle: "Basic Axioms (Click to expand)",
            statusTurn: "'s Turn",
            statusAITurn: "AI is thinking...",
            thinkingTimeStatus: "Thinking Time. Derive new theorems.",
            thinkingTimeTitle: "Thinking Time",
            thinkingTimeDesc:
              "Derive new theorems and add them to the list using the 'Add Theorem' button.<br>When ready, press the button below to start the next round.",
            endThinkingTimeButton: "End Thinking Time & Start Next Round",
            victoryMessage: "Player Wins!",
            victorySubMessage: "You have succeeded with a logical proof!",
            okButton: "OK",
            cancelButton: "Cancel",
            nextButton: "Next",
            cancelAssumptionButton: "Cancel",
          },
          modals: {
            characterSelectTitle: "Select Your Philosopher",
            selectSocrates: "Socrates (White) ⚪️",
            selectPlato: "Plato (Black) ⚫️",
            eurekaTitleVictory: "Eureka! Construct Proof",
            eurekaTitleTheorem: "Thinking Time: Construct Theorem",
            premiseSelectionTitle: "Available Premises List",
            applyRuleButton: "Apply",
            addAssumptionButton: "Assume",
            confirmVictoryButton: "Prove Victory with this Argument!",
            confirmTheoremButton: "Add Selected Theorems to True List ➕",
            tutorialTitle: "LOGOS Tutorial",
            promptInputPlaceholder: "Enter proposition...",
          },
          tutorial: [
            // Stage 1 (Index 0)
            [
              "Welcome to LOGOS!",
              "Before we begin, let's go over a few core rules.",
              "<strong>Win Condition:</strong> At the start of each game, you get a unique, random <strong>Win Condition</strong>.<br><br>You win by declaring <strong>Eureka!</strong> and proving either <strong>your own victory</strong> or <strong>your opponent's defeat</strong>.<br><br>For example, if your philosopher is Socrates, you win by proving either <strong>Socrates wins</strong> or <strong>Plato wins is false</strong>.",
              "<strong>First Turn:</strong> The first round always begins with Socrates (White).<br><br><strong>Alternating Turns:</strong> The starting player alternates each round.",
              "Now, let's learn the most basic action: how to form a <strong>proposition</strong>.",
              "This is your <strong>hand</strong>. It contains various word cards.",
              "You will move cards here to form a <strong>proposition</strong>.",
              "Click a card to move it to the <strong>Current Proposition</strong> area.",
              "Excellent! A <strong>Proper Noun</strong> like <strong>Socrates</strong> can start a proposition directly.",
              "However, <strong>Entity</strong> cards like <strong>dog</strong>, <strong>bird</strong>, and <strong>fish</strong> must always follow a <strong>Quantifier</strong> card like <strong>Every</strong> or <strong>Some</strong>. Please remember this rule!",
              "Now, shall we end the turn? In LOGOS, you must play exactly one card per turn.",
              "Press the <strong>End Turn</strong> button to pass the turn to your opponent.",
              "You've got it!<br><br>Now let's see how to respond to a proposition your opponent has made.",
            ],
            // Stage 2 (Index 1)
            [
              "Your opponent's turn is over, and now it's your turn.",
              "The proposition your opponent made is grammatically complete. You have several options now.",
              "<strong>First Option: Complete Proposition.</strong> This accepts the opponent's statement as <strong>true</strong>. Since there are no contradictions for now, let's press the <strong>Complete Proposition</strong> button to add it to the <strong>List of True Propositions</strong>.",
              "Excellent! However, there are two important conditions for a proposition to be added.",
              "First, you cannot add a proposition if the exact same one already exists.",
              "Second, you cannot add a proposition that contradicts an existing truth.",
              "Now you fully understand the rules for completing a proposition. Instead of completing it, other options are also available.",
              "<strong>Second Option: Extend.</strong> You can add <strong>connective</strong> cards like <strong>and</strong>, <strong>or</strong>, or <strong>then</strong> to make the proposition more complex. Remember, you can only use one connective per proposition.",
              "<strong>Third Option: Negate.</strong> If a proposition is disadvantageous, you can add the <strong>is false</strong> card from your hand to negate it.<br>But be careful! If your opponent also plays a negation card, your negation can be immediately nullified by the <strong>Double Negation</strong> rule.<br><br>Also, when <strong>is false</strong> is attached to a sentence with a connective, it only negates the smallest proposition it's attached to, not the whole sentence.<br><br>For example, in <strong>Some dog is good and Socrates is evil is false</strong>, only the <strong>Socrates is evil</strong> part is negated.",
              "Now you've learned the various ways to respond to an opponent's proposition. Next, let's learn about the <strong>Basic Axioms</strong> that form the foundation of our arguments.",
            ],
            // Stage 3 (Index 2)
            [
              "The List of True Propositions contains not only the propositions we've made, but also the <strong>Basic Axioms</strong> which are the foundation of all arguments.",
              "Click this item to see what axioms are available.",
              "Axioms are propositions that are accepted as true without proof, such as 'Every dog is a dog'.",
              "According to the axioms, the same entity <strong>cannot have two opposing properties at the same time</strong>, like being both <strong>good</strong> and <strong>evil</strong>.",
              "You can use these axioms as important premises when constructing your arguments.",
              "Now that you've checked the basic truths, let's find out what happens when you cannot play any card.",
            ],
            // Stage 4 (Index 3)
            [
              "If the current player has no possible moves, the round ends and <strong>Thinking Time</strong> begins.",
              "During Thinking Time, the <strong>Eureka!</strong> button changes to an <strong>Add Theorem</strong> button.",
              "Press this button to create new <strong>theorems</strong> based on already proven truths. Let's try it now.",
              "The proof workbench has opened. Let's create a new theorem using the <strong>Universal Application</strong> rule.",
              "Select the premises <strong>Socrates is a dog</strong> and <strong>Every dog is wise</strong> from the list.",
              "Now, select <strong>Universal Application</strong> from the dropdown and click <strong>Apply Rule</strong>.",
              "Great! The new theorem <strong>Socrates is wise</strong> has been derived.<br><br>Now, select this theorem and press the <strong>Add Selected Theorems to True List</strong> button to finalize the proof.",
              "The new theorem has been added to the <strong>List of True Propositions</strong>!<br><br>Now press the <strong>End Thinking Time</strong> button to start the next round.<br>When a new round starts, you get all your played cards back, and the List of True Propositions remains.",
            ],
            // Stage 5 (Index 4) - UPDATED & EXPANDED
            [
              "You've learned the game flow. Finally, let's learn the most important <strong>inference rules</strong> for victory, one by one. Press the <strong>Eureka!</strong> button to open the proof workbench.",
              // 1. Modus Ponens
              "First up is <strong>Modus Ponens</strong>. It's the most intuitive rule: if you have (P) and (P → Q), you can derive (Q).",
              "From the premise list, select <strong>Socrates is good</strong> and <strong>Socrates is good then Socrates wins</strong>.",
              "Select <strong>Modus Ponens</strong> from the rule list and click <strong>Apply Rule</strong>.",
              // 2. Modus Tollens
              "Great. The conclusion <strong>Socrates wins</strong> has been derived. Now let's practice <strong>Modus Tollens</strong>.",
              "From the premise list, select <strong>Plato is wise is false</strong> and <strong>Plato wins then Plato is wise</strong>.",
              "Select <strong>Modus Tollens</strong> from the rule list and click <strong>Apply Rule</strong>.",
              // 3. Disjunctive Syllogism
              "Excellent! The conclusion <strong>Plato wins is false</strong> has been derived. Next is <strong>Disjunctive Syllogism</strong>.",
              "From the premise list, select <strong>Some bird is a fish or Some bird is a bird</strong> and <strong>Some bird is a fish is false</strong>. If one part of an <strong>or</strong> statement is false, the other must be true, right?",
              "Select <strong>Disjunctive Syllogism</strong> from the rule list and click <strong>Apply Rule</strong>.",
              // 4. Hypothetical Syllogism
              "<strong>Some bird is a bird</strong> has been derived. Now for <strong>Hypothetical Syllogism</strong>. Let's link two chaining propositions into one.",
              "Select <strong>Plato is a dog then Plato is good</strong> and <strong>Plato is good then Plato wins</strong>.",
              "Select <strong>Hypothetical Syllogism</strong> from the rule list and click <strong>Apply Rule</strong>.",
              // 5. Conjunction Elimination (Simplification)
              "Great! A more concise proposition <strong>Plato is a dog then Plato wins</strong> has been created. Next is the <strong>Simplification</strong> rule.",
              "A statement connected by <strong>and</strong> means both parts are true. From the premise list, select <strong>Socrates is wise and Plato is foolish</strong>.",
              "Select <strong>Simplification</strong> from the rule list and click <strong>Apply Rule</strong>. You'll see two propositions derived at once.",
              // 6. Double Negation Elimination
              "As you can see, the two propositions have been separated. Now let's learn the <strong>Double Negation Elimination</strong> rule. Two negatives make a positive.",
              "Select <strong>Some fish is good is false is false</strong> from the premise list.",
              "Select <strong>Double Negation Elimination</strong> from the rule list and click <strong>Apply Rule</strong>.",
              // 7. Universal Application
              "It's back to the original positive statement. Next up is the <strong>Universal Application</strong> rule. A universal rule applies to specific instances.",
              "Select <strong>Every bird is good</strong> and <strong>Plato is a bird</strong> from the premise list.",
              "Select <strong>Universal Application</strong> from the rule list and click <strong>Apply Rule</strong>.",
              // 8. Existential Instantiation
              "Exactly. Lastly, the <strong>Existential Instantiation</strong> rule. If <strong>Every</strong> is true, then <strong>Some</strong> must also be true.",
              "Select <strong>Every dog is good</strong> from the premise list.",
              "Select <strong>Existential Instantiation</strong> from the rule list and click <strong>Apply Rule</strong>.",
              // End of Stage 5
              "Excellent! You have now mastered all the basic inference rules of LOGOS. Next, let's learn a powerful rule for combining multiple propositions.",
            ],
            // Stage 6 (Index 5)
            [
              "The <strong>Proof by Cases</strong> rule we'll learn now is a powerful tool for merging multiple paths into a single conclusion.",
              "We have two cases: <strong>Plato is good or Plato is evil</strong>. However, in either case, we reach the same conclusion <strong>Plato is wise</strong>. First, please select all three required premises.",
              "Great. Now, select <strong>Proof by Cases</strong> from the rule list and click <strong>Apply Rule</strong> to derive the conclusion.",
              "Perfect! The conclusion <strong>Plato is wise</strong> has been derived. You've become familiar with the basic rules. Next up are rules that use <strong>assumptions</strong>, the heart of logic.",
            ],
            // Stage 7 (Index 6) - ★★★ MODIFIED SECTION ★★★
            [
              "Sometimes, to prove something, you need to assume <strong>what if...</strong>. This time, let's logically connect two premises.",
              "Click the <strong>Assume</strong> button and assume <strong>Socrates is wise</strong> by typing it in.",
              "Great. Now, select the assumption and the first premise: 'Socrates is wise then Plato is a dog'.",
              "Apply the <strong>Modus Ponens</strong> rule to derive an intermediate conclusion.",
              "Excellent! Now, select the intermediate conclusion you just got and the second premise: <strong>Plato is a dog then Plato is good</strong>.",
              "Apply the <strong>Modus Ponens</strong> rule again to derive the final conclusion.",
              "Perfect! Now for the magic of <strong>Conditional Introduction</strong>. Select the final result, <strong>Plato is good</strong>.",
              "Finally, apply the <strong>Conditional Introduction</strong> rule. This creates the new theorem <strong>Socrates is wise then Plato is good</strong>, a solid truth we never had before, independent of the assumption!",
              "Excellent! Now let's learn about Reductio ad Absurdum.",
            ],
            // Stage 8 (Index 7) - NEWLY ADDED
            [
              "<strong>Reductio ad Absurdum</strong> is a method of proving something by assuming its <strong>opposite</strong> to find a contradiction.",
              "Our goal is to prove <strong>Socrates is evil</strong>. Let's assume the opposite by clicking <strong>Assume</strong> and entering <strong>Socrates is evil is false</strong>.",
              "The assumption has been added. Now, let's use it to create an obvious contradiction, a pair of 'P' and '~P'. Select the assumption you just made and the other premise, then apply the 'Modus Ponens' rule.",
              "Look! <strong>Plato is wise</strong> has been derived. But we already have <strong>Plato is wise is false</strong> in our list of true propositions. This is a contradiction!",
              "Now, select the two contradictory propositions and apply the <strong>Reductio ad Absurdum</strong> rule.",
              "This proves our initial assumption was wrong! Now, apply the <strong>Double Negation Elimination</strong> rule to the result to get our final conclusion.",
              "Perfect! You have now learned everything about LOGOS. Go ahead and prove your wisdom in a real battle of wits!",
            ],
          ],
          inferenceRules: {
            basic: "Basic Rules",
            modusPonens: "Modus Ponens (P, P→Q ∴ Q)",
            modusTollens: "Modus Tollens (~Q, P→Q ∴ ~P)",
            hypotheticalSyllogism: "Hypothetical Syllogism (P→Q, Q→R ∴ P→R)",
            disjunctiveSyllogism: "Disjunctive Syllogism (P∨Q, ~P ∴ Q)",
            universalApplication:
              "Universal Application (A is P, Every P are Q ∴ A is Q)",
            existentialInstantiation:
              "Existential Instantiation (Every P is Q ∴ Some P is Q)",
            conjunctionElimination: "Simplification (P∧Q ∴ P, Q)",
            doubleNegationElimination:
              "Double Negation Elimination (~(~P) ∴ P)",
            assumptionBased: "Assumption-Based Rules",
            conditionalIntroduction:
              "Conditional Introduction (Assume P, derive Q ∴ P→Q)",
            reductioAdAbsurdum:
              "Reductio ad Absurdum (Assume P, derive contradiction ∴ ~P)",
            advanced: "Advanced Rules",
            proofByCases: "Proof by Cases (P∨Q, P→R, Q→R ∴ R)",
          },
          alerts: {
            invalidCard: "This card cannot be played here.",
            incompleteProposition:
              "The proposition is incomplete or could not be parsed.",
            duplicateProposition: "The same proposition already exists.",
            contradictionFound:
              "Contradiction found! This proposition is not compatible with the set of true propositions.",
            undoLastCard: "Reverted the last played card.",
            undoLastProposition: "Reverted the last completed proposition.",
            nothingToUndo: "There are no completed propositions to undo.",
            roundEndNoMoves:
              "Player '{player}' has no valid moves. The round ends.",
            criticalErrorUndo:
              "A critical error occurred while rebuilding the truth set. You may need to restart the game.",
            oneAssumptionOnly: "You can only have one assumption at a time.",
            parsingFailed:
              "Could not parse the proposition. Please check the format.",
            premiseNeededForIntro:
              "For Conditional Introduction, you must select exactly one conclusion derived from the assumption.",
            assumptionNeededForIntro:
              "You must make an assumption first to use Conditional Introduction.",
            premiseNotFromAssumption:
              "The selected proposition does not depend on the current assumption.",
            premiseCountError: "This rule requires {count} premises.",
            contradictionNeededForRAA:
              "Reductio ad Absurdum requires 2 contradictory premises.",
            assumptionNeededForRAA:
              "You must make an assumption first to use Reductio ad Absurdum.",
            notAContradiction: "The selected premises are not a contradiction.",
            ruleFailed: "Failed to apply the rule. Please check your premises.",
            noTheoremsToAdd: "There are no new, non-dependent theorems to add.",
            proofIncomplete:
              "Proof incomplete.\nYou must derive your victory [{myGoal}] or your opponent's defeat [{opponentGoal}].",
            oneCardPerTurn: "You can only play one card per turn.",
            aiEurekaDeclared: "AI has declared 'Eureka!'",
          },
          keywords: {
            if: "then",
            and: "and",
            or: "or",
            not: "is false",
            wins: "wins",
            socrates: "Socrates",
            plato: "Plato",
            universal_q: "Every",
            existential_q: "Some",
          },
          cards: [
            { type: "Quantifier", text: "Some" },
            { type: "Quantifier", text: "Every" },
            { type: "Operator", text: "then" },
            { type: "Operator", text: "and" },
            { type: "Operator", text: "or" },
            { type: "Operator", text: "is false" },
            { type: "Entity", text: "bird" },
            { type: "Entity", text: "fish" },
            { type: "Entity", text: "dog" },
            { type: "Proper Noun", text: "Socrates" },
            { type: "Proper Noun", text: "Plato" },
            { type: "Predicate", text: "is good" },
            { type: "Predicate", text: "is evil" },
            { type: "Predicate", text: "is wise" },
            { type: "Predicate", text: "is foolish" },
            { type: "Predicate", text: "is a bird" },
            { type: "Predicate", text: "is a fish" },
            { type: "Predicate", text: "is a dog" },
            { type: "Predicate", text: "wins" },
          ],
          cardTypes: [
            "Proper Noun",
            "Quantifier",
            "Entity",
            "Predicate",
            "Operator",
          ],
          axiom_templates: {
            identity: [
              "Some bird is a bird",
              "Some fish is a fish",
              "Some dog is a dog",
              "Every bird is a bird",
              "Every fish is a fish",
              "Every dog is a dog",
            ],
            opposition_subjects: [
              "{S} is good or {S} is evil",
              "{S} is good then {S} is evil is false",
              "{S} is wise or {S} is foolish",
              "{S} is wise then {S} is foolish is false",
            ],
            opposition_quantifiers: [
              "Every bird is good then Some bird is evil is false",
              "Every bird is evil then Some bird is good is false",
              "Every fish is good then Some fish is evil is false",
              "Every fish is evil then Some fish is good is false",
              "Every dog is good then Some dog is evil is false",
              "Every dog is evil then Some dog is good is false",
              "Every bird is wise then Some bird is foolish is false",
              "Every bird is foolish then Some bird is wise is false",
              "Every fish is wise then Some fish is foolish is false",
              "Every fish is foolish then Some fish is wise is false",
              "Every dog is wise then Some dog is foolish is false",
              "Every dog is foolish then Some dog is wise is false",
              "Some bird is good is false then Every bird is evil",
              "Some bird is evil is false then Every bird is good",
              "Some fish is good is false then Every fish is evil",
              "Some fish is evil is false then Every fish is good",
              "Some dog is good is false then Every dog is evil",
              "Some dog is evil is false then Every dog is good",
              "Some bird is wise is false then Every bird is foolish",
              "Some bird is foolish is false then Every bird is wise",
              "Some fish is wise is false then Every fish is foolish",
              "Some fish is foolish is false then Every fish is wise",
              "Some dog is wise is false then Every dog is foolish",
              "Some dog is foolish is false then Every dog is wise",
            ],
          },
          victoryPredicates: ["is good", "is evil", "is wise", "is foolish"],
          contradictoryPredicates: {
            "is good": "is evil",
            "is wise": "is foolish",
          },
          labels: {
            proposition: "[Prop]",
            axiom: "[Axiom]",
            victory_condition: "[WinCon]",
            theorem: "[Thm]",
            assumption: "[Asmp]",
            ci_theorem: "[CI Thm]",
            raa_theorem: "[RAA Thm]",
            theorem_source: "[Thm] {text} (R{round} Thinking)",
            victory_text: "{owner} Win Condition: {text}",
          },
        },
      };

      // Add this right after the const TEXTS = { ... }; line

      const PHILOSOPHERS = {
        socrates: {
          id: "socrates",
          name: { ko: "소크라테스", en: "Socrates" },
          cardText: { ko: "소크라테스는", en: "Socrates" },
          image: "assets/so_portrait.png", // 👈 철학자 큰 이미지 경로
          icon: "assets/so_icon.png", // 👈 선택 격자에 들어갈 아이콘 이미지 경로
          skill: {
            ko: '너 자신을 알라: 첫 라운드를 패배로 시작합니다. 대신, 게임 시작 시 추가 "정리"를 2개 가집니다.',
            en: 'Know Thyself: Starts the first round with a loss. Instead, gains 2 extra "Theorems" at the start of the game.',
          },
        },
        plato: {
          id: "plato",
          name: { ko: "플라톤", en: "Plato" },
          image: "assets/pl_portrait.png",
          cardText: { ko: "플라톤은", en: "Plato" },
          icon: "assets/pl_icon.png",
          skill: {
            ko: '이데아: "유레카" 선언 시, 증명에 필요한 전제를 하나 덜 사용해도 됩니다 (최소 1개는 필요).',
            en: 'Theory of Forms: May use one less premise when declaring "Eureka!" (minimum of 1 is still required).',
          },
        },
        aristotle: {
          id: "aristotle",
          name: { ko: "아리스토텔레스", en: "Aristotle" },
          cardText: { ko: "아리스토텔레스는", en: "Aristotle" },
          image: "assets/ar_portrait.png",
          icon: "assets/ar_icon.png",
          skill: {
            ko: '삼단논법: "사유 시간"에 "보편 적용" 규칙의 비용이 절반으로 감소합니다.',
            en: 'Syllogism: The cost of the "Universal Application" rule is halved during "Thinking Time".',
          },
        },
        nietzsche: {
          id: "nietzsche",
          name: { ko: "니체", en: "Nietzsche" },
          cardText: { ko: "니체는", en: "Nietzsche" },
          image: "assets/ni_portrait.png",
          icon: "assets/ni_icon.png",
          skill: {
            ko: '초인: 상대방의 승리 조건을 만족시키는 명제를 "거짓"으로 만들었을 때, 추가 턴을 얻습니다.',
            en: "Übermensch: Gains an extra turn when successfully negating a proposition that satisfies the opponent's win condition.",
          },
        },
      };

      // --- GLOBAL STATE ---
      // --- GLOBAL STATE ---
      let currentLang;
      let fullDeck, cardTypeOrder;
      let playerA_Hand = [],
        playerB_Hand = [];
      let truePropositions = [];
      let parsedAxioms = [];
      let currentProposition = [];
      let currentPlayer = "A";
      let propositionStarter = "A";
      let gameIsOver = false;
      let currentRound = 1;
      let isThinkingTime = false;
      let lastPropositionMaker = null;
      let internalTruthSet = [];
      let derivedPropositionsInModal = [];
      let currentAssumption = null;
      let lastCardPlayer = null;
      let cardsPlayedThisTurn = { A: 0, B: 0 };

      let playerA_Data = null;
      let playerB_Data = null;

      let currentAxioms = []; // 현재 게임의 공리를 저장할 배열

      // --- AI Mode State ---
      let gameMode = null;
      let playerCharacter = null;
      let aiPlayer = null;

      // --- TUTORIAL STATE ---
      let inTutorialMode = false;
      let tutorialStep = 0;
      let tutorialSubStep = 0;
      let temporaryListener = null;

      // --- Character Selection State (NEW) ---
      let selectionMode = null; // '2P' or 'AI'
      let characterSelectionTurn = null; // 'P1', 'P2'
      let tempSelections = { p1: null, p2: null };
      let humanPlayerId = null; // In AI mode, is the human 'P1' or 'P2'?
      // --- LOGIC ENGINE: PARSING & COMPARISON (MOVED UP) ---

      let aiTimeoutId = null;

      function parseTokensToProposition(tokens) {
        if (!tokens || tokens.length === 0) return null;
        if (tokens[0] === "(" && tokens[tokens.length - 1] === ")") {
          let balance = 0;
          let isOuterParens = true;
          for (let i = 0; i < tokens.length - 1; i++) {
            if (tokens[i] === "(") balance++;
            else if (tokens[i] === ")") balance--;
            if (balance === 0) {
              isOuterParens = false;
              break;
            }
          }
          if (isOuterParens) {
            return parseTokensToProposition(tokens.slice(1, -1));
          }
        }
        let balance = 0;
        for (let i = tokens.length - 1; i >= 0; i--) {
          if (tokens[i] === ")") balance++;
          else if (tokens[i] === "(") balance--;
          if (balance === 0 && tokens[i] === currentLang.keywords.if) {
            const left = parseTokensToProposition(tokens.slice(0, i));
            const right = parseTokensToProposition(tokens.slice(i + 1));
            if (!left || !right) return null;
            return { type: "conditional", left: left, right: right };
          }
        }
        balance = 0;
        for (let i = tokens.length - 1; i >= 0; i--) {
          if (tokens[i] === ")") balance++;
          else if (tokens[i] === "(") balance--;
          if (balance === 0 && tokens[i] === currentLang.keywords.or) {
            const left = parseTokensToProposition(tokens.slice(0, i));
            const right = parseTokensToProposition(tokens.slice(i + 1));
            if (!left || !right) return null;
            return { type: "disjunction", left: left, right: right };
          }
        }
        balance = 0;
        for (let i = tokens.length - 1; i >= 0; i--) {
          if (tokens[i] === ")") balance++;
          else if (tokens[i] === "(") balance--;
          if (balance === 0 && tokens[i] === currentLang.keywords.and) {
            const left = parseTokensToProposition(tokens.slice(0, i));
            const right = parseTokensToProposition(tokens.slice(i + 1));
            if (!left || !right) return null;
            return { type: "conjunction", left: left, right: right };
          }
        }
        if (
          tokens.length > 1 &&
          tokens[tokens.length - 1] === currentLang.keywords.not
        ) {
          const prop = parseTokensToProposition(tokens.slice(0, -1));
          if (!prop) return null;
          return { type: "negation", proposition: prop };
        }
        const cardInfo = tokens.map((t) => fullDeck.find((c) => c.text === t));
        if (cardInfo.some((c) => !c)) {
          const [properNoun, quantifier, entity, predicate] =
            currentLang.cardTypes;
          const types = tokens.map((t) => {
            const card = fullDeck.find((c) => c.text === t);
            return card ? card.type : null;
          });
          if (types.length === 2 && types[0] === properNoun) {
            return { type: "atomic", subject: tokens[0], predicate: tokens[1] };
          }
          if (types.length === 3 && types[0] === quantifier) {
            return {
              type:
                tokens[0] === currentLang.keywords.universal_q
                  ? "universal"
                  : "existential",
              entity: tokens[1],
              predicate: tokens[2],
            };
          }
          return null;
        }
        const types = cardInfo.map((c) => c.type);
        const [properNoun, quantifier, entity, predicate] =
          currentLang.cardTypes;
        if (types.length === 2 && types[0] === properNoun) {
          return { type: "atomic", subject: tokens[0], predicate: tokens[1] };
        }
        if (types.length === 3 && types[0] === quantifier) {
          return {
            type:
              tokens[0] === currentLang.keywords.universal_q
                ? "universal"
                : "existential",
            entity: tokens[1],
            predicate: tokens[2],
          };
        }
        return null;
      }

      function parsePropositionFromString(str) {
        const allKeywords = [...fullDeck.map((c) => c.text), "(", ")"].sort(
          (a, b) => b.length - a.length
        );
        let tempStr = str.trim();
        const tokens = [];
        while (tempStr.length > 0) {
          const foundToken = allKeywords.find((k) => tempStr.startsWith(k));
          if (foundToken) {
            tokens.push(foundToken);
            tempStr = tempStr.substring(foundToken.length).trim();
          } else {
            console.error(
              "Tokenizer failed for string:",
              str,
              "at substring:",
              tempStr
            );
            return null;
          }
        }
        return parseTokensToProposition(tokens);
      }

      function parsePropositionFromCards(propInfoArray) {
        if (!propInfoArray || propInfoArray.length === 0) return null;
        const tokens = propInfoArray.map((info) => info.card.text);
        return parseTokensToProposition(tokens);
      }

      function arePropositionsEqual(prop1, prop2) {
        if (!prop1 || !prop2 || prop1.type !== prop2.type) return false;
        switch (prop1.type) {
          case "atomic":
            return (
              prop1.subject === prop2.subject &&
              prop1.predicate === prop2.predicate
            );
          case "universal":
          case "existential":
            return (
              prop1.entity === prop2.entity &&
              prop1.predicate === prop2.predicate
            );
          case "negation":
            return arePropositionsEqual(prop1.proposition, prop2.proposition);
          case "conjunction":
          case "disjunction":
          case "conditional":
            return (
              arePropositionsEqual(prop1.left, prop2.left) &&
              arePropositionsEqual(prop1.right, prop2.right)
            );
          default:
            return false;
        }
      }

      function propositionToText(prop) {
        if (!prop) return "";
        switch (prop.type) {
          case "atomic":
            return `${prop.subject} ${prop.predicate}`;
          case "universal":
            return `${currentLang.keywords.universal_q} ${prop.entity} ${prop.predicate}`;
          case "existential":
            return `${currentLang.keywords.existential_q} ${prop.entity} ${prop.predicate}`;
          case "negation":
            return `~(${propositionToText(prop.proposition)})`;
          case "conjunction":
            return `(${propositionToText(prop.left)}) ∧ (${propositionToText(
              prop.right
            )})`;
          case "disjunction":
            return `(${propositionToText(prop.left)}) ∨ (${propositionToText(
              prop.right
            )})`;
          case "conditional":
            return `(${propositionToText(prop.left)}) → (${propositionToText(
              prop.right
            )})`;
          default:
            return "Unknown Proposition";
        }
      }

      function propositionToNaturalText(prop) {
        if (!prop) return "";
        switch (prop.type) {
          case "atomic":
            return `${prop.subject} ${prop.predicate}`;
          case "universal":
            return `${currentLang.keywords.universal_q} ${prop.entity} ${prop.predicate}`;
          case "existential":
            return `${currentLang.keywords.existential_q} ${prop.entity} ${prop.predicate}`;
          case "negation":
            const innerProp = prop.proposition;
            const innerText = propositionToNaturalText(innerProp);
            if (
              innerProp.type === "conjunction" ||
              innerProp.type === "disjunction" ||
              innerProp.type === "conditional"
            ) {
              return `(${innerText}) ${currentLang.keywords.not}`;
            }
            return `${innerText} ${currentLang.keywords.not}`;
          case "conjunction":
            return `(${propositionToNaturalText(prop.left)}) ${
              currentLang.keywords.and
            } (${propositionToNaturalText(prop.right)})`;
          case "disjunction":
            return `(${propositionToNaturalText(prop.left)}) ${
              currentLang.keywords.or
            } (${propositionToNaturalText(prop.right)})`;
          case "conditional":
            return `(${propositionToNaturalText(prop.left)}) ${
              currentLang.keywords.if
            } (${propositionToNaturalText(prop.right)})`;
          default:
            return "Unknown Proposition";
        }
      }

      // 기존 initializeGame 함수를 아래 코드로 교체하세요.
      function initializeGame(lang) {
        currentLang = TEXTS[lang];
        document.documentElement.lang = currentLang.langCode;
        document.title = currentLang.ui.title;

        fullDeck = currentLang.cards;
        cardTypeOrder = currentLang.cardTypes; // 'axioms' 관련 라인 제거

        document.getElementById("language-modal").classList.remove("visible");
        setupUI();
        showMainMenu();
      }

      function showMainMenu() {
        document.getElementById("container").classList.add("ready");
        document.querySelector(".main-center-bg").classList.remove("hidden");
        updateMainMenuBtnVisibility();
        updateMainCenterVisibility();
      }

      function setupUI() {
        document.getElementById("main-menu-btn").textContent =
          currentLang.langCode === "ko" ? "메인으로" : "Main Menu";

        document.getElementById("main-title").textContent =
          currentLang.ui.title;
        document.getElementById("new-game-btn").textContent =
          currentLang.ui.newGameButton;
        document.getElementById("vs-ai-btn").textContent =
          currentLang.ui.vsAIButton;
        document.getElementById("vs-player-btn").textContent =
          currentLang.ui.vsPlayerButton;
        document.getElementById("tutorial-btn").textContent =
          currentLang.ui.tutorialButton;
        document.getElementById(
          "player-a-title"
        ).innerHTML = `${currentLang.ui.playerAName} - ${currentLang.ui.playerAColor}`;
        document.getElementById(
          "player-b-title"
        ).innerHTML = `${currentLang.ui.playerBName} - ${currentLang.ui.playerBColor}`;
        document.getElementById("eureka-a").textContent =
          currentLang.ui.eurekaButton;
        document.getElementById("eureka-b").textContent =
          currentLang.ui.eurekaButton;
        document.getElementById("current-proposition-title").textContent =
          currentLang.ui.currentPropositionTitle;
        document.getElementById("complete-btn").textContent =
          currentLang.ui.completeButton;
        document.getElementById("undo-btn").textContent =
          currentLang.ui.undoButton;
        document.getElementById("end-turn-btn").textContent =
          currentLang.ui.endTurnButton;
        document.getElementById("true-propositions-title").textContent =
          currentLang.ui.truePropositionsTitle;
        document.getElementById("thinking-time-title").textContent =
          currentLang.ui.thinkingTimeTitle;
        document.getElementById("thinking-time-desc").innerHTML =
          currentLang.ui.thinkingTimeDesc;
        document.getElementById("end-thinking-time-btn").textContent =
          currentLang.ui.endThinkingTimeButton;
        document.getElementById("fullscreen-btn").textContent =
          currentLang.ui.fullscreenButton;
        document.getElementById("tutorial-btn").textContent =
          currentLang.ui.tutorialButton;

        document.getElementById("character-select-title").textContent =
          currentLang.modals.characterSelectTitle;
        document.getElementById("select-socrates").textContent =
          currentLang.modals.selectSocrates;
        document.getElementById("select-plato").textContent =
          currentLang.modals.selectPlato;
        document.getElementById("close-eureka-modal-btn").textContent = "X";
        document.getElementById("close-tutorial-modal-btn").textContent = "X";
        document.getElementById("tutorial-modal-title").textContent =
          currentLang.modals.tutorialTitle;
        document.getElementById("alert-ok-btn").textContent =
          currentLang.ui.okButton;
        document.getElementById("prompt-cancel-btn").textContent =
          currentLang.ui.cancelButton;
        document.getElementById("prompt-confirm-btn").textContent =
          currentLang.ui.okButton;
        document.getElementById("prompt-input").placeholder =
          currentLang.modals.promptInputPlaceholder;

        document.getElementById("premise-selection-title").textContent =
          currentLang.modals.premiseSelectionTitle;
        document.getElementById("apply-rule-btn").textContent =
          currentLang.modals.applyRuleButton;
        document.getElementById("add-assumption-btn").textContent =
          currentLang.modals.addAssumptionButton;
        document.getElementById("cancel-assumption-btn").textContent =
          currentLang.ui.cancelAssumptionButton;

        const select = document.getElementById("inference-rule-select");
        select.innerHTML = `
            <optgroup label="${currentLang.inferenceRules.basic}">
                <option value="modusPonens">${currentLang.inferenceRules.modusPonens}</option>
                <option value="modusTollens">${currentLang.inferenceRules.modusTollens}</option>
                <option value="hypotheticalSyllogism">${currentLang.inferenceRules.hypotheticalSyllogism}</option>
                <option value="disjunctiveSyllogism">${currentLang.inferenceRules.disjunctiveSyllogism}</option>
                <option value="universalApplication">${currentLang.inferenceRules.universalApplication}</option>
                <option value="existentialInstantiation">${currentLang.inferenceRules.existentialInstantiation}</option>
                <option value="conjunctionElimination">${currentLang.inferenceRules.conjunctionElimination}</option>
                <option value="doubleNegationElimination">${currentLang.inferenceRules.doubleNegationElimination}</option>
            </optgroup>
            <optgroup label="${currentLang.inferenceRules.assumptionBased}">
                <option value="conditionalIntroduction" style="color:#27ae60; font-weight:normal;">${currentLang.inferenceRules.conditionalIntroduction}</option>
                <option value="reductioAdAbsurdum" style="color:#c0392b; font-weight:normal;">${currentLang.inferenceRules.reductioAdAbsurdum}</option>
            </optgroup>
            <optgroup label="${currentLang.inferenceRules.advanced}">
                <option value="proofByCases" style="color:#2980b9; font-weight:normal;">${currentLang.inferenceRules.proofByCases}</option>
            </optgroup>
        `;
      }

      function generateAxioms(subjectA, subjectB, langData) {
        const templates = langData.axiom_templates;
        const generated = [];

        generated.push(...templates.identity);

        templates.opposition_subjects.forEach((template) => {
          generated.push(template.replaceAll("{S}", subjectA));
        });

        templates.opposition_subjects.forEach((template) => {
          generated.push(template.replaceAll("{S}", subjectB));
        });

        generated.push(...templates.opposition_quantifiers);

        return generated;
      }

      function setupGame(selectedCharacters) {
        playerA_Data = PHILOSOPHERS[selectedCharacters.p1];
        playerB_Data = PHILOSOPHERS[selectedCharacters.p2];

        const p1_id = selectedCharacters.p1;
        const p2_id = selectedCharacters.p2;

        let p1_card_obj, p2_card_obj;
        let subjectA, subjectB;

        subjectA = playerA_Data.cardText[currentLang.langCode];
        subjectB = playerB_Data.cardText[currentLang.langCode];

        if (p1_id === p2_id) {
          if (currentLang.langCode === "ko") {
            subjectA = `${playerA_Data.name.ko}(백)는`;
            subjectB = `${playerB_Data.name.ko}(흑)은`;
          } else {
            subjectA = `${playerA_Data.name.en} (White)`;
            subjectB = `${playerB_Data.name.en} (Black)`;
          }
          document.getElementById("player-a-title").innerHTML = `⚪️ ${
            playerA_Data.name[currentLang.langCode]
          }(백)`;
          document.getElementById("player-b-title").innerHTML = `⚫️ ${
            playerB_Data.name[currentLang.langCode]
          }(흑)`;
        } else {
          document.getElementById("player-a-title").innerHTML = `⚪️ ${
            playerA_Data.name[currentLang.langCode]
          }`;
          document.getElementById("player-b-title").innerHTML = `⚫️ ${
            playerB_Data.name[currentLang.langCode]
          }`;
        }

        const properNounType =
          currentLang.langCode === "ko" ? "고유명사" : "Proper Noun";
        p1_card_obj = { type: properNounType, text: subjectA };
        p2_card_obj = { type: properNounType, text: subjectB };

        const masterDeck = currentLang.cards;
        const allPhilosopherCardTexts = Object.values(PHILOSOPHERS).map(
          (p) => p.cardText[currentLang.langCode]
        );
        const baseDeck = masterDeck.filter(
          (card) => !allPhilosopherCardTexts.includes(card.text)
        );

        const currentGameDeck = [...baseDeck, p1_card_obj, p2_card_obj];
        fullDeck = currentGameDeck;

        const nonPlayerCards = ["승리한다", "wins"];
        playerA_Hand = JSON.parse(
          JSON.stringify(
            fullDeck.filter((c) => !nonPlayerCards.includes(c.text))
          )
        );
        playerB_Hand = JSON.parse(
          JSON.stringify(
            fullDeck.filter((c) => !nonPlayerCards.includes(c.text))
          )
        );

        currentAxioms = generateAxioms(subjectA, subjectB, currentLang);

        parsedAxioms = currentAxioms
          .map((str) => ({
            type: "axiom",
            proposition: parsePropositionFromString(str),
          }))
          .filter((a) => a.proposition);

        internalTruthSet = parsedAxioms.map((a) => a.proposition);

        const { if: ifKeyword, wins, and } = currentLang.keywords;

        const predicateA =
          currentLang.victoryPredicates[
            Math.floor(Math.random() * currentLang.victoryPredicates.length)
          ];
        const victoryTextA = `((${subjectA} ${predicateA}) ${ifKeyword} (${subjectA} ${wins})) ${and} ((${subjectA} ${wins}) ${ifKeyword} ((${subjectA} ${predicateA})))`;
        const parsedVictoryA = parsePropositionFromString(victoryTextA);
        const ultimateTargetA = {
          type: "atomic",
          subject: subjectA,
          predicate: wins,
        };
        const coreGoalA = {
          type: "atomic",
          subject: subjectA,
          predicate: predicateA,
        };

        truePropositions.push({
          type: "victory",
          text: victoryTextA,
          owner: "A",
          proposition: parsedVictoryA,
          ultimate_target: ultimateTargetA,
          core_goal: coreGoalA,
        });
        if (parsedVictoryA) internalTruthSet.push(parsedVictoryA);

        const predicateB =
          currentLang.victoryPredicates[
            Math.floor(Math.random() * currentLang.victoryPredicates.length)
          ];
        const victoryTextB = `((${subjectB} ${predicateB}) ${ifKeyword} (${subjectB} ${wins})) ${and} ((${subjectB} ${wins}) ${ifKeyword} ((${subjectB} ${predicateB})))`;
        const parsedVictoryB = parsePropositionFromString(victoryTextB);
        const ultimateTargetB = {
          type: "atomic",
          subject: subjectB,
          predicate: wins,
        };
        const coreGoalB = {
          type: "atomic",
          subject: subjectB,
          predicate: predicateB,
        };

        truePropositions.push({
          type: "victory",
          text: victoryTextB,
          owner: "B",
          proposition: parsedVictoryB,
          ultimate_target: ultimateTargetB,
          core_goal: coreGoalB,
        });
        if (parsedVictoryB) internalTruthSet.push(parsedVictoryB);

        render();
        checkNextTurn();
      }

      function resetGame(selectedCharacters) {
        // ▼▼▼▼▼ 여기에 안정성 코드 추가 ▼▼▼▼▼
        // 만약 선택된 캐릭터 정보가 없다면, 기본값으로 소크라테스와 플라톤을 설정합니다.
        if (!selectedCharacters) {
          selectedCharacters = { p1: "socrates", p2: "plato" };
        }
        // ▲▲▲▲▲ 여기까지 추가 ▲▲▲▲▲

        clearAllAITimeouts();
        playerA_Hand = [];
        playerB_Hand = [];
        truePropositions = [];
        currentProposition = [];
        currentPlayer = "A";
        gameIsOver = false;
        currentRound = 1;
        isThinkingTime = false;

        document.getElementById("thinking-time-controls").style.display =
          "none";
        document.getElementById("status").innerHTML = "";

        setupGame(selectedCharacters);
      }
      // --- EVENT LISTENERS ---
      // MODIFIED Event Listeners
      document
        .getElementById("lang-en")
        .addEventListener("click", () => initializeGame("en"));
      document
        .getElementById("lang-ko")
        .addEventListener("click", () => initializeGame("ko"));

      document.getElementById("new-game-btn").addEventListener("click", () => {
        if (inTutorialMode) return;

        // 현재 게임 모드가 설정되어 있는지 확인합니다.
        if (gameMode) {
          clearAllAITimeouts(); // 진행 중인 AI 동작이 있다면 중지
          // 현재 게임 모드로 캐릭터 선택을 다시 시작합니다.
          startCharacterSelection(gameMode);
        } else {
          // 혹시 모드가 설정되지 않은 예외적인 경우, 메인 메뉴로 이동합니다.
          showMainMenu();
        }
      });

      document.getElementById("vs-player-btn").addEventListener("click", () => {
        if (inTutorialMode) return;
        startCharacterSelection("2P");
      });
      document.getElementById("vs-ai-btn").addEventListener("click", () => {
        if (inTutorialMode) return;
        startCharacterSelection("AI");
      });

      // NEW Event Listener for the single confirm button
      document
        .getElementById("confirm-selection-btn")
        .addEventListener("click", handleConfirmClick);

      // Keep other event listeners like those for complete-btn, undo-btn, etc. as they are.

      document.getElementById("complete-btn").addEventListener("click", () => {
        if (!inTutorialMode) completeProposition();
      });
      document.getElementById("undo-btn").addEventListener("click", () => {
        if (!inTutorialMode) undoProposition();
      });
      document.getElementById("end-turn-btn").addEventListener("click", () => {
        if (!inTutorialMode) endTurn();
      });
      document.getElementById("eureka-a").addEventListener("click", () => {
        if (!inTutorialMode) declareEureka("A");
      });
      document.getElementById("eureka-b").addEventListener("click", () => {
        if (!inTutorialMode) declareEureka("B");
      });
      document
        .getElementById("close-eureka-modal-btn")
        .addEventListener("click", () => {
          if (!inTutorialMode)
            document.getElementById("eureka-modal").classList.remove("visible");
        });
      document
        .getElementById("close-tutorial-modal-btn")
        .addEventListener("click", () =>
          document.getElementById("tutorial-modal").classList.remove("visible")
        );
      document
        .getElementById("tutorial-btn")
        .addEventListener("click", startTutorial);
      document
        .getElementById("apply-rule-btn")
        .addEventListener("click", () => {
          if (!inTutorialMode) applyRule();
        });
      document
        .getElementById("add-assumption-btn")
        .addEventListener("click", addAssumption);
      document
        .getElementById("cancel-assumption-btn")
        .addEventListener("click", cancelAssumption);
      document
        .getElementById("end-thinking-time-btn")
        .addEventListener("click", () => {
          if (!inTutorialMode) endThinkingTime();
        });
      document
        .getElementById("alert-ok-btn")
        .addEventListener("click", () =>
          document.getElementById("alert-modal").classList.remove("visible")
        );
      document
        .getElementById("tutorial-next-btn")
        .addEventListener("click", advanceTutorial);

      // --- CHARACTER SELECTION LOGIC (NEW SECTION) ---

      function startCharacterSelection(mode) {
        selectionMode = mode;
        tempSelections = { p1: null, p2: null };

        document.querySelector(".main-center-bg").classList.add("hidden");
        document
          .getElementById("character-selection-screen")
          .classList.remove("hidden");

        updatePlayerDisplay("p1", null);
        updatePlayerDisplay("p2", null);
        document.getElementById("p1-ready-overlay").classList.remove("visible");
        document.getElementById("p2-ready-overlay").classList.remove("visible");

        if (mode === "AI") {
          const turnModal = document.getElementById("turn-order-modal");
          turnModal.classList.add("visible");

          document.getElementById("select-first-player").onclick = () => {
            humanPlayerId = "P1";
            aiPlayer = "B";
            turnModal.classList.remove("visible");
            beginPlayerSelectionTurn("P1");
          };
          document.getElementById("select-second-player").onclick = () => {
            humanPlayerId = "P2";
            aiPlayer = "A";
            turnModal.classList.remove("visible");
            beginPlayerSelectionTurn("P1");
          };
        } else {
          aiPlayer = null;
          humanPlayerId = null;
          beginPlayerSelectionTurn("P1");
        }
      }

      function beginPlayerSelectionTurn(player) {
        characterSelectionTurn = player;
        const statusEl = document.getElementById("status");
        const lang = currentLang.ui;

        let instruction =
          player === "P1" ? lang.selectP1Philosopher : lang.selectP2Philosopher;
        if (selectionMode === "AI") {
          instruction =
            player === humanPlayerId
              ? lang.selectYourPhilosopher
              : lang.selectAIPhilosopher;
        }
        statusEl.innerHTML = `<span class="turn-indicator">${instruction}</span>`;

        const grid = document.getElementById("shared-char-grid");
        grid.innerHTML = "";
        for (const key in PHILOSOPHERS) {
          const philosopher = PHILOSOPHERS[key];
          const iconEl = document.createElement("div");
          iconEl.className = "char-icon";
          iconEl.dataset.id = key;
          iconEl.style.backgroundImage = `url('${philosopher.icon}')`;
          iconEl.onclick = () => handleCharacterClick(key);
          grid.appendChild(iconEl);
        }

        if (selectionMode === "AI" && player !== humanPlayerId) {
          const available = Object.keys(PHILOSOPHERS).filter(
            (id) => id !== tempSelections.p1
          );
          const randomChoice =
            available[Math.floor(Math.random() * available.length)];
          handleCharacterClick(randomChoice);
          setTimeout(handleConfirmClick, 1000);
        }
      }

      function handleCharacterClick(philosopherId) {
        const targetPlayer = characterSelectionTurn === "P1" ? "p1" : "p2";
        tempSelections[targetPlayer] = philosopherId;
        updatePlayerDisplay(targetPlayer, philosopherId);

        document.querySelectorAll(".char-icon").forEach((icon) => {
          icon.classList.toggle("selected", icon.dataset.id === philosopherId);
        });

        document.getElementById("confirm-selection-btn").disabled = false;
      }

      function updatePlayerDisplay(player, philosopherId) {
        const portraitEl = document.getElementById(`${player}-portrait`);
        const nameEl = document.getElementById(`${player}-philosopher-name`);
        const skillDescEl = document.getElementById(`${player}-skill-desc`);

        if (philosopherId) {
          const p = PHILOSOPHERS[philosopherId];
          portraitEl.style.backgroundImage = `url('${p.image}')`;
          nameEl.textContent = p.name[currentLang.langCode];
          skillDescEl.textContent = p.skill[currentLang.langCode];
        } else {
          portraitEl.style.backgroundImage = "none";
          nameEl.textContent = "";
          skillDescEl.textContent = currentLang.ui.waitingForOpponent;
        }
      }

      function handleConfirmClick() {
        document.getElementById("confirm-selection-btn").disabled = true;

        if (characterSelectionTurn === "P1") {
          document.getElementById("p1-ready-overlay").classList.add("visible");
          beginPlayerSelectionTurn("P2");
        } else {
          document.getElementById("p2-ready-overlay").classList.add("visible");
          finalizeSelection();
        }
      }

      function finalizeSelection() {
        document.getElementById(
          "status"
        ).innerHTML = `<span class="turn-indicator">${currentLang.ui.gameStartingSoon}</span>`;

        setTimeout(() => {
          document
            .getElementById("character-selection-screen")
            .classList.add("hidden");
          document
            .getElementById("turn-order-modal")
            .classList.remove("visible");
          updateMainMenuBtnVisibility();
          updateMainCenterVisibility();
          resetGame(tempSelections);
        }, 2000);
      }

      function startTutorial() {
        // ▼▼▼▼▼ 여기에 초기화 코드 추가 ▼▼▼▼▼
        // 튜토리얼 시작 시, 철학자를 소크라테스와 플라톤으로 강제 초기화합니다.
        playerA_Data = PHILOSOPHERS["socrates"];
        playerB_Data = PHILOSOPHERS["plato"];
        // ▲▲▲▲▲ 여기까지 추가 ▲▲▲▲▲

        inTutorialMode = true;
        tutorialStep = 0;
        tutorialSubStep = 0;

        const tutorialBtn = document.getElementById("tutorial-btn");
        tutorialBtn.textContent = currentLang.ui.endTutorialButton;
        tutorialBtn.removeEventListener("click", startTutorial);
        tutorialBtn.addEventListener("click", endTutorial);

        document.querySelector(".main-center-bg").classList.add("hidden");
        updateMainMenuBtnVisibility();
        updateMainCenterVisibility();

        document
          .querySelectorAll(
            ".header-buttons-left button, .header-buttons-right button"
          )
          .forEach((btn) => {
            if (btn.id !== "tutorial-btn" && btn.id !== "main-menu-btn") {
              btn.disabled = true;
            }
          });

        document.getElementById("tutorial-guide").classList.remove("hidden");
        document.getElementById("tutorial-next-btn").textContent =
          currentLang.ui.nextButton;

        setupTutorialScenario(1);
        advanceTutorial();
      }

      function advanceTutorial() {
        // Clear previous temporary listeners to prevent stacking
        if (temporaryListener) {
          temporaryListener.element.removeEventListener(
            temporaryListener.type,
            temporaryListener.handler
          );
          temporaryListener = null;
        }

        const script = currentLang.tutorial[tutorialStep];
        if (!script || tutorialSubStep >= script.length) {
          tutorialStep++;
          tutorialSubStep = 0;
          if (tutorialStep >= currentLang.tutorial.length) {
            endTutorial();
            return;
          }
          setupTutorialScenario(tutorialStep + 1); // Setup for the *next* stage
        }

        const newScript = currentLang.tutorial[tutorialStep];
        if (!newScript || tutorialSubStep >= newScript.length) {
          endTutorial();
          return;
        }

        const guideTextEl = document.getElementById("tutorial-text");
        const tutorialGuideEl = document.getElementById("tutorial-guide");
        const nextBtn = document.getElementById("tutorial-next-btn");
        guideTextEl.innerHTML = newScript[tutorialSubStep];
        nextBtn.classList.remove("hidden");

        // Reset position and highlights
        tutorialGuideEl.classList.remove("top");
        clearHighlights();

        handleTutorialStepLogic();

        tutorialSubStep++;
      }

      function handleTutorialStepLogic() {
        if (tutorialStep === 0) {
          // Stage 1
          switch (tutorialSubStep) {
            case 5:
              highlightElement("#player-a-hand");
              break;
            case 6:
              highlightElement("#proposition-display");
              break;
            case 7:
              const cardToClick = Array.from(
                document.querySelectorAll("#player-a-hand .card")
              ).find((c) => c.textContent === currentLang.keywords.socrates);
              if (cardToClick) {
                highlightElement(cardToClick);
                document
                  .getElementById("tutorial-next-btn")
                  .classList.add("hidden");
                waitForInteraction(cardToClick, "click", () => {
                  const cardData = playerA_Hand.find(
                    (c) => c.text === currentLang.keywords.socrates
                  );
                  playCardTutorial(cardData);
                  advanceTutorial();
                });
              }
              break;
            case 9:
              clearHighlights();
              const entityCards = Array.from(
                document.querySelectorAll("#player-a-hand .card")
              ).filter((c) => {
                const cardData = fullDeck.find(
                  (card) => card.text === c.textContent
                );
                return cardData && cardData.type === currentLang.cardTypes[2]; // 개체 or Entity
              });
              const quantifierCards = Array.from(
                document.querySelectorAll("#player-a-hand .card")
              ).filter((c) => {
                const cardData = fullDeck.find(
                  (card) => card.text === c.textContent
                );
                return cardData && cardData.type === currentLang.cardTypes[1]; // 양화사 or Quantifier
              });
              entityCards.forEach((card) =>
                card.classList.add("tutorial-highlight")
              );
              quantifierCards.forEach((card) =>
                card.classList.add("tutorial-highlight")
              );
              break;
            case 11:
              const endTurnBtn = document.getElementById("end-turn-btn");
              highlightElement(endTurnBtn);
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              waitForInteraction(endTurnBtn, "click", () => {
                endTurnTutorial();
                advanceTutorial();
              });
              break;
          }
        } else if (tutorialStep === 1) {
          // Stage 2
          switch (tutorialSubStep) {
            case 2:
              const completeBtn = document.getElementById("complete-btn");
              highlightElement(completeBtn);
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              waitForInteraction(completeBtn, "click", () => {
                completePropositionTutorial();
                advanceTutorial();
              });
              break;
            case 7:
              clearHighlights();
              const connectiveCards = Array.from(
                document.querySelectorAll("#player-a-hand .card")
              ).filter(
                (c) =>
                  c.textContent === currentLang.keywords.and ||
                  c.textContent === currentLang.keywords.or ||
                  c.textContent === currentLang.keywords.if
              );
              connectiveCards.forEach((card) =>
                card.classList.add("tutorial-highlight")
              );
              break;
            case 8:
              const negationCard = Array.from(
                document.querySelectorAll("#player-a-hand .card")
              ).find((c) => c.textContent === currentLang.keywords.not);
              if (negationCard) highlightElement(negationCard);
              break;
          }
        } else if (tutorialStep === 2) {
          // Stage 3
          switch (tutorialSubStep) {
            case 0:
              highlightElement("#true-propositions");
              break;
            case 1:
              const axiomSummary = document.querySelector(
                ".axiom-wrapper summary"
              );
              if (axiomSummary) {
                highlightElement(axiomSummary);
                document
                  .getElementById("tutorial-next-btn")
                  .classList.add("hidden");
                waitForInteraction(axiomSummary, "click", () => {
                  advanceTutorial();
                });
              }
              break;
            case 2:
            case 3:
            case 4:
              document.getElementById("tutorial-guide").classList.add("top");
              break;
          }
        } else if (tutorialStep === 3) {
          // Stage 4
          document.getElementById("tutorial-guide").classList.add("top");
          switch (tutorialSubStep) {
            case 2:
              const addTheoremBtn = document.getElementById("eureka-a");
              highlightElement(addTheoremBtn);
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              waitForInteraction(addTheoremBtn, "click", () => {
                openEurekaModalTutorial();
                advanceTutorial();
              });
              break;
            case 4:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? ["소크라테스는 개이다", "모든 개는 지혜롭다"]
                  : ["Socrates is a dog", "Every dog is wise"]
              );
              break;
            case 5:
              handleTutorialRuleApplication("universalApplication");
              break;
            case 6:
              const confirmBtn = document.getElementById("modal-confirm-btn");
              const newTheoremText =
                currentLang.langCode === "ko"
                  ? "소크라테스는 지혜롭다"
                  : "Socrates is wise";
              const newTheoremProp = parsePropositionFromString(newTheoremText);
              const theoremLi = Array.from(
                document.querySelectorAll("#premise-list li")
              ).find((li) => {
                const data = JSON.parse(li.dataset.propObject);
                return (
                  data.type === "theorem" &&
                  arePropositionsEqual(data.proposition, newTheoremProp)
                );
              });

              if (theoremLi && confirmBtn) {
                highlightElement(theoremLi);
                confirmBtn.classList.add("tutorial-highlight");
                document
                  .getElementById("tutorial-next-btn")
                  .classList.add("hidden");

                const confirmHandler = () => {
                  const checkbox = theoremLi.querySelector("input");
                  if (checkbox && checkbox.checked) {
                    addTheoremsToListTutorial();
                    advanceTutorial();
                  } else {
                    showAlert(
                      currentLang.langCode === "ko"
                        ? "새로 도출된 정리를 먼저 선택해주세요."
                        : "Please select the newly derived theorem first."
                    );
                  }
                };
                waitForInteraction(confirmBtn, "click", confirmHandler);
              }
              break;
            case 7:
              const endThinkingBtn = document.getElementById(
                "end-thinking-time-btn"
              );
              highlightElement(endThinkingBtn);
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              waitForInteraction(endThinkingBtn, "click", () => {
                endThinkingTime();
                advanceTutorial();
              });
              break;
          }
        } else if (tutorialStep === 4) {
          // Stage 5 - Basic Rules
          document.getElementById("tutorial-guide").classList.add("top");
          switch (tutorialSubStep) {
            // Intro
            case 0:
              const eurekaBtn = document.getElementById("eureka-a");
              highlightElement(eurekaBtn);
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              waitForInteraction(eurekaBtn, "click", () => {
                openEurekaModalTutorial();
                advanceTutorial();
              });
              break;
            // Modus Ponens
            case 2:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? [
                      "소크라테스는 선하다",
                      "(소크라테스는 선하다) 라면 (소크라테스는 승리한다)",
                    ]
                  : [
                      "Socrates is good",
                      "(Socrates is good) then (Socrates wins)",
                    ]
              );
              break;
            case 3:
              handleTutorialRuleApplication("modusPonens");
              break;
            // Modus Tollens
            case 5:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? [
                      "플라톤은 지혜롭다 는 거짓이다",
                      "(플라톤은 승리한다) 라면 (플라톤은 지혜롭다)",
                    ]
                  : [
                      "Plato is wise is false",
                      "(Plato wins) then (Plato is wise)",
                    ]
              );
              break;
            case 6:
              handleTutorialRuleApplication("modusTollens");
              break;
            // Disjunctive Syllogism
            case 8:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? [
                      "(어떤 새는 물고기이다) 또는 (어떤 새는 새이다)",
                      "어떤 새는 물고기이다 는 거짓이다",
                    ]
                  : [
                      "(Some bird is a fish) or (Some bird is a bird)",
                      "Some bird is a fish is false",
                    ]
              );
              break;
            case 9:
              handleTutorialRuleApplication("disjunctiveSyllogism");
              break;
            // Hypothetical Syllogism
            case 11:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? [
                      "(플라톤은 개이다) 라면 (플라톤은 선하다)",
                      "(플라톤은 선하다) 라면 (플라톤은 승리한다)",
                    ]
                  : [
                      "(Plato is a dog) then (Plato is good)",
                      "(Plato is good) then (Plato wins)",
                    ]
              );
              break;
            case 12:
              handleTutorialRuleApplication("hypotheticalSyllogism");
              break;
            // Conjunction Elimination
            case 14:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? ["(소크라테스는 지혜롭다) 그리고 (플라톤은 어리석다)"]
                  : ["(Socrates is wise) and (Plato is foolish)"]
              );
              break;
            case 15:
              handleTutorialRuleApplication("conjunctionElimination");
              break;
            // Double Negation
            case 17:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? ["어떤 물고기는 선하다 는 거짓이다 는 거짓이다"]
                  : ["Some fish is good is false is false"]
              );
              break;
            case 18:
              handleTutorialRuleApplication("doubleNegationElimination");
              break;
            // Universal Application
            case 20:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? ["모든 새는 선하다", "플라톤은 새이다"]
                  : ["Every bird is good", "Plato is a bird"]
              );
              break;
            case 21:
              handleTutorialRuleApplication("universalApplication");
              break;
            // Existential Instantiation
            case 23:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? ["모든 개는 선하다"]
                  : ["Every dog is good"]
              );
              break;
            case 24:
              handleTutorialRuleApplication("existentialInstantiation");
              break;
          }
        } else if (tutorialStep === 5) {
          // Stage 6 - Advanced Rules (Proof by Cases)
          document.getElementById("tutorial-guide").classList.add("top");
          switch (tutorialSubStep) {
            case 1:
              const premises =
                currentLang.langCode === "ko"
                  ? [
                      "플라톤은 선하다 또는 플라톤은 악하다",
                      "(플라톤은 선하다) 라면 (플라톤은 지혜롭다)",
                      "(플라톤은 악하다) 라면 (플라톤은 지혜롭다)",
                    ]
                  : [
                      "Plato is good or Plato is evil",
                      "(Plato is good) then (Plato is wise)",
                      "(Plato is evil) then (Plato is wise)",
                    ];
              handleTutorialRuleInteraction(premises);
              break;
            case 2:
              handleTutorialRuleApplication("proofByCases");
              break;
          }
        } else if (tutorialStep === 6) {
          // Stage 7 - Assumption (Conditional Intro) ★★★ MODIFIED SECTION ★★★
          document.getElementById("tutorial-guide").classList.add("top");
          switch (tutorialSubStep) {
            case 1: // Assume
              highlightElement("#add-assumption-btn");
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              const correctAssumptionCI =
                currentLang.langCode === "ko"
                  ? "소크라테스는 지혜롭다"
                  : "Socrates is wise";
              const originalShowPrompt = window.showPrompt;
              window.showPrompt = (message, callback) => {
                originalShowPrompt(message, (value) => {
                  if (value === correctAssumptionCI) {
                    window.showPrompt = originalShowPrompt;
                    callback(value);
                    advanceTutorial();
                  } else {
                    showAlert(
                      currentLang.langCode === "ko"
                        ? "올바른 명제를 입력해 주십시오."
                        : "Please enter a valid proposition."
                    );
                    callback(null);
                  }
                });
              };
              break;
            case 2: // Select premises for 1st MP
              const premisesCI_1 =
                currentLang.langCode === "ko"
                  ? [
                      "소크라테스는 지혜롭다",
                      "(소크라테스는 지혜롭다) 라면 (플라톤은 개이다)",
                    ]
                  : [
                      "Socrates is wise",
                      "(Socrates is wise) then (Plato is a dog)",
                    ];
              handleTutorialRuleInteraction(premisesCI_1);
              break;
            case 3: // Apply 1st MP
              handleTutorialRuleApplication("modusPonens");
              break;
            case 4: // Select premises for 2nd MP
              const premisesCI_2 =
                currentLang.langCode === "ko"
                  ? [
                      "플라톤은 개이다",
                      "(플라톤은 개이다) 라면 (플라톤은 선하다)",
                    ]
                  : ["Plato is a dog", "(Plato is a dog) then (Plato is good)"];
              handleTutorialRuleInteraction(premisesCI_2);
              break;
            case 5: // Apply 2nd MP
              handleTutorialRuleApplication("modusPonens");
              break;
            case 6: // Select final result
              const conclusionTextCI =
                currentLang.langCode === "ko"
                  ? "플라톤은 선하다"
                  : "Plato is good";
              const conclusionPropCI =
                parsePropositionFromString(conclusionTextCI);
              const conclusionLi = Array.from(
                document.querySelectorAll("#premise-list li")
              ).find((li) => {
                const data = JSON.parse(li.dataset.propObject);
                return (
                  data.dependsOnAssumption &&
                  arePropositionsEqual(data.proposition, conclusionPropCI)
                );
              });
              if (conclusionLi) {
                highlightElement(conclusionLi);
                document
                  .getElementById("tutorial-next-btn")
                  .classList.add("hidden");
                waitForInteraction(
                  document.getElementById("premise-list"),
                  "click",
                  () => {
                    const selectedCheckbox =
                      conclusionLi.querySelector("input");
                    const allCheckboxes = document.querySelectorAll(
                      "#premise-list input:checked"
                    );
                    if (
                      selectedCheckbox.checked &&
                      allCheckboxes.length === 1
                    ) {
                      advanceTutorial();
                    }
                  }
                );
              }
              break;
            case 7: // Apply CI
              handleTutorialRuleApplication("conditionalIntroduction");
              break;
          }
        } else if (tutorialStep === 7) {
          // Stage 8 - Assumption (RAA)
          document.getElementById("tutorial-guide").classList.add("top");
          switch (tutorialSubStep) {
            case 1:
              highlightElement("#add-assumption-btn");
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              const correctAssumptionRAA =
                currentLang.langCode === "ko"
                  ? "소크라테스는 악하다 는 거짓이다"
                  : "Socrates is evil is false";
              const originalShowPrompt = window.showPrompt;
              window.showPrompt = (message, callback) => {
                originalShowPrompt(message, (value) => {
                  if (value === correctAssumptionRAA) {
                    window.showPrompt = originalShowPrompt;
                    callback(value);
                    advanceTutorial();
                  } else {
                    showAlert(
                      currentLang.langCode === "ko"
                        ? "올바른 명제를 입력해 주십시오."
                        : "Please enter a valid proposition."
                    );
                    callback(null);
                  }
                });
              };
              break;
            case 2:
              const premisesRAA_texts =
                currentLang.langCode === "ko"
                  ? [
                      "소크라테스는 악하다 는 거짓이다",
                      "(소크라테스는 악하다 는 거짓이다) 라면 (플라톤은 지혜롭다)",
                    ]
                  : [
                      "(Socrates is evil is false) then (Plato is wise)",
                      "Socrates is evil is false",
                    ];

              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              const premiseList_mp = document.getElementById("premise-list");
              const premiseProps_mp = premisesRAA_texts.map((text) =>
                parsePropositionFromString(text)
              );
              const premiseLis_mp = premiseProps_mp
                .map((prop) =>
                  Array.from(premiseList_mp.querySelectorAll("li")).find(
                    (li) => {
                      const data = JSON.parse(li.dataset.propObject);
                      return arePropositionsEqual(data.proposition, prop);
                    }
                  )
                )
                .filter(Boolean);

              premiseLis_mp.forEach((li) =>
                li.classList.add("tutorial-highlight")
              );
              document
                .getElementById("inference-rule-select")
                .classList.add("tutorial-highlight");
              document
                .getElementById("apply-rule-btn")
                .classList.add("tutorial-highlight");

              const applyBtn_mp = document.getElementById("apply-rule-btn");
              const select_mp = document.getElementById(
                "inference-rule-select"
              );

              const applyRuleHandler_mp = () => {
                const allChecked = premiseLis_mp.every(
                  (li) => li.querySelector("input").checked
                );
                const totalChecked =
                  premiseList_mp.querySelectorAll("input:checked").length;
                if (!allChecked || totalChecked !== premiseLis_mp.length) {
                  showAlert(
                    currentLang.langCode === "ko"
                      ? "먼저 가정과 다른 전제를 선택해주세요."
                      : "Please select the assumption and the other premise first."
                  );
                  return;
                }

                if (select_mp.value === "modusPonens") {
                  applyRuleTutorial();
                  advanceTutorial(); // Advances to subStep 3
                } else {
                  showAlert(currentLang.alerts.ruleFailed);
                }
              };
              waitForInteraction(applyBtn_mp, "click", applyRuleHandler_mp);
              break;
            case 3:
              // This substep now just shows the result text.
              // The logic is handled in case 2.
              // We just need to clear highlights and let the user click "Next".
              clearHighlights();
              break;
            case 4: // This case now handles both selection and application for RAA.
              const contradictionPairTexts =
                currentLang.langCode === "ko"
                  ? ["플라톤은 지혜롭다", "플라톤은 지혜롭다 는 거짓이다"]
                  : ["Plato is wise", "Plato is wise is false"];

              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              const premiseList = document.getElementById("premise-list");
              const premiseProps = contradictionPairTexts.map((text) =>
                parsePropositionFromString(text)
              );
              const premiseLis = premiseProps
                .map((prop) =>
                  Array.from(premiseList.querySelectorAll("li")).find((li) => {
                    const data = JSON.parse(li.dataset.propObject);
                    return arePropositionsEqual(data.proposition, prop);
                  })
                )
                .filter(Boolean);

              premiseLis.forEach((li) =>
                li.classList.add("tutorial-highlight")
              );
              highlightElement("#inference-rule-select");
              document
                .getElementById("apply-rule-btn")
                .classList.add("tutorial-highlight");

              const applyBtn = document.getElementById("apply-rule-btn");
              const select = document.getElementById("inference-rule-select");

              const applyRuleHandler = () => {
                const allChecked = premiseLis.every(
                  (li) => li.querySelector("input").checked
                );
                const totalChecked =
                  premiseList.querySelectorAll("input:checked").length;
                if (!allChecked || totalChecked !== premiseLis.length) {
                  showAlert(
                    currentLang.langCode === "ko"
                      ? "먼저 모순되는 두 전제를 선택해주세요."
                      : "Please select the two contradictory premises first."
                  );
                  return;
                }

                if (select.value === "reductioAdAbsurdum") {
                  applyRuleTutorial();
                  advanceTutorial(); // Advances to subStep 5
                } else {
                  showAlert(currentLang.alerts.ruleFailed);
                }
              };
              waitForInteraction(applyBtn, "click", applyRuleHandler);
              break;
            case 5: // This is the step where the RAA result is shown and DNE is expected
              clearHighlights();
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden"); // Hide the "Next" button

              const raaResultText =
                currentLang.langCode === "ko"
                  ? "소크라테스는 악하다 는 거짓이다 는 거짓이다"
                  : "Socrates is evil is false is false";
              const raaResultProp = parsePropositionFromString(raaResultText);

              const premiseListForDNE = document.getElementById("premise-list");
              const raaResultLi = Array.from(
                premiseListForDNE.querySelectorAll("li")
              ).find((li) => {
                const data = JSON.parse(li.dataset.propObject);
                // Check if it's a theorem derived from RAA and matches the expected proposition
                return (
                  data.type === "theorem" &&
                  data.label === currentLang.labels.raa_theorem &&
                  arePropositionsEqual(data.proposition, raaResultProp)
                );
              });

              if (raaResultLi) {
                highlightElement(raaResultLi); // Highlight the RAA result
                highlightElement("#inference-rule-select"); // Highlight the rule dropdown
                document
                  .getElementById("apply-rule-btn")
                  .classList.add("tutorial-highlight"); // Highlight the apply button

                const applyBtnDNE = document.getElementById("apply-rule-btn");
                const selectDNE = document.getElementById(
                  "inference-rule-select"
                );

                const applyRuleHandlerDNE = () => {
                  const selectedCheckboxes = premiseListForDNE.querySelectorAll(
                    'input[type="checkbox"]:checked'
                  );
                  const isRaaResultSelected = Array.from(
                    selectedCheckboxes
                  ).some((chk) => chk.parentElement === raaResultLi);

                  // Check if exactly one premise is selected, it's the RAA result, and DNE rule is chosen
                  if (
                    selectedCheckboxes.length === 1 &&
                    isRaaResultSelected &&
                    selectDNE.value === "doubleNegationElimination"
                  ) {
                    applyRuleTutorial(); // Apply the rule
                    advanceTutorial(); // Proceed to the next tutorial step
                  } else {
                    showAlert(currentLang.alerts.ruleFailed); // Show error if conditions not met
                  }
                };
                waitForInteraction(applyBtnDNE, "click", applyRuleHandlerDNE);
              } else {
                // Fallback if RAA result not found (shouldn't happen in normal tutorial flow)
                console.error(
                  "Tutorial Error: RAA result not found for DNE step."
                );
                advanceTutorial(); // Proceed to next step if something went wrong
              }
              break;
            case 6: // This is the final text step
              clearHighlights();
              // No specific interaction needed, just display text and allow "Next" to end tutorial
              break;
          }
        }
      }

      function handleTutorialRuleInteraction(premiseTexts) {
        document.getElementById("tutorial-next-btn").classList.add("hidden");
        const premiseList = document.getElementById("premise-list");
        const premiseProps = premiseTexts.map((text) =>
          parsePropositionFromString(text)
        );
        const premiseLis = premiseProps
          .map((prop) =>
            Array.from(premiseList.querySelectorAll("li")).find((li) => {
              const data = JSON.parse(li.dataset.propObject);
              return arePropositionsEqual(data.proposition, prop);
            })
          )
          .filter(Boolean);

        if (premiseLis.length !== premiseTexts.length) {
          console.error(
            "Tutorial Error: Could not find all required premises in the list.",
            premiseTexts
          );
          return;
        }

        premiseLis.forEach((li) => li.classList.add("tutorial-highlight"));

        const checkPremises = () => {
          const allChecked = premiseLis.every(
            (li) => li.querySelector("input").checked
          );
          const totalChecked =
            premiseList.querySelectorAll("input:checked").length;
          if (allChecked && totalChecked === premiseLis.length) {
            advanceTutorial();
          }
        };
        waitForInteraction(premiseList, "click", checkPremises);
      }

      function handleTutorialRuleApplication(ruleValue) {
        document.getElementById("tutorial-next-btn").classList.add("hidden");
        highlightElement("#inference-rule-select");
        document
          .getElementById("apply-rule-btn")
          .classList.add("tutorial-highlight");

        const applyBtn = document.getElementById("apply-rule-btn");
        const select = document.getElementById("inference-rule-select");

        const applyRuleHandler = () => {
          if (select.value === ruleValue) {
            applyRuleTutorial();
            advanceTutorial();
          } else {
            showAlert(currentLang.alerts.ruleFailed);
          }
        };
        waitForInteraction(applyBtn, "click", applyRuleHandler);
      }

      function setupTutorialScenario(step) {
        if (step === 1) {
          // Initial setup for the whole tutorial.
          playerA_Hand = [];
          playerB_Hand = [];
          truePropositions = [];

          // 튜토리얼은 소크라테스와 플라톤을 기준으로 공리를 생성합니다.
          const socratesSubject = currentLang.keywords.socrates;
          const platoSubject = currentLang.keywords.plato;
          currentAxioms = generateAxioms(
            socratesSubject,
            platoSubject,
            currentLang
          );

          parsedAxioms = currentAxioms
            .map((str) => ({
              type: "axiom",
              proposition: parsePropositionFromString(str),
            }))
            .filter((a) => a.proposition);
          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentProposition = [];
          currentPlayer = "A";
          propositionStarter = "A";
          gameIsOver = false;
          currentRound = 1;
          isThinkingTime = false;
          lastPropositionMaker = null;
          currentAssumption = null;
          lastCardPlayer = null;
          cardsPlayedThisTurn = { A: 0, B: 0 };
          gameMode = "2P";

          const socratesCardText = currentLang.keywords.socrates;
          const requiredA_CardTexts = [
            socratesCardText,
            currentLang.keywords.and,
            currentLang.keywords.or,
            currentLang.keywords.if,
            currentLang.keywords.not,
            currentLang.langCode === "ko" ? "개는" : "dog",
            currentLang.langCode === "ko" ? "새는" : "bird",
            currentLang.langCode === "ko" ? "물고기는" : "fish",
            currentLang.keywords.universal_q,
            currentLang.keywords.existential_q,
          ];
          playerA_Hand = fullDeck.filter((c) =>
            requiredA_CardTexts.includes(c.text)
          );

          const wiseCardText =
            currentLang.langCode === "ko" ? "지혜롭다" : "is wise";
          const requiredB_CardTexts = [
            wiseCardText,
            currentLang.keywords.plato,
          ];
          playerB_Hand = fullDeck.filter((c) =>
            requiredB_CardTexts.includes(c.text)
          );
          playerB_Hand.push(
            ...fullDeck
              .filter(
                (c) =>
                  !requiredB_CardTexts.includes(c.text) &&
                  c.type ===
                    (currentLang.langCode === "ko" ? "서술어" : "Predicate")
              )
              .slice(0, 2)
          );
        } else if (step === 2) {
          const socratesCardInfo = currentProposition.find(
            (info) => info.card.text === currentLang.keywords.socrates
          );
          const wiseCardText =
            currentLang.langCode === "ko" ? "지혜롭다" : "is wise";
          const wiseCardIndex = playerB_Hand.findIndex(
            (c) => c.text === wiseCardText
          );

          if (socratesCardInfo && wiseCardIndex > -1) {
            const [wiseCard] = playerB_Hand.splice(wiseCardIndex, 1);
            currentProposition = [
              socratesCardInfo,
              { card: wiseCard, player: "B" },
            ];
            lastCardPlayer = "B";
            currentPlayer = "A";
          }
        } else if (step === 4) {
          currentProposition = [];
          playerA_Hand = fullDeck.filter(
            (c) =>
              c.type ===
                (currentLang.langCode === "ko" ? "연산자" : "Operator") &&
              c.text !== currentLang.keywords.not
          );
          playerB_Hand = fullDeck.filter(
            (c) =>
              c.type ===
                (currentLang.langCode === "ko" ? "서술어" : "Predicate") &&
              c.text !== (currentLang.langCode === "ko" ? "개이다" : "is a dog")
          );

          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);

          const premises = [
            currentLang.langCode === "ko"
              ? "소크라테스는 개이다"
              : "Socrates is a dog",
            currentLang.langCode === "ko"
              ? "모든 개는 지혜롭다"
              : "Every dog is wise",
          ];
          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (parsed) {
              truePropositions.push({
                type: "user-made",
                text: pText,
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
          startThinkingTime();
        } else if (step === 5) {
          // Setup for all basic inference rules
          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentPlayer = "A";
          isThinkingTime = false;
          document.getElementById("thinking-time-controls").style.display =
            "none";

          const premises = [
            // For Modus Ponens
            currentLang.langCode === "ko"
              ? "소크라테스는 선하다"
              : "Socrates is good",
            currentLang.langCode === "ko"
              ? "(소크라테스는 선하다) 라면 (소크라테스는 승리한다)"
              : "(Socrates is good) then (Socrates wins)",
            // For Modus Tollens
            currentLang.langCode === "ko"
              ? "플라톤은 지혜롭다 는 거짓이다"
              : "Plato is wise is false",
            currentLang.langCode === "ko"
              ? "(플라톤은 승리한다) 라면 (플라톤은 지혜롭다)"
              : "(Plato wins) then (Plato is wise)",
            // For Disjunctive Syllogism
            currentLang.langCode === "ko"
              ? "(어떤 새는 물고기이다) 또는 (어떤 새는 새이다)"
              : "(Some bird is a fish) or (Some bird is a bird)",
            currentLang.langCode === "ko"
              ? "어떤 새는 물고기이다 는 거짓이다"
              : "Some bird is a fish is false",
            // For Hypothetical Syllogism
            currentLang.langCode === "ko"
              ? "(플라톤은 개이다) 라면 (플라톤은 선하다)"
              : "(Plato is a dog) then (Plato is good)",
            currentLang.langCode === "ko"
              ? "(플라톤은 선하다) 라면 (플라톤은 승리한다)"
              : "(Plato is good) then (Plato wins)",
            // For Simplification
            currentLang.langCode === "ko"
              ? "(소크라테스는 지혜롭다) 그리고 (플라톤은 어리석다)"
              : "(Socrates is wise) and (Plato is foolish)",
            // For Double Negation
            currentLang.langCode === "ko"
              ? "어떤 물고기는 선하다 는 거짓이다 는 거짓이다"
              : "Some fish is good is false is false",
            // For Universal Application
            currentLang.langCode === "ko"
              ? "모든 새는 선하다"
              : "Every bird is good",
            currentLang.langCode === "ko"
              ? "플라톤은 새이다"
              : "Plato is a bird",
            // For Existential Instantiation
            currentLang.langCode === "ko"
              ? "모든 개는 선하다"
              : "Every dog is good",
          ];

          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (
              parsed &&
              !internalTruthSet.some((p) => arePropositionsEqual(p, parsed))
            ) {
              truePropositions.push({
                type: "user-made",
                text: pText,
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
        } else if (step === 6) {
          // Setup for Proof by Cases
          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentPlayer = "A";
          isThinkingTime = false;
          document.getElementById("thinking-time-controls").style.display =
            "none";

          const premises =
            currentLang.langCode === "ko"
              ? [
                  "플라톤은 선하다 또는 플라톤은 악하다",
                  "(플라톤은 선하다) 라면 (플라톤은 지혜롭다)",
                  "(플라톤은 악하다) 라면 (플라톤은 지혜롭다)",
                ]
              : [
                  "Plato is good or Plato is evil",
                  "(Plato is good) then (Plato is wise)",
                  "(Plato is evil) then (Plato is wise)",
                ];

          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (
              parsed &&
              !internalTruthSet.some((p) => arePropositionsEqual(p, parsed))
            ) {
              truePropositions.push({
                type: "user-made",
                text: pText,
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
          openEurekaModalTutorial();
        } else if (step === 7) {
          // Setup for Conditional Introduction ★★★ MODIFIED SECTION ★★★
          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentPlayer = "A";
          isThinkingTime = false;
          document.getElementById("thinking-time-controls").style.display =
            "none";
          const premises =
            currentLang.langCode === "ko"
              ? [
                  "(소크라테스는 지혜롭다) 라면 (플라톤은 개이다)",
                  "(플라톤은 개이다) 라면 (플라톤은 선하다)",
                ]
              : [
                  "(Socrates is wise) then (Plato is a dog)",
                  "(Plato is a dog) then (Plato is good)",
                ];

          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (parsed) {
              truePropositions.push({
                type: "user-made",
                text: propositionToNaturalText(parsed),
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
          openEurekaModalTutorial();
        } else if (step === 8) {
          // Setup for Reductio ad Absurdum
          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentPlayer = "A";
          isThinkingTime = false;
          document.getElementById("thinking-time-controls").style.display =
            "none";
          const premises =
            currentLang.langCode === "ko"
              ? [
                  "(소크라테스는 악하다 는 거짓이다) 라면 (플라톤은 지혜롭다)",
                  "플라톤은 지혜롭다 는 거짓이다",
                ]
              : [
                  "(Socrates is evil is false) then (Plato is wise)",
                  "Plato is wise is false",
                ];

          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (
              parsed &&
              !internalTruthSet.some((p) => arePropositionsEqual(p, parsed))
            ) {
              truePropositions.push({
                type: "user-made",
                text: pText,
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
          openEurekaModalTutorial();
        }
        render();
      }

      function playCardTutorial(cardToPlay) {
        const hand = currentPlayer === "A" ? playerA_Hand : playerB_Hand;
        const cardIndex = hand.findIndex(
          (c) => c.text === cardToPlay.text && c.type === cardToPlay.type
        );

        if (cardIndex > -1) {
          const [playedCard] = hand.splice(cardIndex, 1);
          currentProposition.push({ card: playedCard, player: currentPlayer });
          cardsPlayedThisTurn[currentPlayer]++;
          lastCardPlayer = currentPlayer;
          render();
        }
      }

      function endTurnTutorial() {
        currentPlayer = currentPlayer === "A" ? "B" : "A";
        cardsPlayedThisTurn.A = 0;
        cardsPlayedThisTurn.B = 0;
        render();
      }

      function completePropositionTutorial() {
        const parsedProp = parsePropositionFromCards([...currentProposition]);
        if (parsedProp) {
          truePropositions.push({
            type: "user-made",
            round: currentRound,
            proposition: parsedProp,
            original_cards: [...currentProposition],
          });
          lastPropositionMaker =
            currentProposition[currentProposition.length - 1].player;
          currentPlayer = lastPropositionMaker === "A" ? "B" : "A";
          currentProposition = [];
          lastCardPlayer = null;
          cardsPlayedThisTurn = { A: 0, B: 0 };
          render();
        }
      }

      function openEurekaModalTutorial() {
        derivedPropositionsInModal = [];
        currentAssumption = null;
        const modal = document.getElementById("eureka-modal");
        const premiseList = document.getElementById("premise-list");
        premiseList.innerHTML = "";

        const allSelectablePropositions = [
          ...parsedAxioms,
          ...truePropositions.filter(
            (p) => p.type === "user-made" || p.type === "theorem"
          ),
        ];
        allSelectablePropositions.forEach((propData) => {
          let label;
          switch (propData.type) {
            case "axiom":
              label = currentLang.labels.axiom;
              break;
            case "victory":
              label = currentLang.labels.victory_condition;
              break;
            case "theorem":
              label = currentLang.labels.theorem;
              break;
            default:
              label = currentLang.labels.proposition;
          }
          addPremiseToWorkbench({
            proposition: propData.proposition,
            type: propData.type,
            dependsOnAssumption: false,
            isAssumption: false,
            label: label,
          });
        });

        const modalTitle = document.getElementById("eureka-title");
        const confirmBtn = document.getElementById("modal-confirm-btn");
        modalTitle.textContent = isThinkingTime
          ? currentLang.modals.eurekaTitleTheorem
          : currentLang.modals.eurekaTitleVictory;
        confirmBtn.textContent = isThinkingTime
          ? currentLang.modals.confirmTheoremButton
          : currentLang.modals.confirmVictoryButton;

        document.getElementById("cancel-assumption-btn").style.display =
          currentAssumption ? "inline-block" : "none";

        renderModal();
        modal.classList.add("visible");
      }

      function applyRuleTutorial() {
        const selectedLis = Array.from(
          document.querySelectorAll(
            '#premise-list input[type="checkbox"]:checked'
          )
        );
        const rule = document.getElementById("inference-rule-select").value;
        const premisesData = selectedLis
          .map((chk) => {
            const propString = chk.parentElement.dataset.propObject;
            return propString ? JSON.parse(propString) : null;
          })
          .filter(Boolean);

        const premises = premisesData.map((data) => data.proposition);
        let conclusions = [];

        const onePremiseRules = [
          "conjunctionElimination",
          "doubleNegationElimination",
          "existentialInstantiation",
        ];
        const twoPremiseRules = [
          "modusPonens",
          "modusTollens",
          "hypotheticalSyllogism",
          "disjunctiveSyllogism",
          "universalApplication",
        ];
        const threePremiseRules = ["proofByCases"];

        if (rule === "conditionalIntroduction") {
          const result = {
            type: "conditional",
            left: currentAssumption,
            right: premises[0],
          };
          if (result) {
            derivedPropositionsInModal = derivedPropositionsInModal.filter(
              (p) => !p.dependsOnAssumption
            );
            currentAssumption = null;
            addPremiseToWorkbench({
              proposition: result,
              type: "theorem",
              dependsOnAssumption: false,
              isAssumption: false,
              label: currentLang.labels.ci_theorem,
            });
          }
        } else if (rule === "reductioAdAbsurdum") {
          const result = reductioAdAbsurdum(
            premises[0],
            premises[1],
            currentAssumption
          );
          if (result) {
            derivedPropositionsInModal = derivedPropositionsInModal.filter(
              (p) => !p.dependsOnAssumption
            );
            currentAssumption = null;
            addPremiseToWorkbench({
              proposition: result,
              type: "theorem",
              dependsOnAssumption: false,
              isAssumption: false,
              label: currentLang.labels.raa_theorem,
            });
          }
        } else if (threePremiseRules.includes(rule)) {
          const result = window[rule](premises[0], premises[1], premises[2]);
          if (result) conclusions.push(result);
        } else if (twoPremiseRules.includes(rule)) {
          const result = window[rule](premises[0], premises[1]);
          if (result) conclusions.push(result);
        } else if (onePremiseRules.includes(rule)) {
          const result = window[rule](premises[0]);
          if (result) {
            if (Array.isArray(result)) conclusions.push(...result);
            else conclusions.push(result);
          }
        }

        if (conclusions.length > 0 && conclusions[0] != null) {
          const isDependent = premisesData.some((p) => p.dependsOnAssumption);
          conclusions.forEach((conc) => {
            addPremiseToWorkbench({
              proposition: conc,
              type: "theorem",
              dependsOnAssumption: isDependent,
              isAssumption: false,
              label: currentLang.labels.theorem,
            });
          });
        }
        renderModal();
      }

      function addTheoremsToListTutorial() {
        const selectedLis = Array.from(
          document.querySelectorAll(
            '#premise-list input[type="checkbox"]:checked'
          )
        );
        const newTheorems = selectedLis
          .map((li) => {
            const propString = li.parentElement.dataset.propObject;
            return propString ? JSON.parse(propString) : null;
          })
          .filter((p) => p && p.type === "theorem" && !p.dependsOnAssumption);

        newTheorems.forEach((theoremData) => {
          const isDuplicate = truePropositions.some((p) =>
            arePropositionsEqual(p.proposition, theoremData.proposition)
          );
          if (!isDuplicate) {
            truePropositions.push({
              type: "theorem",
              round: currentRound,
              proposition: theoremData.proposition,
            });
          }
        });
        document.getElementById("eureka-modal").classList.remove("visible");
        render();
      }

      function highlightElement(elementOrSelector, remove = false) {
        clearHighlights();
        if (remove) return;

        const element =
          typeof elementOrSelector === "string"
            ? document.querySelector(elementOrSelector)
            : elementOrSelector;
        if (element) {
          element.classList.add("tutorial-highlight");
        }
      }

      function clearHighlights() {
        document
          .querySelectorAll(".tutorial-highlight")
          .forEach((el) => el.classList.remove("tutorial-highlight"));
      }

      function waitForInteraction(element, eventType, callback) {
        if (temporaryListener) {
          temporaryListener.element.removeEventListener(
            temporaryListener.type,
            temporaryListener.handler
          );
        }
        const handler = (event) => {
          // For checkbox clicks, we don't want to stop propagation
          if (eventType !== "click" || event.target.type !== "checkbox") {
            event.stopPropagation();
          }
          callback(event);
        };
        element.addEventListener(eventType, handler, {
          once: eventType !== "click",
        });

        temporaryListener = { element, type: eventType, handler };
      }

      // 기존 endTutorial 함수를 아래 코드로 교체하세요.
      function endTutorial() {
        inTutorialMode = false;
        document.getElementById("tutorial-guide").classList.add("hidden");
        clearHighlights();

        const tutorialBtn = document.getElementById("tutorial-btn");
        tutorialBtn.textContent = currentLang.ui.tutorialButton;
        tutorialBtn.removeEventListener("click", endTutorial);
        tutorialBtn.addEventListener("click", startTutorial);

        document
          .querySelectorAll(
            ".header-buttons-left button, .header-buttons-right button"
          )
          .forEach((btn) => {
            btn.disabled = false;
          });
        document.getElementById("eureka-modal").classList.remove("visible");

        // ▼▼▼▼▼ 이 부분을 수정합니다 ▼▼▼▼▼
        // resetGame() 대신 메인 메뉴를 표시하여 상태를 완전히 초기화합니다.
        showMainMenu();
        // ▲▲▲▲▲ 여기까지 수정 ▲▲▲▲▲
      }

      function showAlert(message, callback) {
        const modal = document.getElementById("alert-modal");
        document.getElementById("alert-message").textContent = message;
        modal.classList.add("visible");

        // 기존 이벤트 제거
        const okBtn = document.getElementById("alert-ok-btn");
        const newBtn = okBtn.cloneNode(true);
        okBtn.parentNode.replaceChild(newBtn, okBtn);

        newBtn.addEventListener("click", () => {
          modal.classList.remove("visible");
          if (callback) callback();
        });
      }

      function showPrompt(message, callback) {
        const modal = document.getElementById("prompt-modal");
        document.getElementById("prompt-message").textContent = message;
        const input = document.getElementById("prompt-input");
        const confirmBtn = document.getElementById("prompt-confirm-btn");
        const cancelBtn = document.getElementById("prompt-cancel-btn");
        input.value = "";

        const confirmHandler = () => {
          cleanup();
          callback(input.value);
        };
        const cancelHandler = () => {
          cleanup();
          callback(null);
        };
        const cleanup = () => {
          modal.classList.remove("visible");
          confirmBtn.removeEventListener("click", confirmHandler);
          cancelBtn.removeEventListener("click", cancelHandler);
        };

        confirmBtn.addEventListener("click", confirmHandler);
        cancelBtn.addEventListener("click", cancelHandler);
        modal.classList.add("visible");
        input.focus();
      }

      // --- GAME FLOW & TURN MANAGEMENT ---
      function modusPonens(p1, p2) {
        if (!p1 || !p2) return null;
        if (p2.type === "conditional" && arePropositionsEqual(p1, p2.left))
          return p2.right;
        if (p1.type === "conditional" && arePropositionsEqual(p2, p1.left))
          return p1.right;
        return null;
      }

      function modusTollens(p1, p2) {
        if (!p1 || !p2) return null;
        const check = (c, o) => {
          if (c.type !== "conditional") return null;
          const consequent = c.right;
          let isContradiction = false;
          if (
            o.type === "negation" &&
            arePropositionsEqual(o.proposition, consequent)
          ) {
            isContradiction = true;
          }
          if (
            consequent.type === "negation" &&
            arePropositionsEqual(consequent.proposition, o)
          ) {
            isContradiction = true;
          }
          if (isContradiction) {
            return { type: "negation", proposition: c.left };
          }
          return null;
        };
        return check(p1, p2) || check(p2, p1);
      }

      function disjunctiveSyllogism(p1, p2) {
        /**
         * 두 명제가 서로 모순 관계인지 확인하는 헬퍼 함수.
         * 예: (P, ~P) 또는 (~P, P)는 참을 반환합니다.
         * @param {object} propA - 명제 객체 1
         * @param {object} propB - 명제 객체 2
         * @returns {boolean} 모순 관계이면 true
         */
        const areContradictory = (propA, propB) => {
          // propA가 ~X이고 propB가 X인 경우
          if (
            propA.type === "negation" &&
            arePropositionsEqual(propA.proposition, propB)
          ) {
            return true;
          }
          // propB가 ~X이고 propA가 X인 경우
          if (
            propB.type === "negation" &&
            arePropositionsEqual(propB.proposition, propA)
          ) {
            return true;
          }
          return false;
        };

        /**
         * 선언적 삼단논법을 적용하는 내부 함수.
         * @param {object} d - disjunction 타입으로 추정되는 명제
         * @param {object} o - 나머지 명제
         * @returns {object|null} 추론 결과 또는 null
         */
        const check = (d, o) => {
          if (d.type !== "disjunction") return null;

          // 다른 전제(o)가 선언문의 왼쪽 부분(d.left)과 모순 관계일 때
          // 예: (P ∨ Q)와 ~P가 주어지면 Q를 반환 (이때 ~P는 ~~P와도 모순)
          if (areContradictory(d.left, o)) {
            return d.right;
          }

          // 다른 전제(o)가 선언문의 오른쪽 부분(d.right)과 모순 관계일 때
          // 예: (P ∨ Q)와 ~Q가 주어지면 P를 반환
          if (areContradictory(d.right, o)) {
            return d.left;
          }

          return null;
        };

        // p1, p2 순서와 p2, p1 순서 모두 확인
        return check(p1, p2) || check(p2, p1);
      }

      function conjunctionIntroduction(p1, p2) {
        if (!p1 || !p2) return null;
        return { type: "conjunction", left: p1, right: p2 };
      }

      function conjunctionElimination(p) {
        if (p && p.type === "conjunction") return [p.left, p.right];
        return null;
      }

      function doubleNegationElimination(p) {
        if (p && p.type === "negation" && p.proposition.type === "negation")
          return p.proposition.proposition;
        return null;
      }

      function hypotheticalSyllogism(p1, p2) {
        if (!p1 || !p2) return null;
        const check = (c1, c2) => {
          if (
            c1.type === "conditional" &&
            c2.type === "conditional" &&
            arePropositionsEqual(c1.right, c2.left)
          )
            return { type: "conditional", left: c1.left, right: c2.right };
          return null;
        };
        return check(p1, p2) || check(p2, p1);
      }

      function existentialInstantiation(p) {
        if (p && p.type === "universal") {
          return {
            type: "existential",
            entity: p.entity,
            predicate: p.predicate,
          };
        }
        return null;
      }

      function universalApplication(p1, p2) {
        if (!p1 || !p2) return null;
        const getBaseNoun = (text) => {
          if (currentLang.langCode === "ko") {
            return text.replace(/(이다|는|은)$/, "").trim();
          } else {
            return text.replace(/^is a /, "").trim();
          }
        };
        const check = (propA, propB) => {
          if (propA.type === "atomic" && propB.type === "universal") {
            const atomicPredicateBase = getBaseNoun(propA.predicate);
            const universalEntityBase = getBaseNoun(propB.entity);
            if (atomicPredicateBase === universalEntityBase) {
              return {
                type: "atomic",
                subject: propA.subject,
                predicate: propB.predicate,
              };
            }
          }
          if (propA.type === "existential" && propB.type === "universal") {
            const existentialPredicateBase = getBaseNoun(propA.predicate);
            const universalEntityBase = getBaseNoun(propB.entity);
            if (existentialPredicateBase === universalEntityBase) {
              return {
                type: "existential",
                entity: propA.entity,
                predicate: propB.predicate,
              };
            }
          }
          if (propA.type === "universal" && propB.type === "universal") {
            const propAPredicateBase = getBaseNoun(propA.predicate);
            const propBEntityBase = getBaseNoun(propB.entity);
            if (propAPredicateBase === propBEntityBase) {
              return {
                type: "universal",
                entity: propA.entity,
                predicate: propB.predicate,
              };
            }
          }
          return null;
        };
        return check(p1, p2) || check(p2, p1);
      }

      function reductioAdAbsurdum(p1, p2, assumption) {
        if (!p1 || !p2) return null;
        const isContradiction =
          (p1.type === "negation" &&
            arePropositionsEqual(p1.proposition, p2)) ||
          (p2.type === "negation" && arePropositionsEqual(p2.proposition, p1));
        if (isContradiction && assumption) {
          return { type: "negation", proposition: assumption };
        }
        return null;
      }

      function proofByCases(p1, p2, p3) {
        if (!p1 || !p2 || !p3) return null;
        const premises = [p1, p2, p3];
        const disjunction = premises.find((p) => p.type === "disjunction");
        if (!disjunction) return null;
        const conditionals = premises.filter((p) => p.type === "conditional");
        if (conditionals.length !== 2) return null;
        const p = disjunction.left;
        const q = disjunction.right;
        const cond1 = conditionals[0];
        const cond2 = conditionals[1];
        const caseA =
          arePropositionsEqual(cond1.left, p) &&
          arePropositionsEqual(cond2.left, q) &&
          arePropositionsEqual(cond1.right, cond2.right);
        const caseB =
          arePropositionsEqual(cond1.left, q) &&
          arePropositionsEqual(cond2.left, p) &&
          arePropositionsEqual(cond1.right, cond2.right);
        if (caseA || caseB) {
          return cond1.right;
        }
        return null;
      }

      function isContradictory(newProp, allTrueProps) {
        for (const trueProp of allTrueProps) {
          if (
            trueProp.type === "negation" &&
            arePropositionsEqual(newProp, trueProp.proposition)
          )
            return true;
          if (
            newProp.type === "negation" &&
            arePropositionsEqual(newProp.proposition, trueProp)
          )
            return true;
        }
        if (newProp.type === "atomic" || newProp.type === "universal") {
          const predicatePairs = currentLang.contradictoryPredicates;
          let oppositePredicate = null;
          for (const key in predicatePairs) {
            if (key === newProp.predicate) {
              oppositePredicate = predicatePairs[key];
              break;
            }
            if (predicatePairs[key] === newProp.predicate) {
              oppositePredicate = key;
              break;
            }
          }
          if (oppositePredicate) {
            for (const trueProp of allTrueProps) {
              if (trueProp.type === newProp.type) {
                const sameSubject =
                  (newProp.type === "atomic" &&
                    trueProp.subject === newProp.subject) ||
                  (newProp.type === "universal" &&
                    trueProp.entity === newProp.entity);
                if (sameSubject && trueProp.predicate === oppositePredicate) {
                  return true;
                }
              }
            }
          }
        }
        return false;
      }

      function verifyAndExpandTruths(newProposition) {
        const tempTruthSet = JSON.parse(JSON.stringify(internalTruthSet));
        const worklist = [];
        const addSafe = (prop, list) => {
          if (!prop) return true;
          if (isContradictory(prop, list)) return false;
          if (list.some((p) => arePropositionsEqual(p, prop))) return true;
          list.push(prop);
          worklist.push(prop);
          return true;
        };
        if (!addSafe(newProposition, tempTruthSet)) return { success: false };
        while (worklist.length > 0) {
          const currentProp = worklist.shift();
          if (!addSafe(doubleNegationElimination(currentProp), tempTruthSet))
            return { success: false };
          const conjuctElimResults = conjunctionElimination(currentProp);
          if (conjuctElimResults) {
            for (const p of conjuctElimResults) {
              if (!addSafe(p, tempTruthSet)) return { success: false };
            }
          }
          const currentFullSet = [...tempTruthSet];
          for (const existingProp of currentFullSet) {
            if (arePropositionsEqual(currentProp, existingProp)) continue;
            const rules = [
              modusPonens,
              modusTollens,
              hypotheticalSyllogism,
              disjunctiveSyllogism,
              universalApplication,
            ];
            for (const rule of rules) {
              const result = rule(currentProp, existingProp);
              if (!addSafe(result, tempTruthSet)) return { success: false };
            }
          }
        }
        return { success: true, expandedSet: tempTruthSet };
      }

      function isValidPlay(cardToPlay, proposition) {
        if (inTutorialMode) {
          const highlightedCard = document.querySelector(".tutorial-highlight");
          return (
            highlightedCard && highlightedCard.textContent === cardToPlay.text
          );
        }

        const propLength = proposition.length;
        const { if: ifKeyword, and, or, not } = currentLang.keywords;
        const isConnective = (card) => [ifKeyword, and, or].includes(card.text);
        const [properNoun, quantifier, entity, predicate, operator] =
          currentLang.cardTypes;

        if (propLength === 0) {
          return (
            cardToPlay.type === properNoun || cardToPlay.type === quantifier
          );
        }

        const lastCardInfo = proposition[propLength - 1];

        if (cardToPlay.text === not) {
          // '는 거짓이다'가 적용될 절(clause)을 찾습니다.
          const connectiveIndex = proposition
            .map((info) => info.card)
            .findIndex(isConnective);
          const clauseToNegate =
            connectiveIndex > -1
              ? proposition.slice(connectiveIndex + 1)
              : [...proposition];
          const newClauseWithNegation = [
            ...clauseToNegate,
            { card: cardToPlay, player: currentPlayer },
          ];
          return parsePropositionFromCards(newClauseWithNegation) !== null;
        }

        if (isConnective(cardToPlay)) {
          if (proposition.some((info) => isConnective(info.card))) return false;
          const connectiveIndex = proposition
            .map((info) => info.card)
            .findIndex(isConnective);
          const partToCheck =
            connectiveIndex > -1
              ? proposition.slice(connectiveIndex + 1)
              : proposition;
          return parsePropositionFromCards(partToCheck) !== null;
        }

        if (isConnective(lastCardInfo.card)) {
          return (
            cardToPlay.type === properNoun || cardToPlay.type === quantifier
          );
        }

        const connectiveIndex = proposition
          .map((info) => info.card)
          .findIndex(isConnective);
        const currentSimpleProp =
          connectiveIndex > -1
            ? proposition.slice(connectiveIndex + 1)
            : proposition;

        if (currentSimpleProp.length === 1) {
          const lastType = currentSimpleProp[0].card.type;
          if (lastType === properNoun) return cardToPlay.type === predicate;
          if (lastType === quantifier) return cardToPlay.type === entity;
        }
        if (currentSimpleProp.length === 2) {
          if (
            currentSimpleProp[0].card.type === quantifier &&
            currentSimpleProp[1].card.type === entity
          ) {
            return cardToPlay.type === predicate;
          }
        }
        return false;
      }

      function checkNextTurn() {
        if (gameIsOver || isThinkingTime || inTutorialMode) return;

        if (gameMode === "AI" && currentPlayer === aiPlayer) {
          render();
          if (aiTimeoutId) clearTimeout(aiTimeoutId);
          aiTimeoutId = setTimeout(aiTurn, 1500);
        } else {
          checkRoundEndConditions();
        }
      }

      function endTurn() {
        if (cardsPlayedThisTurn[currentPlayer] === 0) return;

        const playerWhoEndedTurn = currentPlayer;
        cardsPlayedThisTurn[playerWhoEndedTurn] = 0;

        currentPlayer = currentPlayer === "A" ? "B" : "A";

        render();
        checkNextTurn();
      }

      /**
       * 상대방의 손패를 분석하여 위협적인 카드 정보를 반환합니다.
       * @param {Array} opponentHand - 상대방의 카드 객체 배열.
       * @param {string} myCorePredicate - AI의 승리 조건과 직결된 핵심 서술어.
       * @param {object} langData - 현재 언어 설정 데이터 (TEXTS.ko 또는 TEXTS.en).
       * @returns {{hasNegation: boolean, hasContradictoryToMyWinCon: boolean}}
       * - hasNegation: 부정 카드('는 거짓이다') 존재 여부
       * - hasContradictoryToMyWinCon: AI의 승리 조건과 모순되는 서술어 존재 여부
       */
      function analyzeOpponentThreats(opponentHand, myCorePredicate, langData) {
        const threats = {
          hasNegation: false,
          hasContradictoryToMyWinCon: false,
        };

        // AI의 핵심 서술어와 모순되는 서술어 찾기
        let contradictoryPredicate = null;
        const predicatePairs = langData.contradictoryPredicates;
        for (const key in predicatePairs) {
          if (key === myCorePredicate) {
            contradictoryPredicate = predicatePairs[key];
            break;
          }
          if (predicatePairs[key] === myCorePredicate) {
            contradictoryPredicate = key;
            break;
          }
        }

        // 상대방 손패 순회
        for (const card of opponentHand) {
          // 부정 카드 확인
          if (card.text === langData.keywords.not) {
            threats.hasNegation = true;
          }
          // AI 승리 조건과 모순되는 서술어 카드 확인
          if (
            card.type === langData.cardTypes[3] /* 서술어 or Predicate */ &&
            card.text === contradictoryPredicate
          ) {
            threats.hasContradictoryToMyWinCon = true;
          }
        }

        return threats;
      }

      /**
       * AI의 승리 조건을 달성하기 위한 모든 잠재적 '계획'을 생성하고 점수를 매기는 함수
       * @returns {object | null} 가장 점수가 높은 최적의 계획 객체 또는 null
       */
      function generateAndScorePlans() {
        const aiHand = aiPlayer === "A" ? playerA_Hand : playerB_Hand;
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === aiPlayer
        );
        if (!myVictoryData) return null;

        const ultimateGoal = myVictoryData.core_goal; // 예: { subject: '소크라테스', predicate: '지혜롭다' }
        const goalSubject = ultimateGoal.subject;
        const goalPredicate = ultimateGoal.predicate;

        let potentialPlans = [];

        let middleTermText; // ★ 1. if문 밖에서 변수를 먼저 선언합니다.
        let middleTermAsPredicate;
        let subGoal1CardsNeeded;

        // 'A'가 될 수 있는 모든 중간 개념(개체, 서술어)을 탐색합니다.
        const allMiddleTermCards = fullDeck.filter(
          (c) =>
            c.type === currentLang.cardTypes[2] || // 개체 (새, 물고기, 개)
            c.type === currentLang.cardTypes[3] // 서술어 (선하다, 악하다 등)
        );

        for (const middleTermCard of allMiddleTermCards) {
          // A가 '새이다'와 같은 서술어 형태일 경우, A는 '새'가 됩니다.
          let middleTermAsPredicate;
          let subGoal1CardsNeeded;

          // ★★★ 핵심 수정: 중간 항의 타입('개체'/'서술어')에 따라 로직을 분기합니다.
          if (middleTermCard.type === currentLang.cardTypes[2]) {
            // 타입이 '개체'(새, 물고기, 개)인 경우
            middleTermText =
              currentLang.langCode === "ko"
                ? middleTermCard.text.replace(/는$/, "")
                : middleTermCard.text;
            middleTermAsPredicate =
              currentLang.langCode === "ko"
                ? `${middleTermText}이다`
                : `is a ${middleTermText}`;

            subGoal1CardsNeeded = [goalSubject, middleTermAsPredicate];
          } else {
            middleTermText = middleTermCard.text;
            middleTermAsPredicate = middleTermCard.text;
            subGoal1CardsNeeded = [goalSubject, middleTermCard.text];
            // 타입이 '서술어'(선하다, 지혜롭다, 승리한다)인 경우
            // '이다'를 붙이지 않고 서술어 카드의 텍스트를 그대로 사용합니다.
            middleTermAsPredicate = middleTermCard.text;

            subGoal1CardsNeeded = [goalSubject, middleTermCard.text];
          }

          // 계획 A: 삼단논법 (보편 적용)
          // 1. (나의 철학자)는 A이다.  (예: 소크라테스는 새이다)
          // 2. 모든 A는 (목표 서술어)이다. (예: 모든 새는 지혜롭다)
          const plan = {
            name: `UA_${middleTermText}`, // Plan Name: e.g., UA_bird
            subGoal1: {
              text: `${goalSubject} ${middleTermAsPredicate}`,
              proposition: parsePropositionFromString(
                `${goalSubject} ${middleTermAsPredicate}`
              ),
              isAchieved: false,
              cardsNeeded: subGoal1CardsNeeded,
            },
            subGoal2: {
              text: `${currentLang.keywords.universal_q} ${middleTermCard.text} ${goalPredicate}`,
              proposition: parsePropositionFromString(
                `${currentLang.keywords.universal_q} ${middleTermCard.text} ${goalPredicate}`
              ),
              isAchieved: false,
              cardsNeeded: [
                currentLang.keywords.universal_q,
                middleTermCard.text,
                goalPredicate,
              ],
            },
            score: 0,
          };

          // 각 하위 목표가 이미 달성되었는지 확인 (참 명제 목록에 있는지)
          plan.subGoal1.isAchieved = internalTruthSet.some((p) =>
            arePropositionsEqual(p, plan.subGoal1.proposition)
          );
          plan.subGoal2.isAchieved = internalTruthSet.some((p) =>
            arePropositionsEqual(p, plan.subGoal2.proposition)
          );

          // 계획 점수 계산
          let score = 0;
          if (plan.subGoal1.isAchieved) score += 5000;
          if (plan.subGoal2.isAchieved) score += 5000;

          // 계획 달성에 필요한 카드를 얼마나 가지고 있는지 확인
          const needed = [
            ...plan.subGoal1.cardsNeeded,
            ...plan.subGoal2.cardsNeeded,
          ];
          const has = aiHand.map((c) => c.text);
          let cardsOwned = 0;
          needed.forEach((cardText) => {
            if (has.includes(cardText)) {
              cardsOwned++;
              score += 1000; // 필요한 카드를 가지고 있으면 점수 추가
            }
          });

          // 실현 가능성이 있는 계획만 후보에 추가 (필요한 카드를 하나라도 가졌거나, 목표 하나가 이미 달성된 경우)
          if (
            cardsOwned > 0 ||
            plan.subGoal1.isAchieved ||
            plan.subGoal2.isAchieved
          ) {
            plan.score = score;
            potentialPlans.push(plan);
          }
        }

        if (potentialPlans.length === 0) return null;

        // 가장 점수가 높은 계획을 반환
        potentialPlans.sort((a, b) => b.score - a.score);
        return potentialPlans[0];
      }

      function aiTurn() {
        if (gameIsOver || isThinkingTime) return;

        if (aiTimeoutId) clearTimeout(aiTimeoutId);
        aiTimeoutId = setTimeout(aiTurn, 1500);

        const opponentPlayer = aiPlayer === "A" ? "B" : "A";
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === aiPlayer
        );
        const opponentVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponentPlayer
        );

        // 자기 패배로 이어지는 명제를 탐지하는 내부 헬퍼 함수
        const selfDefeatingProp = (() => {
          if (!myVictoryData) return null;
          const { predicate } = myVictoryData.core_goal;
          const contradictoryPredicate = Object.keys(
            currentLang.contradictoryPredicates
          ).find(
            (key) =>
              currentLang.contradictoryPredicates[key] === predicate ||
              key === predicate
          );

          if (contradictoryPredicate && contradictoryPredicate !== predicate) {
            const oppositePredicate =
              currentLang.contradictoryPredicates[predicate] ||
              Object.keys(currentLang.contradictoryPredicates).find(
                (key) => currentLang.contradictoryPredicates[key] === predicate
              );
            return {
              type: "atomic",
              subject: myVictoryData.core_goal.subject,
              predicate: oppositePredicate,
            };
          }
          return null;
        })();

        if (aiDeclareEureka()) {
          return;
        }

        // 우선순위 2: 장기적인 승리 계획을 세우고 실행
        const bestPlan = generateAndScorePlans();
        if (bestPlan && bestPlan.score > 1000) {
          // 일정 점수 이상인 '좋은 계획'이 있을 경우
          console.log(
            `AI STRATEGY: Executing plan '${bestPlan.name}' with score ${bestPlan.score}`
          );

          // 아직 달성되지 않은 하위 목표 중 하나를 선택
          let targetSubGoal = null;
          if (!bestPlan.subGoal1.isAchieved) targetSubGoal = bestPlan.subGoal1;
          else if (!bestPlan.subGoal2.isAchieved)
            targetSubGoal = bestPlan.subGoal2;

          if (targetSubGoal) {
            // 해당 목표를 만들기 위한 최적의 카드를 손에서 찾아서 냅니다.
            const aiHand = aiPlayer === "A" ? playerA_Hand : playerB_Hand;

            // 현재 명제판에 놓인 카드와 이어지는 카드를 우선적으로 찾습니다.
            const possibleMoves = aiHand.filter((card) =>
              isValidPlay(card, currentProposition)
            );

            for (const move of possibleMoves) {
              // 내야 할 카드가 계획의 일부라면 즉시 실행
              if (targetSubGoal.cardsNeeded.includes(move.text)) {
                console.log(
                  `AI ACTION: Playing card '${move.text}' to advance the plan.`
                );
                playCard(aiPlayer, move);
                setTimeout(endTurn, 500);
                return; // 계획을 실행했으므로 턴 종료
              }
            }
          }
        }

        // --- ▲▲▲▲▲ '계획 기반 행동' 로직 종료 ▲▲▲▲▲ ---

        // =======================================================================================
        // === 제안된 수정 - 시작: '추론 기반' 위협 탐지 및 무력화 우선순위 로직 ===
        // =======================================================================================

        const isBoardDangerous = () => {
          if (currentProposition.length === 0) return null;
          const parsedProp = parsePropositionFromCards(currentProposition);
          if (!parsedProp || !opponentVictoryData) return null;

          // 위협 유형 1: 상대의 핵심 승리 조건과 '직접 일치'하는 경우 (기존 로직)
          if (arePropositionsEqual(parsedProp, opponentVictoryData.core_goal)) {
            console.log("Threat Detected (Type 1: Direct Match)");
            return parsedProp;
          }

          // 위협 유형 2: 이 명제를 참으로 인정할 경우, 상대의 승리가 '추론 가능'해지는 경우
          // 이미 알려진 사실이면 중복 계산 방지
          const isAlreadyKnown = internalTruthSet.some((p) =>
            arePropositionsEqual(p, parsedProp)
          );
          if (isAlreadyKnown) return null;

          // "만약 이 명제가 참이 된다면?" 이라는 가상 시나리오 생성
          const simulatedTruths = [...internalTruthSet, parsedProp];

          // 이 시나리오에서 상대의 최종 승리 조건(ultimate_target)이 증명되는지 확인
          if (
            aiFindProof(opponentVictoryData.ultimate_target, simulatedTruths)
          ) {
            console.log("Threat Detected (Type 2: Inferred Defeat)");
            return parsedProp;
          }

          return null;
        };

        const dangerousParsedProp = isBoardDangerous();

        if (dangerousParsedProp) {
          console.log(
            "AI ALERT: Dangerous proposition detected! Activating neutralization priority.",
            propositionToText(dangerousParsedProp)
          );

          const aiHand = aiPlayer === "A" ? playerA_Hand : playerB_Hand;
          const { not, if: ifKeyword, or } = currentLang.keywords;
          const neutralizationOrder = [not, ifKeyword, or];

          for (const cardText of neutralizationOrder) {
            const cardToPlay = aiHand.find((c) => c.text === cardText);
            if (cardToPlay && isValidPlay(cardToPlay, currentProposition)) {
              console.log(
                `AI STRATEGY: Neutralizing with '${cardText}' card (Priority: ${
                  neutralizationOrder.indexOf(cardText) + 1
                }).`
              );
              playCard(aiPlayer, cardToPlay);
              setTimeout(endTurn, 500);
              return; // 우선순위 행동을 수행했으므로 AI 턴 즉시 종료
            }
          }

          console.log(
            "AI WARNING: Dangerous proposition on board, but no neutralization cards available. Falling back to default scoring."
          );
        }

        // =====================================================================================
        // === 제안된 수정 - 끝 ===
        // =====================================================================================

        const isBoardCompletable =
          currentProposition.length > 0 &&
          parsePropositionFromCards(currentProposition) !== null;
        if (isBoardCompletable && lastCardPlayer !== aiPlayer) {
          const parsedProp = parsePropositionFromCards(currentProposition);
          if (parsedProp) {
            const isDuplicate = internalTruthSet.some((p) =>
              arePropositionsEqual(p, parsedProp)
            );
            const isDirectContradiction = isContradictory(
              parsedProp,
              internalTruthSet
            );

            if (isDuplicate) {
              console.log(
                "AI VETO: Refusing to complete a duplicate proposition."
              );
            } else if (isDirectContradiction) {
              console.log(
                "AI VETO: Refusing to complete a proposition that is a direct contradiction."
              );
            } else if (
              opponentVictoryData &&
              arePropositionsEqual(parsedProp, opponentVictoryData.core_goal)
            ) {
              console.log(
                "AI VETO: Refusing to complete opponent's core goal."
              );
            } else if (
              selfDefeatingProp &&
              arePropositionsEqual(parsedProp, selfDefeatingProp)
            ) {
              console.log(
                "AI VETO: Refusing to complete a self-defeating proposition."
              );
            } else {
              const verificationResult = verifyAndExpandTruths(parsedProp);
              // aiTurn 함수 내, if (verificationResult.success) { ... } 부분을 아래 코드로 대체

              if (verificationResult.success) {
                const simulatedTruthSet = verificationResult.expandedSet;

                // --- 검사 우선순위 1: 나의 승리 목표를 직접적으로 방해하는가? (새로 추가된 핵심 로직) ---
                const myVictoryData = truePropositions.find(
                  (p) => p.type === "victory" && p.owner === aiPlayer
                );
                let myCoreGoalIsUndermined = false;
                if (myVictoryData) {
                  const myCoreGoal = myVictoryData.core_goal;
                  const contradictoryPredicateText =
                    currentLang.contradictoryPredicates[myCoreGoal.predicate] ||
                    Object.keys(currentLang.contradictoryPredicates).find(
                      (key) =>
                        currentLang.contradictoryPredicates[key] ===
                        myCoreGoal.predicate
                    );
                  if (contradictoryPredicateText) {
                    const antiGoalProposition = {
                      type: "atomic",
                      subject: myCoreGoal.subject,
                      predicate: contradictoryPredicateText,
                    };
                    if (aiFindProof(antiGoalProposition, simulatedTruthSet)) {
                      myCoreGoalIsUndermined = true;
                    }
                  }
                }

                // --- 검사 우선순위 2: 상대방의 승리로 이어지는가? (기존 로직) ---
                const opponentCanWin =
                  opponentVictoryData &&
                  aiFindProof(
                    opponentVictoryData.ultimate_target,
                    simulatedTruthSet
                  );

                // --- 최종 결정 ---
                if (myCoreGoalIsUndermined) {
                  console.log(
                    "AI VETO: Refusing to complete, it undermines my core victory condition."
                  );
                  // 명제를 완성하지 않고, 다른 카드를 내는 로직으로 넘어감
                } else if (opponentCanWin) {
                  console.log(
                    "AI VETO: Refusing to complete, it leads to opponent's victory."
                  );
                  // 명제를 완성하지 않고, 다른 카드를 내는 로직으로 넘어감
                } else {
                  // 모든 치명적인 위협이 없다고 판단될 때만 명제를 완성
                  console.log(
                    "AI Strategy: Completing opponent's proposition as it is safe."
                  );
                  completeProposition();
                  return; // 명제를 완성했으므로 AI 턴 종료
                }
              }
            }
          }
        }

        const aiHand = aiPlayer === "A" ? playerA_Hand : playerB_Hand;
        const validMoves = aiHand.filter((card) =>
          isValidPlay(card, currentProposition)
        );

        if (validMoves.length > 0) {
          // --- '전략적 점수 계산' 로직 시작 ---

          // 1. 현재 명제판이 AI에게 위협적인지 먼저 판단합니다.
          let isBoardThreatening = false;
          const currentParsedPropOnBoard =
            parsePropositionFromCards(currentProposition);
          if (currentParsedPropOnBoard) {
            if (myVictoryData) {
              const myCoreGoal = myVictoryData.core_goal;
              const contradictoryPredicateText =
                currentLang.contradictoryPredicates[myCoreGoal.predicate] ||
                Object.keys(currentLang.contradictoryPredicates).find(
                  (key) =>
                    currentLang.contradictoryPredicates[key] ===
                    myCoreGoal.predicate
                );
              if (contradictoryPredicateText) {
                const antiGoalProposition = {
                  type: "atomic",
                  subject: myCoreGoal.subject,
                  predicate: contradictoryPredicateText,
                };
                if (
                  aiFindProof(antiGoalProposition, [
                    ...internalTruthSet,
                    currentParsedPropOnBoard,
                  ])
                ) {
                  isBoardThreatening = true;
                }
              }
            }
          }

          const scoredMoves = validMoves.map((move) => {
            let score = 0;
            const { and, or, if: ifKeyword, not } = currentLang.keywords;

            // 2. 위협 상황일 경우, '전략적 대응' 점수를 부여합니다.
            if (isBoardThreatening) {
              console.log(
                `AI ALERT: Board is threatening. Applying strategic scores for move '${move.text}'.`
              );
              switch (move.text) {
                case not:
                  // 최우선 순위: 위협을 직접적으로 부정
                  score += 20000;
                  break;
                case ifKeyword:
                  // 차선책: 위협을 '가정'으로 만들어 한 단계 약화시킴 (A 라면 B)
                  score += 50000;
                  break;
                case or:
                  // 다음 선택: '또는'으로 연결하여 위협의 명확성을 희석시킴 (A 또는 B)
                  score += 5000;
                  break;
                case and:
                  // 최악의 수: 위험한 명제를 사실상 인정하는 행위
                  score -= 100000;
                  break;
                default:
                  // 기타 행동은 상황을 바꾸지 못하므로 감점
                  score -= 1000;
                  break;
              }
            }
            // 3. 위협 상황이 아닐 경우, '장기 계획' 또는 '일반' 점수를 계산합니다.
            else {
              // (여기에 이전 답변에서 제안한 generateAndScorePlans() 기반의 계획 실행 점수 로직이나
              //  기존에 사용하시던 간단한 일반 점수 계산 로직을 넣을 수 있습니다.)

              // 간단한 예시:
              if (move.type === currentLang.cardTypes[3]) score += 10; // 서술어에 기본 점수
              if (
                !parsePropositionFromCards([
                  ...currentProposition,
                  { card: move, player: aiPlayer },
                ])
              ) {
                score += 5; // 미완성 명제가 되면 약간의 점수
              }
            }

            return { move, score };
          });
          // --- '전략적 점수 계산' 로직 종료 ---

          scoredMoves.sort((a, b) => b.score - a.score);

          const bestScore = scoredMoves[0].score;
          const topMoves = scoredMoves.filter(
            (m) => m.score >= bestScore * 0.8 && m.score >= 0
          );

          let chosenMove;
          if (topMoves.length > 0) {
            chosenMove = topMoves[Math.floor(Math.random() * topMoves.length)];
          } else {
            chosenMove = scoredMoves[0];
          }

          console.log(
            `AI Strategy: Chose move '${chosenMove.move.text}' with score ${chosenMove.score}`
          );

          playCard(aiPlayer, chosenMove.move);
          setTimeout(endTurn, 500);
        } else {
          // =================================================================
          // ★★★★★ 버그 수정 지점 ★★★★★
          // =================================================================
          // AI가 손에 낼 수 있는 유효한 카드가 없을 때의 로직
          console.log("AI has no valid moves in hand.");
          const isBoardCompletableNow =
            currentProposition.length > 0 &&
            parsePropositionFromCards(currentProposition) !== null;

          // 보드를 완성시키는 것이 유일하게 가능한 행동이라면,
          // 이전의 모든 전략적 판단(Veto)과 관계없이 규칙에 따라 완성을 시도한다.
          // 이를 통해 게임이 멈추는 버그를 해결한다.
          if (isBoardCompletableNow && lastCardPlayer !== aiPlayer) {
            console.log(
              "AI Forced Decision: No other options available. Attempting to complete the proposition."
            );
            // completeProposition 함수 자체에 중복 및 모순 검사 기능이 내장되어 있으므로
            // AI는 규칙에 따라 일단 완성을 시도하고, 그 결과(패배 포함)를 받아들인다.
            completeProposition();
          } else {
            // 보드를 완성시킬 수도 없는, 완전히 행동이 불가능한 상태일 때
            console.log(
              "AI has no possible moves at all. Checking for round end."
            );
            checkRoundEndConditions();
          }
          // =================================================================
          // ★★★★★ 버그 수정 끝 ★★★★★
          // =================================================================
        }
      }

      function playCard(player, cardToPlay) {
        if (
          gameMode === "AI" &&
          player !== aiPlayer &&
          player !== playerCharacter
        )
          return;
        if (player !== currentPlayer || gameIsOver || isThinkingTime) return;

        if (cardsPlayedThisTurn[player] >= 1) {
          showAlert(currentLang.alerts.oneCardPerTurn);
          return;
        }

        if (!isValidPlay(cardToPlay, currentProposition)) {
          if (player !== aiPlayer) {
            showAlert(currentLang.alerts.invalidCard);
          }
          return;
        }
        if (currentProposition.length === 0) propositionStarter = player;
        const hand = player === "A" ? playerA_Hand : playerB_Hand;
        const cardIndex = hand.findIndex(
          (card) =>
            card.text === cardToPlay.text && card.type === cardToPlay.type
        );
        if (cardIndex === -1) return;
        currentProposition.push({
          card: hand.splice(cardIndex, 1)[0],
          player: player,
        });
        lastCardPlayer = player;
        cardsPlayedThisTurn[player]++;

        render();
      }

      function completeProposition() {
        if (currentProposition.length === 0 || gameIsOver || isThinkingTime)
          return false;

        const parsedProp = parsePropositionFromCards([...currentProposition]);
        if (!parsedProp) {
          if (currentPlayer !== aiPlayer) {
            showAlert(currentLang.alerts.incompleteProposition);
          }
          return false;
        }

        const isAxiom = parsedAxioms.some((a) =>
          arePropositionsEqual(a.proposition, parsedProp)
        );
        const isAlreadyProven = truePropositions.some(
          (p) =>
            p.proposition && arePropositionsEqual(p.proposition, parsedProp)
        );

        if (isAxiom || isAlreadyProven) {
          if (currentPlayer !== aiPlayer) {
            showAlert(currentLang.alerts.duplicateProposition);
          }
          return false;
        }

        const verificationResult = verifyAndExpandTruths(parsedProp);
        if (verificationResult.success) {
          internalTruthSet = verificationResult.expandedSet;
          truePropositions.push({
            type: "user-made",
            round: currentRound,
            proposition: parsedProp,
            original_cards: [...currentProposition],
          });
          lastPropositionMaker =
            currentProposition[currentProposition.length - 1].player;
          currentPlayer = lastPropositionMaker === "A" ? "B" : "A";
          currentProposition = [];
          lastCardPlayer = null;
          cardsPlayedThisTurn = { A: 0, B: 0 };
          render();
          const truePropositionsEl =
            document.getElementById("true-propositions");
          truePropositionsEl.scrollTop = truePropositionsEl.scrollHeight;
          checkNextTurn();
          return true;
        } else {
          if (currentPlayer !== aiPlayer) {
            showAlert(currentLang.alerts.contradictionFound);
          }
          return false;
        }
      }

      function undoProposition() {
        if (gameIsOver || isThinkingTime) return;
        if (gameMode === "AI" && currentPlayer === aiPlayer) return;

        if (currentProposition.length > 0) {
          const lastPlayedInfo = currentProposition.pop();
          if (gameMode === "AI" && lastPlayedInfo.player === aiPlayer) {
            currentProposition.push(lastPlayedInfo);
            return;
          }
          const hand =
            lastPlayedInfo.player === "A" ? playerA_Hand : playerB_Hand;
          hand.push(lastPlayedInfo.card);
          cardsPlayedThisTurn[lastPlayedInfo.player]--;
          currentPlayer = lastPlayedInfo.player;

          if (currentProposition.length > 0) {
            lastCardPlayer =
              currentProposition[currentProposition.length - 1].player;
          } else {
            lastCardPlayer = null;
          }

          render();
        } else {
          let lastUserMadePropIndex = -1;
          for (let i = truePropositions.length - 1; i >= 0; i--) {
            if (truePropositions[i].type === "user-made") {
              lastUserMadePropIndex = i;
              break;
            }
          }
          if (lastUserMadePropIndex !== -1) {
            const propToUndo = truePropositions[lastUserMadePropIndex];
            const lastMaker =
              propToUndo.original_cards[propToUndo.original_cards.length - 1]
                .player;
            if (gameMode === "AI" && lastMaker === aiPlayer) {
              showAlert(currentLang.alerts.nothingToUndo);
              return;
            }
            truePropositions.splice(lastUserMadePropIndex, 1);
            let newTruthSet = parsedAxioms.map((a) => a.proposition);
            const propositionsToReverify = truePropositions
              .filter(
                (p) =>
                  p.type === "victory" ||
                  p.type === "theorem" ||
                  p.type === "user-made"
              )
              .map((p) => p.proposition);
            for (const prop of propositionsToReverify) {
              internalTruthSet = JSON.parse(JSON.stringify(newTruthSet));
              const verificationResult = verifyAndExpandTruths(prop);
              if (verificationResult.success) {
                newTruthSet = verificationResult.expandedSet;
              } else {
                console.error(
                  "Critical error: Inconsistency found while rebuilding truth set after undo.",
                  prop
                );
                showAlert(currentLang.alerts.criticalErrorUndo);
                truePropositions.splice(lastUserMadePropIndex, 0, propToUndo);
                return;
              }
            }
            internalTruthSet = newTruthSet;
            currentProposition = propToUndo.original_cards;
            currentPlayer =
              currentProposition[currentProposition.length - 1].player;
            lastCardPlayer =
              currentProposition[currentProposition.length - 1].player;
            cardsPlayedThisTurn = { A: 0, B: 0 };
            showAlert(currentLang.alerts.undoLastProposition);
            render();
          } else {
            showAlert(currentLang.alerts.nothingToUndo);
          }
        }
      }

      function declareEureka(player) {
        if (gameIsOver) return;
        if (gameMode === "AI" && player === aiPlayer) return;
        if (!isThinkingTime && player !== currentPlayer) return;
        openEurekaModal();
      }

      function aiDeclareEureka() {
        if (isThinkingTime) return false;

        const opponentPlayer = aiPlayer === "A" ? "B" : "A";
        const myVictoryCondition = truePropositions.find(
          (p) => p.type === "victory" && p.owner === aiPlayer
        );
        const opponentVictoryCondition = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponentPlayer
        );

        if (!myVictoryCondition || !opponentVictoryCondition) return false;

        const myGoal = myVictoryCondition.ultimate_target;
        const opponentGoal = {
          type: "negation",
          proposition: opponentVictoryCondition.ultimate_target,
        };

        if (aiFindProof(myGoal)) {
          console.log("AI Eureka! Proved own victory.");
          showAlert(currentLang.alerts.aiEurekaDeclared, () =>
            endGame(aiPlayer)
          );
          return true;
        }

        if (aiFindProof(opponentGoal)) {
          console.log("AI Eureka! Proved opponent's defeat.");
          showAlert(currentLang.alerts.aiEurekaDeclared, () =>
            endGame(aiPlayer)
          );
          return true;
        }

        return false;
      }

      function aiFindProof(
        targetProposition,
        initialTruths = internalTruthSet
      ) {
        let knownTruths = [...initialTruths];
        let newTruthsFoundInIteration = true;
        let iterations = 0;
        const maxIterations = 15; // 무한 루프 방지

        while (newTruthsFoundInIteration && iterations < maxIterations) {
          newTruthsFoundInIteration = false;
          iterations++;

          const currentTruthsCount = knownTruths.length;
          let tempTruths = [...knownTruths];

          // 목표를 이미 달성했는지 확인
          if (
            tempTruths.some((p) => arePropositionsEqual(p, targetProposition))
          ) {
            return true;
          }

          // 1개 전제 규칙 적용
          for (const p of knownTruths) {
            const rules = [
              conjunctionElimination,
              doubleNegationElimination,
              existentialInstantiation,
            ];
            for (const rule of rules) {
              const result = rule(p);
              if (result) {
                const results = Array.isArray(result) ? result : [result];
                results.forEach((res) => {
                  if (!tempTruths.some((t) => arePropositionsEqual(t, res))) {
                    tempTruths.push(res);
                    newTruthsFoundInIteration = true;
                  }
                });
              }
            }
          }

          // 2개 전제 규칙 적용
          for (let i = 0; i < knownTruths.length; i++) {
            for (let j = 0; j < knownTruths.length; j++) {
              if (i === j) continue;
              const p1 = knownTruths[i];
              const p2 = knownTruths[j];
              const rules = [
                modusPonens,
                modusTollens,
                hypotheticalSyllogism,
                disjunctiveSyllogism,
                universalApplication,
              ];
              for (const rule of rules) {
                const result = rule(p1, p2);
                if (
                  result &&
                  !tempTruths.some((t) => arePropositionsEqual(t, result))
                ) {
                  tempTruths.push(result);
                  newTruthsFoundInIteration = true;
                }
              }
            }
          }

          // ★★★ 수정된 부분: 경우 논증 (Proof by Cases) 최적화 ★★★
          // 1. 모든 '또는' 명제와 '라면' 명제를 미리 분류하여 검색 범위를 줄입니다.
          const disjunctions = knownTruths.filter(
            (p) => p.type === "disjunction"
          );
          const conditionals = knownTruths.filter(
            (p) => p.type === "conditional"
          );

          // 2. '또는' 명제를 기준으로 탐색을 시작합니다.
          for (const disjunction of disjunctions) {
            // 예: (P ∨ Q)
            const p = disjunction.left;
            const q = disjunction.right;

            // 3. P로 시작하는 '라면' 명제들 (P → R)을 찾습니다.
            const pConditionals = conditionals.filter((c) =>
              arePropositionsEqual(c.left, p)
            );
            if (pConditionals.length === 0) continue; // 없으면 다음 '또는' 명제로 넘어감

            // 4. Q로 시작하는 '라면' 명제들 (Q → R)을 찾습니다.
            const qConditionals = conditionals.filter((c) =>
              arePropositionsEqual(c.left, q)
            );
            if (qConditionals.length === 0) continue; // 없으면 다음 '또는' 명제로 넘어감

            // 5. 찾아낸 두 '라면' 명제 그룹을 비교하여 결론(R)이 같은 쌍을 찾습니다.
            for (const pCond of pConditionals) {
              for (const qCond of qConditionals) {
                // 결론(pCond.right와 qCond.right)이 동일한지 확인
                if (arePropositionsEqual(pCond.right, qCond.right)) {
                  const result = pCond.right; // 최종 결론 R
                  // 새로운 결론이라면 참 목록에 추가
                  if (
                    result &&
                    !tempTruths.some((t) => arePropositionsEqual(t, result))
                  ) {
                    tempTruths.push(result);
                    newTruthsFoundInIteration = true;
                  }
                }
              }
            }
          }

          knownTruths = tempTruths;
        }

        // 최종적으로 목표가 달성되었는지 확인
        return knownTruths.some((p) =>
          arePropositionsEqual(p, targetProposition)
        );
      }

      function endGame(winner, winningProposition) {
        gameIsOver = true;
        document.getElementById("eureka-modal").classList.remove("visible");
        const statusEl = document.getElementById("status");
        const winnerName =
          winner === "A"
            ? currentLang.ui.playerAName
            : currentLang.ui.playerBName;
        const victoryText = `${winnerName} ${currentLang.ui.victoryMessage}<br>${currentLang.ui.victorySubMessage}`;
        statusEl.innerHTML = `<span class="turn-indicator">${victoryText}</span>`;
        render();

        // 1. 모든 오버레이 이미지를 일단 숨깁니다.
        document.querySelectorAll(".overlay-image").forEach((img) => {
          img.classList.add("hidden");
        });

        // 2. ★★★ 수정된 핵심 로직 ★★★
        //    승리한 철학자의 '승리' 오버레이를 논리 증명과 관계없이 즉시 표시합니다.
        const winnerOverlayId =
          winner === "A" ? "socrates-win-overlay" : "plato-win-overlay";
        const winnerOverlay = document.getElementById(winnerOverlayId);
        if (winnerOverlay) {
          winnerOverlay.classList.remove("hidden");
          // z-index를 다른 승리 이미지보다 높게 설정하여 항상 위에 오도록 보장합니다.
          // (CSS에서 이미 z-index: 3으로 설정했으므로 이 줄은 선택적입니다.)
          winnerOverlay.style.zIndex = "5";
        }

        // 3. '승리'를 제외한 나머지 상태 오버레이들은 기존처럼 논리적 참/거짓에 따라 표시합니다.
        const characters = [
          currentLang.keywords.socrates,
          currentLang.keywords.plato,
        ];
        const predicates = [
          ...currentLang.cards
            .filter(
              (card) =>
                card.type === currentLang.cardTypes[3] ||
                card.type === "Predicate"
            )
            // ★★★ '승리한다' 서술어는 위에서 수동으로 처리했으므로, 반복문에서 제외합니다.
            .filter(
              (card) =>
                card.text !== currentLang.keywords.wins &&
                card.text !== "승리한다"
            )
            .map((card) => card.text),
        ];

        characters.forEach((subjectText) => {
          predicates.forEach((predicateText) => {
            const targetProposition = {
              type: "atomic",
              subject: subjectText,
              predicate: predicateText,
            };

            if (aiFindProof(targetProposition, internalTruthSet)) {
              const subjectId =
                subjectText === currentLang.keywords.socrates
                  ? "socrates"
                  : "plato";
              const predicateMap = {
                선하다: "good",
                "is good": "good",
                악하다: "evil",
                "is evil": "evil",
                지혜롭다: "wise",
                "is wise": "wise",
                어리석다: "foolish",
                "is foolish": "foolish",
                새이다: "bird",
                "is a bird": "bird",
                물고기이다: "fish",
                "is a fish": "fish",
                개이다: "dog",
                "is a dog": "dog",
              };
              const predicateId = predicateMap[predicateText];

              if (predicateId) {
                const overlayId = `${subjectId}-${predicateId}-overlay`;
                const overlayToShow = document.getElementById(overlayId);
                if (overlayToShow) {
                  overlayToShow.classList.remove("hidden");
                }
              }
            }
          });
        });

        const gameOverModal = document.getElementById("game-over-modal");
        gameOverModal.style.display = "flex";
      }
      function checkRoundEndConditions() {
        if (
          gameIsOver ||
          isThinkingTime ||
          cardsPlayedThisTurn[currentPlayer] > 0
        )
          return;

        const hand = currentPlayer === "A" ? playerA_Hand : playerB_Hand;
        const hasValidCardMove = hand.some((card) =>
          isValidPlay(card, currentProposition)
        );

        let canComplete = false;
        if (currentProposition.length > 0 && lastCardPlayer !== currentPlayer) {
          const parsedProp = parsePropositionFromCards(currentProposition);
          if (parsedProp) {
            const verificationResult = verifyAndExpandTruths(parsedProp);
            if (verificationResult.success) {
              canComplete = true;
            }
          }
        }

        if (!hasValidCardMove && !canComplete) {
          const playerName =
            currentPlayer === "A"
              ? currentLang.ui.playerAName
              : currentLang.ui.playerBName;
          showAlert(
            currentLang.alerts.roundEndNoMoves.replace("{player}", playerName)
          );
          startThinkingTime();
        }
      }

      function startThinkingTime() {
        currentProposition = [];
        lastCardPlayer = null;
        isThinkingTime = true;
        cardsPlayedThisTurn = { A: 0, B: 0 };
        document.getElementById("thinking-time-controls").style.display =
          "block";
        render();
      }

      function endThinkingTime() {
        isThinkingTime = false;
        document.getElementById("thinking-time-controls").style.display =
          "none";
        currentRound++;
        const nonPlayerCards = [currentLang.keywords.wins];
        playerA_Hand = JSON.parse(
          JSON.stringify(
            fullDeck.filter((c) => !nonPlayerCards.includes(c.text))
          )
        );
        playerB_Hand = JSON.parse(
          JSON.stringify(
            fullDeck.filter((c) => !nonPlayerCards.includes(c.text))
          )
        );
        currentPlayer = currentRound % 2 === 1 ? "A" : "B";
        render();
        checkNextTurn();
      }

      function openEurekaModal() {
        derivedPropositionsInModal = [];
        currentAssumption = null;
        const modal = document.getElementById("eureka-modal");
        const premiseList = document.getElementById("premise-list");
        premiseList.innerHTML = "";
        const allSelectablePropositions = [
          ...parsedAxioms,
          ...truePropositions
            .map((p) => ({ ...p, proposition: p.proposition }))
            .filter((p) => p.proposition),
        ];
        allSelectablePropositions.forEach((propData) => {
          let label;
          switch (propData.type) {
            case "axiom":
              label = currentLang.labels.axiom;
              break;
            case "victory":
              label = currentLang.labels.victory_condition;
              break;
            case "theorem":
              label = currentLang.labels.theorem;
              break;
            default:
              label = currentLang.labels.proposition;
          }
          addPremiseToWorkbench({
            proposition: propData.proposition,
            type: propData.type,
            dependsOnAssumption: false,
            isAssumption: false,
            label: label,
          });
        });
        const modalTitle = document.getElementById("eureka-title");
        const confirmBtn = document.getElementById("modal-confirm-btn");
        if (isThinkingTime) {
          modalTitle.textContent = currentLang.modals.eurekaTitleTheorem;
          confirmBtn.textContent = currentLang.modals.confirmTheoremButton;
          confirmBtn.onclick = addTheoremsToList;
        } else {
          modalTitle.textContent = currentLang.modals.eurekaTitleVictory;
          confirmBtn.textContent = currentLang.modals.confirmVictoryButton;
          confirmBtn.onclick = proveVictory;
        }
        renderModal();
        modal.classList.add("visible");
      }

      function addAssumption() {
        if (currentAssumption) {
          showAlert(currentLang.alerts.oneAssumptionOnly);
          return;
        }
        showPrompt(
          currentLang.modals.promptInputPlaceholder,
          (propositionText) => {
            if (propositionText) {
              const parsedProp = parsePropositionFromString(propositionText);
              if (parsedProp) {
                currentAssumption = parsedProp;
                addPremiseToWorkbench({
                  proposition: parsedProp,
                  type: "assumption",
                  dependsOnAssumption: true,
                  isAssumption: true,
                  label: currentLang.labels.assumption,
                });
                renderModal();
              } else {
                showAlert(currentLang.alerts.parsingFailed);
              }
            }
          }
        );
      }

      function cancelAssumption() {
        currentAssumption = null;
        derivedPropositionsInModal = derivedPropositionsInModal.filter(
          (p) => !p.dependsOnAssumption
        );
        renderModal();
      }

      function addPremiseToWorkbench(propObject) {
        const isDuplicate = derivedPropositionsInModal.some((p) =>
          arePropositionsEqual(p.proposition, propObject.proposition)
        );
        if (isDuplicate) return;
        derivedPropositionsInModal.push(propObject);
      }

      function applyRule() {
        const selectedLis = Array.from(
          document.querySelectorAll(
            '#premise-list input[type="checkbox"]:checked'
          )
        );
        const rule = document.getElementById("inference-rule-select").value;
        const premisesData = selectedLis.map((chk) =>
          JSON.parse(chk.parentElement.dataset.propObject)
        );
        const premises = premisesData.map((data) => data.proposition);
        let conclusions = [];
        const onePremiseRules = [
          "conjunctionElimination",
          "doubleNegationElimination",
          "conditionalIntroduction",
          "existentialInstantiation",
        ];
        const twoPremiseRules = [
          "modusPonens",
          "modusTollens",
          "hypotheticalSyllogism",
          "disjunctiveSyllogism",
          "universalApplication",
        ];
        const threePremiseRules = ["proofByCases"];
        if (rule === "conditionalIntroduction") {
          if (premises.length !== 1) {
            showAlert(currentLang.alerts.premiseNeededForIntro);
            return;
          }
          if (!currentAssumption) {
            showAlert(currentLang.alerts.assumptionNeededForIntro);
            return;
          }
          const conclusionData = premisesData[0];
          if (!conclusionData.dependsOnAssumption) {
            showAlert(currentLang.alerts.premiseNotFromAssumption);
            return;
          }
          const newConditional = {
            type: "conditional",
            left: currentAssumption,
            right: conclusionData.proposition,
          };
          derivedPropositionsInModal = derivedPropositionsInModal.filter(
            (p) => !p.dependsOnAssumption
          );
          currentAssumption = null;
          addPremiseToWorkbench({
            proposition: newConditional,
            type: "theorem",
            dependsOnAssumption: false,
            isAssumption: false,
            label: currentLang.labels.ci_theorem,
          });
        } else if (rule === "reductioAdAbsurdum") {
          if (premises.length !== 2) {
            showAlert(currentLang.alerts.contradictionNeededForRAA);
            return;
          }
          if (!currentAssumption) {
            showAlert(currentLang.alerts.assumptionNeededForRAA);
            return;
          }
          const result = reductioAdAbsurdum(
            premises[0],
            premises[1],
            currentAssumption
          );
          if (result) {
            derivedPropositionsInModal = derivedPropositionsInModal.filter(
              (p) => !p.dependsOnAssumption
            );
            currentAssumption = null;
            addPremiseToWorkbench({
              proposition: result,
              type: "theorem",
              dependsOnAssumption: false,
              isAssumption: false,
              label: currentLang.labels.raa_theorem,
            });
          } else {
            showAlert(currentLang.alerts.notAContradiction);
          }
        } else if (threePremiseRules.includes(rule)) {
          if (premises.length !== 3) {
            showAlert(
              currentLang.alerts.premiseCountError.replace("{count}", 3)
            );
            return;
          }
          const result = window[rule](premises[0], premises[1], premises[2]);
          if (result) conclusions.push(result);
        } else if (twoPremiseRules.includes(rule)) {
          if (premises.length !== 2) {
            showAlert(
              currentLang.alerts.premiseCountError.replace("{count}", 2)
            );
            return;
          }
          const result = window[rule](premises[0], premises[1]);
          if (result) conclusions.push(result);
        } else if (onePremiseRules.includes(rule)) {
          if (premises.length !== 1) {
            showAlert(
              currentLang.alerts.premiseCountError.replace("{count}", 1)
            );
            return;
          }
          const result = window[rule](premises[0]);
          if (result) {
            if (Array.isArray(result)) conclusions.push(...result);
            else conclusions.push(result);
          }
        }
        if (conclusions.length > 0 && conclusions[0] != null) {
          const isDependent = premisesData.some((p) => p.dependsOnAssumption);
          conclusions.forEach((conc) => {
            addPremiseToWorkbench({
              proposition: conc,
              type: "theorem",
              dependsOnAssumption: isDependent,
              isAssumption: false,
              label: currentLang.labels.theorem,
            });
          });
        } else if (
          rule !== "reductioAdAbsurdum" &&
          rule !== "conditionalIntroduction" &&
          conclusions.length === 0
        ) {
          showAlert(currentLang.alerts.ruleFailed);
        }
        renderModal();
      }

      function addTheoremsToList() {
        const selectedLis = Array.from(
          document.querySelectorAll(
            '#premise-list input[type="checkbox"]:checked'
          )
        );
        if (selectedLis.length === 0) {
          showAlert(currentLang.alerts.noTheoremsToAdd);
          return;
        }

        const selectedPropsData = selectedLis.map((chk) =>
          JSON.parse(chk.parentElement.dataset.propObject)
        );

        let potentialTheorems = selectedPropsData.filter(
          (p) => p.type === "theorem" && !p.dependsOnAssumption
        );

        const trulyNewTheorems = potentialTheorems.filter((theoremData) => {
          const isAxiom = parsedAxioms.some((a) =>
            arePropositionsEqual(a.proposition, theoremData.proposition)
          );
          const isAlreadyProven = truePropositions.some(
            (p) =>
              p.proposition &&
              arePropositionsEqual(p.proposition, theoremData.proposition)
          );
          return !isAxiom && !isAlreadyProven;
        });

        if (trulyNewTheorems.length === 0) {
          showAlert(currentLang.alerts.duplicateProposition);
          return;
        }

        let theoremsAdded = 0;
        for (const theoremData of trulyNewTheorems) {
          const verificationResult = verifyAndExpandTruths(
            theoremData.proposition
          );

          if (verificationResult.success) {
            truePropositions.push({
              type: "theorem",
              round: currentRound,
              proposition: theoremData.proposition,
            });
            internalTruthSet = verificationResult.expandedSet;
            theoremsAdded++;
          } else {
            console.error(
              "Contradiction detected while adding a new theorem.",
              theoremData.proposition
            );
            showAlert(currentLang.alerts.contradictionFound);
            break;
          }
        }

        if (theoremsAdded > 0) {
          document.getElementById("eureka-modal").classList.remove("visible");
          render();
        }
      }

      function proveVictory() {
        if (isThinkingTime) return;

        // 현재 플레이어의 승리 목표와 상대의 패배 목표를 정의합니다.
        const myVictoryCondition = truePropositions.find(
          (p) => p.type === "victory" && p.owner === currentPlayer
        );
        if (!myVictoryCondition) return;
        const myUltimateTarget = myVictoryCondition.ultimate_target;

        const opponentPlayer = currentPlayer === "A" ? "B" : "A";
        const opponentVictoryCondition = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponentPlayer
        );
        if (!opponentVictoryCondition) return;
        const opponentLossCondition = {
          type: "negation",
          proposition: opponentVictoryCondition.ultimate_target,
        };

        // 모달창 안에서 승리 또는 상대 패배가 증명되었는지 확인합니다.
        const isMyVictoryProven = derivedPropositionsInModal.some(
          (p) =>
            !p.dependsOnAssumption &&
            arePropositionsEqual(p.proposition, myUltimateTarget)
        );
        const isOpponentLossProven = derivedPropositionsInModal.some(
          (p) =>
            !p.dependsOnAssumption &&
            arePropositionsEqual(p.proposition, opponentLossCondition)
        );

        if (isMyVictoryProven || isOpponentLossProven) {
          // ★★★★★ 버그 수정 시작 ★★★★★
          // 게임을 종료하기 전에, 모달에서 파생된 모든 새로운 정리(theorem)들을
          // 게임의 전체 참 목록(internalTruthSet)에 먼저 업데이트합니다.

          const newTheorems = derivedPropositionsInModal.filter(
            (p) =>
              p.type === "theorem" &&
              !p.dependsOnAssumption &&
              !truePropositions.some((existing) =>
                arePropositionsEqual(p.proposition, existing.proposition)
              )
          );

          for (const theoremData of newTheorems) {
            // 각 정리가 기존 진리 체계와 모순되지 않는지 최종 검증합니다.
            const verificationResult = verifyAndExpandTruths(
              theoremData.proposition
            );
            if (verificationResult.success) {
              // ★★★ 핵심 수정 사항 ★★★
              // 화면 목록(truePropositions)에는 추가하지 않고,
              // 내부 논리 집합(internalTruthSet)만 업데이트합니다.
              // 이렇게 하면 게임 종료 화면의 논리 연산에는 영향을 주지만
              // 메인 화면 목록에는 표시되지 않습니다.
              internalTruthSet = verificationResult.expandedSet;
            } else {
              // 논리적으로 발생하기 어렵지만, 만약의 경우를 대비한 에러 처리
              console.error(
                "치명적 오류: 승리 증명에 사용된 정리가 기존 사실과 모순됩니다.",
                theoremData
              );
              showAlert(currentLang.alerts.criticalErrorUndo);
              return;
            }
          }
          // ★★★★★ 버그 수정 끝 ★★★★★

          // 이제 모든 사실이 업데이트된 상태에서 게임을 종료합니다.
          endGame(currentPlayer);
          return;
        }

        // 승리가 증명되지 않았을 경우, 안내 메시지를 표시합니다.
        showAlert(
          currentLang.alerts.proofIncomplete
            .replace("{myGoal}", propositionToText(myUltimateTarget))
            .replace("{opponentGoal}", propositionToText(opponentLossCondition))
        );
      }

      function render() {
        document.getElementById("round-display").textContent =
          currentLang.ui.roundDisplay.replace("{round}", currentRound);
        const handA_El = document.getElementById("player-a-hand"),
          handB_El = document.getElementById("player-b-hand");
        handA_El.innerHTML = "";
        handB_El.innerHTML = "";
        playerA_Hand.sort(
          (a, b) =>
            cardTypeOrder.indexOf(a.type) - cardTypeOrder.indexOf(b.type)
        );
        playerB_Hand.sort(
          (a, b) =>
            cardTypeOrder.indexOf(a.type) - cardTypeOrder.indexOf(b.type)
        );
        let lastTypeA = null;
        playerA_Hand.forEach((card) => {
          if (card.type !== lastTypeA) {
            if (lastTypeA !== null) {
              const br = document.createElement("div");
              br.style.flexBasis = "100%";
              br.style.height = "0";
              handA_El.appendChild(br);
            }
            lastTypeA = card.type;
          }
          const cardEl = document.createElement("div");
          cardEl.className = "card card-white";
          cardEl.textContent = card.text;
          if (gameMode === "AI" && aiPlayer === "A") {
            cardEl.classList.add("ai-hand");
          } else {
            cardEl.addEventListener("click", () => {
              if (!inTutorialMode) playCard("A", card);
            });
          }
          handA_El.appendChild(cardEl);
        });
        let lastTypeB = null;
        playerB_Hand.forEach((card) => {
          if (card.type !== lastTypeB) {
            if (lastTypeB !== null) {
              const br = document.createElement("div");
              br.style.flexBasis = "100%";
              br.style.height = "0";
              handB_El.appendChild(br);
            }
            lastTypeB = card.type;
          }
          const cardEl = document.createElement("div");
          cardEl.className = "card card-black";
          cardEl.textContent = card.text;
          if (gameMode === "AI" && aiPlayer === "B") {
            cardEl.classList.add("ai-hand");
          } else {
            cardEl.addEventListener("click", () => {
              if (!inTutorialMode) playCard("B", card);
            });
          }
          handB_El.appendChild(cardEl);
        });
        const propositionEl = document.getElementById("proposition-display");
        propositionEl.innerHTML = "";
        currentProposition.forEach((info) => {
          const cardEl = document.createElement("div");
          const colorClass = info.player === "A" ? "card-white" : "card-black";
          cardEl.className = `card ${colorClass}`;
          cardEl.textContent = info.card.text;
          propositionEl.appendChild(cardEl);
        });
        const trueList_El = document.getElementById("true-list");
        trueList_El.innerHTML = "";
        const liAxiom = document.createElement("li");
        liAxiom.className = "axiom-wrapper";
        const details = document.createElement("details");
        const summary = document.createElement("summary");
        summary.textContent = currentLang.ui.axiomTitle;
        details.appendChild(summary);
        const axiomContainer = document.createElement("div");
        axiomContainer.className = "axiom-list";

        currentAxioms.forEach((axiomText) => {
          const p = document.createElement("p");
          p.textContent = `• ${axiomText}`;
          axiomContainer.appendChild(p);
        });

        details.appendChild(axiomContainer);
        liAxiom.appendChild(details);
        trueList_El.appendChild(liAxiom);

        truePropositions.forEach((propData) => {
          const li = document.createElement("li");

          if (propData.type === "victory") {
            li.classList.add("victory-condition");
            const ownerName =
              propData.owner === "A"
                ? playerA_Data.name[currentLang.langCode]
                : playerB_Data.name[currentLang.langCode];
            const ownerPrefix =
              propData.owner === "A" ? `⚪️ ${ownerName}` : `⚫️ ${ownerName}`;
            li.innerHTML = currentLang.labels.victory_text
              .replace("{owner}", ownerPrefix)
              .replace("{text}", propData.text);
          } else if (propData.type === "user-made") {
            if (propData.original_cards && propData.original_cards.length > 0) {
              propData.original_cards.forEach((info) => {
                const wordSpan = document.createElement("span");
                wordSpan.textContent = info.card.text + " ";
                wordSpan.className = info.player === "A" ? "word-a" : "word-b";
                li.appendChild(wordSpan);
              });
            } else if (propData.proposition) {
              li.textContent = propositionToNaturalText(propData.proposition);
            }
          } else if (propData.type === "theorem") {
            li.classList.add("theorem");
            li.textContent = currentLang.labels.theorem_source
              .replace("{text}", propositionToNaturalText(propData.proposition))
              .replace("{round}", propData.round);
          }
          trueList_El.appendChild(li);
        });

        const statusEl = document.getElementById("status");
        const mainCenter = document.querySelector(".main-center-bg");

        if (mainCenter && !mainCenter.classList.contains("hidden")) {
          statusEl.innerHTML = "";
        } else {
          const playerAreaA = document.getElementById("player-a-area"),
            playerAreaB = document.getElementById("player-b-area");
          const eurekaBtnA = document.getElementById("eureka-a"),
            eurekaBtnB = document.getElementById("eureka-b");
          const completeBtn = document.getElementById("complete-btn"),
            undoBtn = document.getElementById("undo-btn"),
            endTurnBtn = document.getElementById("end-turn-btn");

          let winnerName = "";
          if (gameIsOver) {
            winnerName =
              currentPlayer === "A" && playerA_Data
                ? playerA_Data.name[currentLang.langCode]
                : playerB_Data
                ? playerB_Data.name[currentLang.langCode]
                : "";
          }

          if (gameIsOver) {
            statusEl.innerHTML = `<span class="turn-indicator">${winnerName} ${currentLang.ui.victoryMessage}<br>${currentLang.ui.victorySubMessage}</span>`;
            statusEl.style.color = "#c0392b";
            playerAreaA.classList.add("disabled");
            playerAreaB.classList.add("disabled");
            eurekaBtnA.disabled = true;
            eurekaBtnB.disabled = true;
            completeBtn.disabled = true;
            undoBtn.disabled = true;
            endTurnBtn.disabled = true;
          } else if (isThinkingTime) {
            statusEl.innerHTML = `<span class="turn-indicator">${currentLang.ui.thinkingTimeStatus}</span>`;
            playerAreaA.classList.remove("disabled");
            playerAreaB.classList.remove("disabled");
            eurekaBtnA.disabled = gameMode === "AI" && aiPlayer === "A";
            eurekaBtnB.disabled = gameMode === "AI" && aiPlayer === "B";
            eurekaBtnA.textContent = currentLang.ui.addTheoremButton;
            eurekaBtnB.textContent = currentLang.ui.addTheoremButton;
            completeBtn.disabled = true;
            undoBtn.disabled = true;
            endTurnBtn.disabled = true;
          } else {
            statusEl.style.color = "#333";
            eurekaBtnA.textContent = currentLang.ui.eurekaButton;
            eurekaBtnB.textContent = currentLang.ui.eurekaButton;
            const isAITurn = gameMode === "AI" && currentPlayer === aiPlayer;
            const isCompletable =
              currentProposition.length > 0 &&
              parsePropositionFromCards(currentProposition) !== null;

            if (isAITurn) {
              statusEl.innerHTML = `<span class="turn-indicator">${currentLang.ui.statusAITurn}</span>`;
              playerAreaA.classList.add("disabled");
              playerAreaB.classList.add("disabled");
              eurekaBtnA.disabled = true;
              eurekaBtnB.disabled = true;
              completeBtn.disabled = true;
              undoBtn.disabled = true;
              endTurnBtn.disabled = true;
            } else {
              if (currentPlayer === "A") {
                const playerAName = playerA_Data
                  ? playerA_Data.name[currentLang.langCode]
                  : currentLang.ui.playerAName;
                statusEl.innerHTML = `<span class="turn-indicator">⚪️ ${playerAName} ${currentLang.ui.statusTurn}</span>`;
                playerAreaA.classList.remove("disabled");
                playerAreaB.classList.add("disabled");
                eurekaBtnA.disabled = false;
                eurekaBtnB.disabled = true;
              } else {
                const playerBName = playerB_Data
                  ? playerB_Data.name[currentLang.langCode]
                  : currentLang.ui.playerBName;
                statusEl.innerHTML = `<span class="turn-indicator">⚫️ ${playerBName} ${currentLang.ui.statusTurn}</span>`;
                playerAreaB.classList.remove("disabled");
                playerAreaA.classList.add("disabled");
                eurekaBtnA.disabled = true;
                eurekaBtnB.disabled = false;
              }
              completeBtn.disabled =
                !isCompletable || lastCardPlayer === currentPlayer;
              undoBtn.disabled = cardsPlayedThisTurn[currentPlayer] === 0;
              endTurnBtn.disabled = cardsPlayedThisTurn[currentPlayer] === 0;
            }
          }
        }
      }

      function setupTutorialScenario(step) {
        if (step === 1) {
          playerA_Hand = [];
          playerB_Hand = [];
          truePropositions = [];

          const socratesSubject = currentLang.keywords.socrates;
          const platoSubject = currentLang.keywords.plato;
          currentAxioms = generateAxioms(
            socratesSubject,
            platoSubject,
            currentLang
          );

          parsedAxioms = currentAxioms
            .map((str) => ({
              type: "axiom",
              proposition: parsePropositionFromString(str),
            }))
            .filter((a) => a.proposition);

          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentProposition = [];
          currentPlayer = "A";
          propositionStarter = "A";
          gameIsOver = false;
          currentRound = 1;
          isThinkingTime = false;
          lastPropositionMaker = null;
          currentAssumption = null;
          lastCardPlayer = null;
          cardsPlayedThisTurn = { A: 0, B: 0 };
          gameMode = "2P";

          // 튜토리얼을 위한 기본 철학자 데이터 설정
          playerA_Data = PHILOSOPHERS["socrates"];
          playerB_Data = PHILOSOPHERS["plato"];

          const socratesCardText = currentLang.keywords.socrates;
          const requiredA_CardTexts = [
            socratesCardText,
            currentLang.keywords.and,
            currentLang.keywords.or,
            currentLang.keywords.if,
            currentLang.keywords.not,
            currentLang.langCode === "ko" ? "개는" : "dog",
            currentLang.langCode === "ko" ? "새는" : "bird",
            currentLang.langCode === "ko" ? "물고기는" : "fish",
            currentLang.keywords.universal_q,
            currentLang.keywords.existential_q,
          ];
          playerA_Hand = fullDeck.filter((c) =>
            requiredA_CardTexts.includes(c.text)
          );

          const wiseCardText =
            currentLang.langCode === "ko" ? "지혜롭다" : "is wise";
          const requiredB_CardTexts = [
            wiseCardText,
            currentLang.keywords.plato,
          ];
          playerB_Hand = fullDeck.filter((c) =>
            requiredB_CardTexts.includes(c.text)
          );
          playerB_Hand.push(
            ...fullDeck
              .filter(
                (c) =>
                  !requiredB_CardTexts.includes(c.text) &&
                  c.type ===
                    (currentLang.langCode === "ko" ? "서술어" : "Predicate")
              )
              .slice(0, 2)
          );
        } else if (step === 2) {
          const socratesCardInfo = currentProposition.find(
            (info) => info.card.text === currentLang.keywords.socrates
          );
          const wiseCardText =
            currentLang.langCode === "ko" ? "지혜롭다" : "is wise";
          const wiseCardIndex = playerB_Hand.findIndex(
            (c) => c.text === wiseCardText
          );

          if (socratesCardInfo && wiseCardIndex > -1) {
            const [wiseCard] = playerB_Hand.splice(wiseCardIndex, 1);
            currentProposition = [
              socratesCardInfo,
              { card: wiseCard, player: "B" },
            ];
            lastCardPlayer = "B";
            currentPlayer = "A";
          }
        } else if (step === 4) {
          currentProposition = [];
          playerA_Hand = fullDeck.filter(
            (c) =>
              c.type ===
                (currentLang.langCode === "ko" ? "연산자" : "Operator") &&
              c.text !== currentLang.keywords.not
          );
          playerB_Hand = fullDeck.filter(
            (c) =>
              c.type ===
                (currentLang.langCode === "ko" ? "서술어" : "Predicate") &&
              c.text !== (currentLang.langCode === "ko" ? "개이다" : "is a dog")
          );

          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);

          const premises = [
            currentLang.langCode === "ko"
              ? "소크라테스는 개이다"
              : "Socrates is a dog",
            currentLang.langCode === "ko"
              ? "모든 개는 지혜롭다"
              : "Every dog is wise",
          ];
          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (parsed) {
              truePropositions.push({
                type: "user-made",
                text: pText,
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
          startThinkingTime();
        } else if (step === 5) {
          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentPlayer = "A";
          isThinkingTime = false;
          document.getElementById("thinking-time-controls").style.display =
            "none";

          const premises = [
            currentLang.langCode === "ko"
              ? "소크라테스는 선하다"
              : "Socrates is good",
            currentLang.langCode === "ko"
              ? "(소크라테스는 선하다) 라면 (소크라테스는 승리한다)"
              : "(Socrates is good) then (Socrates wins)",
            currentLang.langCode === "ko"
              ? "플라톤은 지혜롭다 는 거짓이다"
              : "Plato is wise is false",
            currentLang.langCode === "ko"
              ? "(플라톤은 승리한다) 라면 (플라톤은 지혜롭다)"
              : "(Plato wins) then (Plato is wise)",
            currentLang.langCode === "ko"
              ? "(어떤 새는 물고기이다) 또는 (어떤 새는 새이다)"
              : "(Some bird is a fish) or (Some bird is a bird)",
            currentLang.langCode === "ko"
              ? "어떤 새는 물고기이다 는 거짓이다"
              : "Some bird is a fish is false",
            currentLang.langCode === "ko"
              ? "(플라톤은 개이다) 라면 (플라톤은 선하다)"
              : "(Plato is a dog) then (Plato is good)",
            currentLang.langCode === "ko"
              ? "(플라톤은 선하다) 라면 (플라톤은 승리한다)"
              : "(Plato is good) then (Plato wins)",
            currentLang.langCode === "ko"
              ? "(소크라테스는 지혜롭다) 그리고 (플라톤은 어리석다)"
              : "(Socrates is wise) and (Plato is foolish)",
            currentLang.langCode === "ko"
              ? "어떤 물고기는 선하다 는 거짓이다 는 거짓이다"
              : "Some fish is good is false is false",
            currentLang.langCode === "ko"
              ? "모든 새는 선하다"
              : "Every bird is good",
            currentLang.langCode === "ko"
              ? "플라톤은 새이다"
              : "Plato is a bird",
            currentLang.langCode === "ko"
              ? "모든 개는 선하다"
              : "Every dog is good",
          ];

          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (
              parsed &&
              !internalTruthSet.some((p) => arePropositionsEqual(p, parsed))
            ) {
              truePropositions.push({
                type: "user-made",
                text: pText,
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
        } else if (step === 6) {
          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentPlayer = "A";
          isThinkingTime = false;
          document.getElementById("thinking-time-controls").style.display =
            "none";

          const premises =
            currentLang.langCode === "ko"
              ? [
                  "플라톤은 선하다 또는 플라톤은 악하다",
                  "(플라톤은 선하다) 라면 (플라톤은 지혜롭다)",
                  "(플라톤은 악하다) 라면 (플라톤은 지혜롭다)",
                ]
              : [
                  "Plato is good or Plato is evil",
                  "(Plato is good) then (Plato is wise)",
                  "(Plato is evil) then (Plato is wise)",
                ];

          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (
              parsed &&
              !internalTruthSet.some((p) => arePropositionsEqual(p, parsed))
            ) {
              truePropositions.push({
                type: "user-made",
                text: pText,
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
          openEurekaModalTutorial();
        } else if (step === 7) {
          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentPlayer = "A";
          isThinkingTime = false;
          document.getElementById("thinking-time-controls").style.display =
            "none";
          const premises =
            currentLang.langCode === "ko"
              ? [
                  "(소크라테스는 지혜롭다) 라면 (플라톤은 개이다)",
                  "(플라톤은 개이다) 라면 (플라톤은 선하다)",
                ]
              : [
                  "(Socrates is wise) then (Plato is a dog)",
                  "(Plato is a dog) then (Plato is good)",
                ];

          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (parsed) {
              truePropositions.push({
                type: "user-made",
                text: propositionToNaturalText(parsed),
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
          openEurekaModalTutorial();
        } else if (step === 8) {
          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentPlayer = "A";
          isThinkingTime = false;
          document.getElementById("thinking-time-controls").style.display =
            "none";
          const premises =
            currentLang.langCode === "ko"
              ? [
                  "(소크라테스는 악하다 는 거짓이다) 라면 (플라톤은 지혜롭다)",
                  "플라톤은 지혜롭다 는 거짓이다",
                ]
              : [
                  "(Socrates is evil is false) then (Plato is wise)",
                  "Plato is wise is false",
                ];

          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (
              parsed &&
              !internalTruthSet.some((p) => arePropositionsEqual(p, parsed))
            ) {
              truePropositions.push({
                type: "user-made",
                text: pText,
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
          openEurekaModalTutorial();
        }
        render();
      }

      function renderModal() {
        const premiseList = document.getElementById("premise-list");
        premiseList.innerHTML = "";

        const hasAssumption = !!currentAssumption;
        document.getElementById("add-assumption-btn").disabled = hasAssumption;
        document.getElementById("cancel-assumption-btn").style.display =
          hasAssumption ? "inline-block" : "none";

        derivedPropositionsInModal.forEach((propData) => {
          const li = document.createElement("li");
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          li.dataset.propObject = JSON.stringify(propData);

          if (propData.isAssumption) li.classList.add("assumption-itself");
          else if (propData.dependsOnAssumption)
            li.classList.add("assumption-dependent");

          li.appendChild(checkbox);
          li.append(
            ` ${propData.label} ${propositionToText(propData.proposition)}`
          );

          premiseList.appendChild(li);
        });
      }

      // --- 유레카 모달 리스트 클릭 편의성 개선 코드 ---
      const eurekaPremiseList = document.getElementById("premise-list");

      if (eurekaPremiseList) {
        eurekaPremiseList.addEventListener("click", function (event) {
          // 클릭된 지점에서 가장 가까운 <li> 요소를 찾습니다.
          const targetLi = event.target.closest("li");

          // <li> 요소 안에서 클릭이 발생했다면,
          if (targetLi) {
            // 그 <li> 안에 있는 체크박스를 찾습니다.
            const checkbox = targetLi.querySelector('input[type="checkbox"]');

            // 체크박스가 존재한다면,
            if (checkbox) {
              // 중요: 실제 클릭된 요소(event.target)가 체크박스 자체가 아닐 때만 코드로 상태를 변경합니다.
              // 이렇게 해야 체크박스를 직접 클릭했을 때 상태가 두 번 바뀌는 현상을 막을 수 있습니다.
              if (event.target !== checkbox) {
                checkbox.checked = !checkbox.checked;
              }
            }
          }
        });
        // --- 전체 화면 기능 로직 ---
        const fullscreenBtn = document.getElementById("fullscreen-btn");

        fullscreenBtn.addEventListener("click", toggleFullScreen);

        function toggleFullScreen() {
          if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch((err) => {
              alert(TEXTS.fullscreen_error + `: ${err.message} (${err.name})`);
            });
          } else {
            if (document.exitFullscreen) {
              document.exitFullscreen();
            }
          }
        }

        // --- UI 텍스트 업데이트 (다국어 지원) ---
        function updateUIText() {
          document.querySelectorAll("[data-i18n]").forEach((element) => {
            const key = element.getAttribute("data-i18n");
            if (TEXTS.hasOwnProperty(key)) {
              element.textContent =
                TEXTS[`${key}_${currentLanguage}`] || TEXTS[`${key}_ko`]; // 현재 언어 없으면 한국어 기본
            }
          });
        }

        // 초기 로드 시 텍스트 업데이트
        updateUIText();

        // 언어 변경 시 텍스트 업데이트 함수 호출 (기존 언어 변경 로직에 추가 필요)
        // 예시:
        // function changeLanguage(lang) {
        //     currentLanguage = lang;
        //     localStorage.setItem('languagePreference', lang);
        //     updateUIText(); // 텍스트 업데이트
        //     // ... 기존 언어 변경 로직 ...
        // }
      }
      function adjustBottomBackground() {
        const statusBar = document.getElementById("status");
        const bottomBox = document.getElementById("bottom-background-box");

        if (statusBar && bottomBox) {
          // getBoundingClientRect()를 사용해 status-bar의 실제 위치와 크기 정보를 가져옵니다.
          const statusBarRect = statusBar.getBoundingClientRect();

          // status-bar의 세로 중앙 위치를 계산합니다.
          const statusBarMidY = statusBarRect.top + statusBarRect.height / 2;

          // 화면 전체 높이에서 status-bar 중앙 위치를 뺀 만큼을 bottom-box의 높이로 지정합니다.
          const newHeight = window.innerHeight - statusBarMidY;

          // 계산된 높이가 0보다 클 때만 적용하여 오류를 방지합니다.
          if (newHeight > 0) {
            bottomBox.style.height = `${newHeight}px`;
          }
        }
      }
      // 창 크기가 조절될 때마다 함수를 호출합니다.
      window.addEventListener("resize", adjustBottomBackground);
      // 전체화면 상태가 변경될 때마다 함수를 호출합니다.
      document.addEventListener("fullscreenchange", adjustBottomBackground);

      // 페이지가 처음 로드될 때 한 번 실행하여 초기 높이를 맞춥니다.
      adjustBottomBackground();
      function closeGameOverModal() {
        const gameOverModal = document.getElementById("game-over-modal");
        gameOverModal.style.display = "none"; // 모달을 숨김
      }
      document.getElementById("vs-player-btn").addEventListener("click", () => {
        if (inTutorialMode) return;
        document.querySelector(".main-center-bg").classList.add("hidden"); // 메인 센터 숨김
        gameMode = "2P";
        aiPlayer = null;
        resetGame();
      });
      document.getElementById("vs-ai-btn").addEventListener("click", () => {
        if (inTutorialMode || gameMode === "AI") return;
        document.querySelector(".main-center-bg").classList.add("hidden"); // 메인 센터 숨김
        document
          .getElementById("character-select-modal")
          .classList.add("visible");
      });
      document.getElementById("main-menu-btn").addEventListener("click", () => {
        // AI 타이머 정리 및 게임 상태 초기화
        clearAllAITimeouts();
        aiPlayer = null; // AI 플레이어 초기화
        gameMode = "2P"; // 게임 모드 초기화
        gameIsOver = true; // 게임 종료 상태로 설정

        // UI 업데이트
        document.querySelector(".main-center-bg").classList.remove("hidden");
        updateMainMenuBtnVisibility();
        updateMainCenterVisibility();

        resetGame();
      });

      function updateMainMenuBtnVisibility() {
        const mainCenter = document.querySelector(".main-center-bg");
        const mainMenuBtn = document.getElementById("main-menu-btn");
        if (mainCenter && mainMenuBtn) {
          if (!mainCenter.classList.contains("hidden")) {
            mainMenuBtn.style.display = "none";
          } else {
            mainMenuBtn.style.display = "";
          }
        }
      }

      // 메인 센터 show/hide 시마다 호출
      document.getElementById("main-menu-btn").addEventListener("click", () => {
        document.querySelector(".main-center-bg").classList.remove("hidden");
        updateMainMenuBtnVisibility();
      });
      document.getElementById("vs-player-btn").addEventListener("click", () => {
        if (inTutorialMode) return;
        document.querySelector(".main-center-bg").classList.add("hidden");
        updateMainMenuBtnVisibility();
        gameMode = "2P";
        aiPlayer = null;
        resetGame();
      });
      document.getElementById("vs-ai-btn").addEventListener("click", () => {
        if (inTutorialMode || gameMode === "AI") return;
        document.querySelector(".main-center-bg").classList.add("hidden");
        updateMainMenuBtnVisibility();
        document
          .getElementById("character-select-modal")
          .classList.add("visible");
      });

      function updateMainCenterVisibility() {
        const mainCenter = document.querySelector(".main-center-bg");
        const hideList = [
          "#player-a-area .player-title-box",
          "#player-a-area .hand",
          "#player-a-area .eureka-btn",
          "#player-b-area .player-title-box",
          "#player-b-area .hand",
          "#player-b-area .eureka-btn",
          "#status > *", // status-bar의 자식(내용물)만
          "#round-display",
          "#new-game-btn",
        ];
        const shouldHide = !mainCenter.classList.contains("hidden");
        hideList.forEach((sel) => {
          const el = document.querySelector(sel);
          if (el) el.style.display = shouldHide ? "none" : "";
        });
      }
      // 메인 센터 show/hide 시마다 호출
      document.getElementById("main-menu-btn").addEventListener("click", () => {
        document.querySelector(".main-center-bg").classList.remove("hidden");
        updateMainMenuBtnVisibility();
        updateMainCenterVisibility();
        if (inTutorialMode) {
          inTutorialMode = false;
          document.getElementById("tutorial-guide").classList.add("hidden");
          clearHighlights();
          // 버튼 복구
          const tutorialBtn = document.getElementById("tutorial-btn");
          tutorialBtn.textContent = currentLang.ui.tutorialButton;
          tutorialBtn.removeEventListener("click", endTutorial);
          tutorialBtn.addEventListener("click", startTutorial);
          document
            .querySelectorAll(
              ".header-buttons-left button, .header-buttons-right button"
            )
            .forEach((btn) => {
              btn.disabled = false;
            });
          document.getElementById("eureka-modal").classList.remove("visible");
        }
        // AI 타이머 정리 및 게임 상태 초기화
        clearAllAITimeouts();
        aiPlayer = null;
        gameMode = "2P";
        gameIsOver = true;

        // UI 업데이트
        document.querySelector(".main-center-bg").classList.remove("hidden");
        updateMainMenuBtnVisibility();
        updateMainCenterVisibility();

        resetGame();
      });
      document.getElementById("vs-player-btn").addEventListener("click", () => {
        if (inTutorialMode) return;
        document.querySelector(".main-center-bg").classList.add("hidden");
        updateMainMenuBtnVisibility();
        updateMainCenterVisibility();
        gameMode = "2P";
        aiPlayer = null;
        resetGame();
      });
      document.getElementById("vs-ai-btn").addEventListener("click", () => {
        if (inTutorialMode || gameMode === "AI") return;
        document.querySelector(".main-center-bg").classList.add("hidden");
        updateMainMenuBtnVisibility();
        updateMainCenterVisibility();
        document
          .getElementById("character-select-modal")
          .classList.add("visible");
      });

      // 초기화 시에도 호출
      updateMainCenterVisibility();

      // 초기화 시에도 호출
      updateMainMenuBtnVisibility();

      function clearAllAITimeouts() {
        if (aiTimeoutId) {
          clearTimeout(aiTimeoutId);
          aiTimeoutId = null;
        }
      }
    </script>
  </body>
</html>
