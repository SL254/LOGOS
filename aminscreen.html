<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LOGOS</title>

    <style>
      @font-face {
        font-family: "font"; /* CSSì—ì„œ ì‚¬ìš©í•  í°íŠ¸ ì´ë¦„ì„ ì§€ì • */
        src: url("assets/font.ttf") format("truetype"); /* í°íŠ¸ íŒŒì¼ì˜ ê²½ë¡œì™€ í˜•ì‹ */
      }
      body {
        font-family: "font", "Malgun Gothic", "Segoe UI", sans-serif;
        background-color: #f4f7f9;
        color: #333;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
        font-size: 15px;
        /* 1. ì´ë¯¸ì§€ íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸° */
        background-image: url("assets/sky.png"); /* ğŸ‘ˆ ì‚¬ìš©í•  ë‹¨ì¼ ì´ë¯¸ì§€ ê²½ë¡œ */
        background-repeat: no-repeat; /* ğŸ‘ˆ ì´ë¯¸ì§€ ë°˜ë³µ ì•ˆ í•¨ */
        background-size: cover; /* ğŸ‘ˆ ë°•ìŠ¤ë¥¼ ë®ë„ë¡ í¬ê¸° ì¡°ì ˆ (ë˜ëŠ” contain) */
        background-position: center; /* ğŸ‘ˆ ì´ë¯¸ì§€ë¥¼ ì¤‘ì•™ì— ë°°ì¹˜ */
        image-rendering: pixelated;
      }
      .container {
        display: grid;
        grid-template-columns: 1fr 2fr 1fr;
        grid-template-rows: auto auto 1fr auto;
        row-gap: 0;
        column-gap: 0px;
        width: 100%;
        max-width: 1400px;
        height: 90vh;
        visibility: hidden; /* Initially hidden until language is selected */
        position: relative;
        z-index: 1;
      }
      .container.ready {
        visibility: visible;
      }
      header {
        grid-column: 1 / -1;
        text-align: center;
        padding: 25px 15px;
        color: black;
        margin: 0 -40px;
        background-image: url("assets/roof.png"); /* ğŸ‘ˆ ì‚¬ìš©í•  ë‹¨ì¼ ì´ë¯¸ì§€ ê²½ë¡œ */
        background-repeat: no-repeat; /* ğŸ‘ˆ ì´ë¯¸ì§€ ë°˜ë³µ ì•ˆ í•¨ */
        background-size: cover; /* ğŸ‘ˆ ë°•ìŠ¤ë¥¼ ë®ë„ë¡ í¬ê¸° ì¡°ì ˆ (ë˜ëŠ” contain) */
        background-position: center; /* ğŸ‘ˆ ì´ë¯¸ì§€ë¥¼ ì¤‘ì•™ì— ë°°ì¹˜ */
        image-rendering: pixelated;
      }
      header h1 {
        color: #9a4b37;
        margin: 0;
        font-size: 38px;
      }

      #info-box {
        padding: 15px 55px;
        grid-column: 1 / -1;
        display: flex;
        justify-content: space-between;
        align-items: center;
        position: relative;
        margin: 0 -40px;
        background-image: url("assets/roo.png"); /* ğŸ‘ˆ ì‚¬ìš©í•  ë‹¨ì¼ ì´ë¯¸ì§€ ê²½ë¡œ */
        background-repeat: no-repeat; /* ğŸ‘ˆ ì´ë¯¸ì§€ ë°˜ë³µ ì•ˆ í•¨ */
        background-size: cover; /* ğŸ‘ˆ ë°•ìŠ¤ë¥¼ ë®ë„ë¡ í¬ê¸° ì¡°ì ˆ (ë˜ëŠ” contain) */
        background-position: center; /* ğŸ‘ˆ ì´ë¯¸ì§€ë¥¼ ì¤‘ì•™ì— ë°°ì¹˜ */
        image-rendering: pixelated;
      }
      .header-buttons-left,
      .header-buttons-right {
        display: flex;
        gap: 10px;
      }
      .header-buttons-left button,
      .header-buttons-right button {
        padding: 4px 8px;
        border: none;

        cursor: pointer;
        transition: background-color 0.2s;
        font-size: 1em;
      }
      #new-game-btn {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/new.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #new-game-btn:hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/new_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #fullscreen-btn {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/full.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #fullscreen-btn:hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/full_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }

      #main-menu-btn {
        border-width: 5px;
        border-style: solid;
        border-color: transparent;
        border-image-source: url("assets/full.png");
        border-image-slice: 6 fill;
        border-image-repeat: round;
        background-color: transparent;
      }
      #main-menu-btn:hover {
        border-image-source: url("assets/full_hover.png");
      }
      #tutorial-btn {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/tuto.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #tutorial-btn:hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/tuto_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      .mode-selector button {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/tuto.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }

      .mode-selector button:not(.active):hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/tuto_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }

      .round-display {
        /* position, left, transform ì†ì„± ì œê±° */
        font-size: 1.4em;
        font-weight: normal;
        color: #9a4b37;
      }
      .player-area {
        background-color: #b95941;
        padding: 15px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        display: flex;
        flex-direction: column;
        transition: opacity 0.3s, box-shadow 0.3s;
        border: 4px solid transparent;
      }
      .player-area.disabled {
        background-color: #b95941;
      }

      .player-area h3 {
        font-weight: normal;
        margin: 0;
      }
      .hand {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-content: flex-start;
        height: 500px; /* ì›í•˜ëŠ” ê³ ì • ë†’ì´ê°’ (ì¡°ì • ê°€ëŠ¥) */
        overflow-y: auto; /* ë‚´ìš©ì´ ë„˜ì¹  ê²½ìš° ìŠ¤í¬ë¡¤ ìƒì„± */

        padding: 10px; /* ì¹´ë“œ íš¨ê³¼ê°€ ê·¸ë ¤ì§ˆ ë‚´ë¶€ ì—¬ë°± í™•ë³´ */
        box-sizing: border-box; /* paddingì´ ë†’ì´ ê³„ì‚°ì— í¬í•¨ë˜ë„ë¡ ì„¤ì • */
        background-color: rgba(238, 218, 165, 0.65); /* ë°˜íˆ¬ëª… í°ìƒ‰ ë°°ê²½ */
      }
      .card {
        padding: 10px 15px;
        cursor: pointer;
        transition: all 0.2s;
      }
      .card.ai-hand {
        cursor: default;
      }
      .card-white {
        /* ì¹´ë“œ ë‚´ìš©ë¬¼ì„ ìœ„í•œ ì•ˆìª½ ì—¬ë°± */
        padding: 7px;

        /* border-imageë¥¼ ìœ„í•œ ì„¤ì • */
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/card_white.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
      }
      .card-white:hover:not(.ai-hand) {
        /* ì¹´ë“œ ë‚´ìš©ë¬¼ì„ ìœ„í•œ ì•ˆìª½ ì—¬ë°± */
        padding: 7px;

        /* border-imageë¥¼ ìœ„í•œ ì„¤ì • */
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/card_white_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
      }
      .card-black {
        color: white;
        /* ì¹´ë“œ ë‚´ìš©ë¬¼ì„ ìœ„í•œ ì•ˆìª½ ì—¬ë°± */
        padding: 7px;

        /* border-imageë¥¼ ìœ„í•œ ì„¤ì • */
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/card_black.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
      }
      .card-black:hover:not(.ai-hand) {
        color: white;
        /* ì¹´ë“œ ë‚´ìš©ë¬¼ì„ ìœ„í•œ ì•ˆìª½ ì—¬ë°± */
        padding: 7px;

        /* border-imageë¥¼ ìœ„í•œ ì„¤ì • */
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/card_black_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
      }
      .game-board {
        display: flex;
        flex-direction: column;
        gap: 0px;
        min-height: 0;
        position: relative;
      }
      #current-proposition {
        /* ì¹´ë“œ ë‚´ìš©ë¬¼ì„ ìœ„í•œ ì•ˆìª½ ì—¬ë°± */
        padding: 7px;

        /* border-imageë¥¼ ìœ„í•œ ì„¤ì • */
        border-width: 20px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/papiru.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
      }
      #current-proposition {
        min-height: 120px;
        display: flex;
        flex-direction: column;
      }

      #background-box {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 300px; /* ğŸ‘ˆ ë†’ì´ë¥¼ ê³ ì •ê°’ìœ¼ë¡œ ì§ì ‘ ì§€ì • */
        z-index: -1;
        /* 1. ì´ë¯¸ì§€ íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸° */
        background-image: url("assets/cloud.png"); /* ğŸ‘ˆ ì—¬ê¸°ì— íŒŒì¼ ê²½ë¡œë¥¼ ì…ë ¥í•˜ì„¸ìš” */
        background-size: 340px 340px; /* ğŸ‘ˆ 64pxì—ì„œ 128pxë¡œ 2ë°° í™•ëŒ€ */
        image-rendering: pixelated; /* ğŸ‘ˆ ì´ë¯¸ì§€ë¥¼ ì„ ëª…í•˜ê²Œ ìœ ì§€í•˜ëŠ” í•µì‹¬ ì†ì„± */

        background-repeat: repeat; /* ë°°ê²½ ì´ë¯¸ì§€ë¥¼ ë°”ë‘‘íŒì‹ìœ¼ë¡œ ë°˜ë³µ */
      }
      #proposition-display {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        min-height: 50px;
        flex-grow: 1;
        align-items: center;
      }
      #proposition-controls {
        margin-top: 10px;
        display: flex;
        gap: 10px;
      }
      #complete-btn {
        color: white;
        padding: 0;
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/complete.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        image-rendering: pixelated;
      }
      #complete-btn:hover:not(:disabled) {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/complete_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        image-rendering: pixelated;
      }
      #undo-btn {
        color: white;
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/undo.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        image-rendering: pixelated;
      }
      #undo-btn:hover:not(:disabled) {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/undo_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        image-rendering: pixelated;
      }
      #end-turn-btn {
        color: white;
        margin-left: auto;
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/end.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        image-rendering: pixelated;
      }
      #end-turn-btn:hover:not(:disabled) {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/end_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        image-rendering: pixelated;
      }
      #true-propositions {
        /* ì¹´ë“œ ë‚´ìš©ë¬¼ì„ ìœ„í•œ ì•ˆìª½ ì—¬ë°± */
        padding: 15px;

        /* border-imageë¥¼ ìœ„í•œ ì„¤ì • */
        border-width: 20px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/papiru_1.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        image-rendering: pixelated;

        /* --- ìˆ˜ì •ëœ ë¶€ë¶„ --- */
        flex-grow: 1; /* ë‚¨ëŠ” ê³µê°„ì„ ì°¨ì§€í•˜ë ¤ëŠ” ì„±ì§ˆ */
        flex-shrink: 1; /* ê³µê°„ì´ ë¶€ì¡±í•  ë•Œ ì¤„ì–´ë“¤ë ¤ëŠ” ì„±ì§ˆ */
        flex-basis: 0; /* í•µì‹¬: ë‚´ìš©ë¬¼ í¬ê¸°ë¥¼ ë¬´ì‹œí•˜ê³  0ì—ì„œë¶€í„° ê³µê°„ì„ ê³„ì‚°í•˜ë„ë¡ ì„¤ì • */
        /* ------------------ */

        overflow-y: auto;
        min-height: 0;
      }

      #true-propositions h3 {
        margin-top: 0;
      }
      #true-propositions ul {
        padding-left: 0;
        list-style-type: none;
        margin: 0;
      }
      #true-propositions li {
        margin-bottom: 8px;
        padding: 8px;
        background-color: #fff;

        border-left: 4px solid #3498db;
      }
      #true-propositions li.victory-condition {
        border-left-color: #f1c40f;
        font-weight: normal;
        background-color: #fef9e7;
      }
      #true-propositions li.axiom-wrapper {
        padding: 0;
        border-left: none;
      }
      #true-propositions li.theorem {
        border-left-color: #8e44ad;
        font-style: italic;
        background-color: #f5eef8;
      }
      .word-a {
        color: #7f8c8d;
      }
      .word-b {
        color: #2c3e50;
      }
      details {
        background-color: #fff;

        margin-bottom: 8px;
      }
      summary {
        padding: 5px;
        cursor: pointer;
        font-weight: normal;
      }
      .axiom-list {
        padding: 5px 15px 15px 35px;
        background-color: #fafafa;
        border-top: 1px solid #eee;
      }
      .axiom-list p {
        margin: 4px 0;
        font-size: 14px;
      }
      .status-bar {
        height: 46px; /* ê³ ì • ë†’ì´ ë¶€ì—¬ (ê°’ì€ ì ì ˆíˆ ì¡°ì ˆ) */
        display: flex; /* ë‚´ë¶€ ìš”ì†Œë¥¼ flexboxë¡œ ì •ë ¬ */
        align-items: center; /* ì„¸ë¡œ ì¤‘ì•™ ì •ë ¬ */
        justify-content: center; /* ê°€ë¡œ ì¤‘ì•™ ì •ë ¬ */
        grid-column: 1 / -1;
        text-align: center;
        padding: 15px;
        font-weight: normal;
        font-size: 1.2em;
        background-color: transparent;
        margin: 0 -40px;
        min-height: 40px; /* Give it some default height */
        background-image: url("assets/bottom.png"); /* ğŸ‘ˆ ì‚¬ìš©í•  ë‹¨ì¼ ì´ë¯¸ì§€ ê²½ë¡œ */
        background-repeat: no-repeat; /* ğŸ‘ˆ ì´ë¯¸ì§€ ë°˜ë³µ ì•ˆ í•¨ */
        background-size: cover; /* ğŸ‘ˆ ë°•ìŠ¤ë¥¼ ë®ë„ë¡ í¬ê¸° ì¡°ì ˆ (ë˜ëŠ” contain) */
        background-position: center; /* ğŸ‘ˆ ì´ë¯¸ì§€ë¥¼ ì¤‘ì•™ì— ë°°ì¹˜ */
        image-rendering: pixelated;
      }
      /* ì´ ì½”ë“œë¥¼ style íƒœê·¸ ì•ˆì— ì¶”ê°€í•˜ì„¸ìš” */
      .player-title-box {
        padding: 10px; /* ë‚´ë¶€ ì—¬ë°± */
        text-align: center; /* í…ìŠ¤íŠ¸ ê°€ìš´ë° ì •ë ¬ */
        margin-bottom: 15px; /* ì¹´ë“œ ëª©ë¡(hand)ê³¼ì˜ ê°„ê²© */
        background-image: url("assets/player.png"); /* ğŸ‘ˆ ì‚¬ìš©í•  ë‹¨ì¼ ì´ë¯¸ì§€ ê²½ë¡œ */
        background-repeat: no-repeat; /* ğŸ‘ˆ ì´ë¯¸ì§€ ë°˜ë³µ ì•ˆ í•¨ */
        background-size: contain; /* ğŸ‘ˆ ë°•ìŠ¤ë¥¼ ë®ë„ë¡ í¬ê¸° ì¡°ì ˆ (ë˜ëŠ” contain) */
        background-position: center; /* ğŸ‘ˆ ì´ë¯¸ì§€ë¥¼ ì¤‘ì•™ì— ë°°ì¹˜ */
        image-rendering: pixelated;
      }
      .eureka-btn {
        margin-top: auto;
        padding: 10px 15px;
        border: none;
        color: #333;
        font-size: 1.1em;
        cursor: pointer;
        transition: background-color 0.2s;
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/eureka.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      .eureka-btn:hover:not(:disabled) {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/eureka_1.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      .eureka-btn:disabled {
        cursor: not-allowed;
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/eureka_disabled.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #proposition-controls button:disabled {
        color: #464646;
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/disabled.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        cursor: not-allowed;
      }
      .modal {
        position: fixed;
        z-index: 100;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.6);
        display: none;
        align-items: center;
        justify-content: center;
      }
      .modal.visible {
        display: flex;
      }
      .modal-content {
        padding: 20px;

        border-width: 20px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/papiru_3.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */

        width: 80%;
        max-width: 800px;
        position: relative;
      }
      .modal-content-small {
        border-width: 20px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/papiru_3.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */

        padding: 30px;
        text-align: center;
        max-width: 500px;
        width: 90%;
      }
      .close-button {
        color: #000000;
        position: absolute;
        padding: 15px;
        top: 17px;
        right: 33px;
        font-size: 20px;
        font-weight: normal;
        cursor: pointer;
        background-image: url("assets/close.png"); /* ğŸ‘ˆ ì•„ì´ì½˜ì€ background-imageë¡œ ì„¤ì •í•´ì•¼ í•©ë‹ˆë‹¤. */
        background-repeat: no-repeat; /* ğŸ‘ˆ ì•„ì´ì½˜ì´ ë°˜ë³µë˜ì§€ ì•Šë„ë¡ ì„¤ì • */
        background-size: contain; /* ğŸ‘ˆ ë²„íŠ¼ í¬ê¸°ì— ë§ì¶° ì•„ì´ì½˜ í¬ê¸° ì¡°ì ˆ */
        background-position: center; /* ğŸ‘ˆ ì•„ì´ì½˜ì„ ì¤‘ì•™ì— ë°°ì¹˜ */
        image-rendering: pixelated;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        border: none; /* í…Œë‘ë¦¬ ì œê±° */
        z-index: 10;
      }
      .close-button:hover {
        background-image: url("assets/close_hover.png"); /* ğŸ‘ˆ ì•„ì´ì½˜ì€ background-imageë¡œ ì„¤ì •í•´ì•¼ í•©ë‹ˆë‹¤. */
        background-repeat: no-repeat; /* ğŸ‘ˆ ì•„ì´ì½˜ì´ ë°˜ë³µë˜ì§€ ì•Šë„ë¡ ì„¤ì • */
        background-size: contain; /* ğŸ‘ˆ ë²„íŠ¼ í¬ê¸°ì— ë§ì¶° ì•„ì´ì½˜ í¬ê¸° ì¡°ì ˆ */
        background-position: center; /* ğŸ‘ˆ ì•„ì´ì½˜ì„ ì¤‘ì•™ì— ë°°ì¹˜ */
        image-rendering: pixelated;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        border: none; /* í…Œë‘ë¦¬ ì œê±° */
        color: black;
      }
      .proof-container {
        background-color: #eedaa5;
        display: flex;
        gap: 20px;
        margin-top: 15px;
      }
      .premise-selection {
        flex: 1;
        background-color: #eedaa5;
        padding: 15px;

        height: 50vh;
        overflow-y: auto;
      }
      .premise-selection ul {
        list-style-type: none;
        padding: 0;
      }
      .premise-selection li {
        margin-bottom: 5px;
        padding: 8px;
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/pre_li.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */

        width: 80%;
        max-width: 800px;
        position: relative;

        cursor: pointer;
      }

      .premise-selection li.assumption-dependent {
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/pre_li_assu.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        font-style: italic;
      }
      .premise-selection li.assumption-itself {
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/pre_li_assu.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        font-style: italic;
      }
      .premise-selection li:hover {
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/pre_li_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #modal-confirm-btn {
        color: white;
        margin-top: 20px;
        padding: 12px 25px;
        font-size: 1.2em;
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/confirm.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */

        cursor: pointer;
      }
      #modal-confirm-btn:hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/confirm_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #workbench-controls {
        display: flex;
        gap: 10px;
        align-items: center;
        justify-content: center;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 1px solid #eee;
      }
      #apply-rule-btn {
        color: black;
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/full.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */

        cursor: pointer;
      }
      #apply-rule-btn:hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/full_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */

        cursor: pointer;
      }
      #add-assumption-btn {
        color: black;
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/tuto.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */

        cursor: pointer;
      }
      #add-assumption-btn:hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/tuto_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #add-assumption-btn:disabled {
        display: none;
        cursor: not-allowed;
      }
      #cancel-assumption-btn {
        color: black;
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/undo.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #cancel-assumption-btn:hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/undo_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #thinking-time-controls {
        display: none;
        text-align: center;
        /* ì¹´ë“œ ë‚´ìš©ë¬¼ì„ ìœ„í•œ ì•ˆìª½ ì—¬ë°± */
        padding: 15px;

        /* border-imageë¥¼ ìœ„í•œ ì„¤ì • */
        border-width: 20px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/papiru_1.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;

        margin-top: 0;
      }
      #end-thinking-time-btn {
        margin-top: 10px;
        padding: 10px 20px;
        font-size: 1.1em;
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/think.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        color: black;

        cursor: pointer;
      }
      #end-thinking-time-btn:hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/think_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #prompt-input {
        width: 100%;
        padding: 8px;
        margin-top: 15px;
        margin-bottom: 15px;
      }
      .modal-buttons {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 20px;
      }
      .modal-buttons button {
        padding: 8px 16px;

        border: none;
        cursor: pointer;
        font-weight: normal;
      }

      #alert-ok-btn {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/tuto.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #alert-ok-btn:hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/tuto_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #prompt-confirm-btn {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/complete.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #prompt-confirm-btn:hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/complete_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #prompt-cancel-btn {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/undo.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #prompt-cancel-btn:hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/undo_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #tutorial-modal .modal-content {
        max-width: 800px;
        height: 70vh;
        overflow-y: auto;
      }
      #tutorial-modal h3 {
        border-bottom: 2px solid #eee;
        padding-bottom: 10px;
        margin-top: 20px;
      }
      #tutorial-modal ul {
        list-style-position: inside;
        padding-left: 10px;
      }
      #tutorial-modal li {
        margin-bottom: 10px;
        line-height: 1.6;
      }
      #tutorial-modal code {
        background-color: #e9ecef;
        padding: 2px 6px;
      }
      /* Modal Styles */
      #language-modal .modal-content-small,
      #character-select-modal .modal-content-small {
        border-width: 20px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/papiru_3.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      .selection-buttons {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 25px;
      }
      .selection-buttons button {
        padding: 15px 30px;
        font-size: 1.2em;
        font-weight: normal;
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/tuto.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */

        cursor: pointer;
        transition: all 0.3s ease;
      }
      .selection-buttons button:hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/tuto_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        transform: translateY(-3px);
      }

      /* Tutorial Styles */
      .tutorial-highlight {
        box-shadow: 0 0 0 4px #639bff, 0 0 20px #6da2ff; /* ğŸ‘ˆ íŒŒë€ìƒ‰ìœ¼ë¡œ ë³€ê²½ */

        transition: box-shadow 0.3s ease-in-out;
        position: relative;
        z-index: 101; /* Ensure it's above other elements */
      }
      #tutorial-guide {
        position: fixed; /* ğŸ‘ˆ absoluteì—ì„œ fixedë¡œ ë³€ê²½ëœ ê²ƒì´ í•µì‹¬ì…ë‹ˆë‹¤. */
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(44, 62, 80, 0.9);
        color: white;
        padding: 20px;
        width: 80%;
        max-width: 700px;
        text-align: center;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        z-index: 200; /* ì´ ê°’ì€ ì½”ë“œ í•˜ë‹¨ì˜ !important ê·œì¹™ìœ¼ë¡œ ë®ì–´ì¨ì§‘ë‹ˆë‹¤. */
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
        transition: top 0.3s ease-in-out, bottom 0.3s ease-in-out;
      }
      #tutorial-guide.top {
        top: 20px;
        bottom: auto;
      }
      #tutorial-guide p {
        margin: 0;
        font-size: 1.1em;
        line-height: 1.6;
      }
      #tutorial-guide button {
        padding: 10px 25px;
        font-size: 1em;
        font-weight: normal;
        border: none;

        cursor: pointer;
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/tuto.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        transform: translateY(-3px);
        color: #2c3e50;
      }
      #tutorial-guide button:hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/tuto_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      .hidden {
        display: none !important;
      }
      #bottom-background-box {
        position: fixed; /* í™”ë©´ í•˜ë‹¨ì— ê³ ì • */
        bottom: 0;
        left: 0;
        width: 100%; /* ì¢Œìš° ê½‰ ì±„ìš°ê¸° */
        height: 40px; /* ìƒíƒœí‘œì‹œì¤„ ì¤‘ê°„ê¹Œì§€ì˜ ë†’ì´ (ì¡°ì • ê°€ëŠ¥) */
        z-index: -1; /* ë‹¤ë¥¸ ìš”ì†Œë“¤ ë’¤ë¡œ ë³´ë‚´ê¸° */

        /* 1. ì´ë¯¸ì§€ íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸° */
        background-image: url("assets/grass.png"); /* ğŸ‘ˆ ì—¬ê¸°ì— íŒŒì¼ ê²½ë¡œë¥¼ ì…ë ¥í•˜ì„¸ìš” */
        background-size: 150px 150px; /* ğŸ‘ˆ 64pxì—ì„œ 128pxë¡œ 2ë°° í™•ëŒ€ */
        image-rendering: pixelated; /* ğŸ‘ˆ ì´ë¯¸ì§€ë¥¼ ì„ ëª…í•˜ê²Œ ìœ ì§€í•˜ëŠ” í•µì‹¬ ì†ì„± */

        background-repeat: repeat; /* ë°°ê²½ ì´ë¯¸ì§€ë¥¼ ë°”ë‘‘íŒì‹ìœ¼ë¡œ ë°˜ë³µ */
      }

      .turn-indicator {
        display: inline-block;
        padding: 8px 20px; /* ë‚´ë¶€ ì—¬ë°± *
        transition: all 0.3s ease; /* ë¶€ë“œëŸ¬ìš´ ì „í™˜ íš¨ê³¼ */
        text-align: center; /* í…ìŠ¤íŠ¸ ê°€ìš´ë° ì •ë ¬ */
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/indi.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        image-rendering: pixelated;
      }

      button,
      select {
        font-family: inherit;
      }
      #info-box > div {
        position: relative; /* ìœ„ì¹˜ë¥¼ ìƒëŒ€ì ìœ¼ë¡œ ì¡°ì •í•˜ë„ë¡ ì„¤ì • */
        top: 6px; /* ğŸ‘ˆ ì›ë˜ ìœ„ì¹˜ì—ì„œ 5px ì•„ë˜ë¡œ ì´ë™ */
      }
      .header-buttons-left,
      .header-buttons-right {
        flex: 1; /* ì–‘ìª½ ì»¨í…Œì´ë„ˆê°€ ë™ì¼í•œ ë„ˆë¹„ë¥¼ ê°–ë„ë¡ ì„¤ì • */
      }

      /* ì˜¤ë¥¸ìª½ ë²„íŠ¼ë“¤ì„ ì˜¤ë¥¸ìª½ ëìœ¼ë¡œ ì •ë ¬ */
      .header-buttons-right {
        justify-content: flex-end;
      }
      /* ìŠ¹ë¦¬ ì¡°ê±´ í…ìŠ¤íŠ¸ì˜ strong íƒœê·¸ ë³¼ë“œì²´ ì œê±° */
      #true-propositions li.victory-condition strong {
        font-weight: normal;
      }
      /* ê¸°ì¡´ ì½”ë“œ */
      #proposition-controls button {
        padding: 8px 15px;
        cursor: pointer;
        font-size: 14px;
        font-weight: normal;
        transition: background-color 0.2s;
        /* ğŸ‘‡ ì•„ë˜ ì†ì„± ì¶”ê°€ */
        min-width: 100px; /* ì›í•˜ëŠ” ìµœì†Œ ë„ˆë¹„ë¡œ ì¡°ì ˆ (ì˜ˆ: 100px) */
        box-sizing: border-box; /* paddingì„ ë„ˆë¹„ì— í¬í•¨ì‹œì¼œ ê³„ì‚° */
      }
      /* íŠœí† ë¦¬ì–¼ ëŒ€í™”ì°½ì„ ê°•ì œë¡œ ìµœìƒë‹¨ì— í‘œì‹œí•˜ê¸° ìœ„í•œ ê·œì¹™ */
      #tutorial-guide {
        z-index: 9999 !important;
      }
      /* ìƒˆë¡œ ì¶”ê°€: í„´ì´ ì•„ë‹ ë•Œ ì¹´ë“œì— ì§ì ‘ íë¦¼ ë° ë°˜íˆ¬ëª… íš¨ê³¼ ì ìš© */
      /* í„´ì´ ì•„ë‹ ë•Œ ì¹´ë“œì˜ ë°ê¸°ì™€ ëŒ€ë¹„ë¥¼ ì¡°ì ˆ */
      .player-area.disabled .card {
        filter: brightness(0.7) contrast(0.7);
      }
      #workbench-controls select,
      #workbench-controls button {
        font-size: 16px; /* ê¸€ì í¬ê¸°ë¥¼ 14pxì—ì„œ 16pxë¡œ í‚¤ì›ë‹ˆë‹¤ */
        padding: 10px 20px; /* ë²„íŠ¼ì˜ ìƒí•˜, ì¢Œìš° ì—¬ë°±ì„ ëŠ˜ë¦½ë‹ˆë‹¤ */
      }

      #game-over-modal {
        display: none; /* ê¸°ë³¸ì ìœ¼ë¡œ ìˆ¨ê¹€ */
        position: fixed; /* í™”ë©´ì— ê³ ì • */
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: transparent;
        z-index: 100; /* ë‹¤ë¥¸ ìš”ì†Œë³´ë‹¤ ìœ„ì— í‘œì‹œ */
        align-items: center;
        justify-content: center;
      }

      /* index.html íŒŒì¼ì˜ <style> íƒœê·¸ ì•ˆ */

      /* ê¸°ì¤€ì ì´ ë˜ëŠ” ë¶€ëª¨ ìš”ì†Œ */
      .game-over-content {
        position: relative; /* â˜…â˜…â˜…â˜…â˜… ê°€ì¥ ì¤‘ìš”! ì´ê²Œ ì—†ìœ¼ë©´ ì˜¤ë²„ë ˆì´ê°€ ì—‰ëš±í•œ ê³³ì— í‘œì‹œë©ë‹ˆë‹¤. */
        width: 80vw;
        max-width: 1024px;
        aspect-ratio: 13 / 9;
        padding: 0;
        border: none;
        background-color: transparent;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
      }

      /* ê¸°ë³¸ ë°°ê²½ ì´ë¯¸ì§€ ìŠ¤íƒ€ì¼ */
      .game-over-image {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }

      /* ë§ì”Œìš¸ ì´ë¯¸ì§€ë“¤ì„ ë‹´ëŠ” ì»¨í…Œì´ë„ˆ */
      #overlay-container {
        position: absolute; /* ë¶€ëª¨ ìœ„ì— ê²¹ì¹˜ë„ë¡ ì„¤ì • */
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      /* ë§ì”Œìš¸ ê°œë³„ ì´ë¯¸ì§€ */
      .overlay-image {
        position: absolute; /* ì»¨í…Œì´ë„ˆ ìœ„ì— ê²¹ì¹˜ë„ë¡ ì„¤ì • */
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: contain;
      }

      /* ì´ë¯¸ì§€ë¥¼ ìˆ¨ê¸°ëŠ” í•µì‹¬ í´ë˜ìŠ¤ */
      .hidden {
        display: none !important; /* â˜…â˜…â˜…â˜…â˜… ê°€ì¥ ì¤‘ìš”! */
      }
      #socrates-wise-overlay,
      #socrates-foolish-overlay,
      #socrates-good-overlay,
      #socrates-evil-overlay,
      #plato-wise-overlay,
      #plato-foolish-overlay,
      #plato-good-overlay,
      #plato-evil-overlay,
      #socrates-bird-overlay,
      #socrates-fish-overlay,
      #plato-bird-overlay,
      #plato-fish-overlay,
      #socrates-win-overlay,
      #plato-win-overlay {
        z-index: 1;
      }
      #socrates-dog-overlay,
      #plato-dog-overlay {
        z-index: 2;
      }

      #player-a-area {
        /* 1. ì´ë¯¸ì§€ íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸° */
        background-image: url("assets/paper_1.png"); /* ğŸ‘ˆ ì‚¬ìš©í•  ë‹¨ì¼ ì´ë¯¸ì§€ ê²½ë¡œ */
        background-repeat: no-repeat; /* ğŸ‘ˆ ì´ë¯¸ì§€ ë°˜ë³µ ì•ˆ í•¨ */
        background-size: cover; /* ğŸ‘ˆ ë°•ìŠ¤ë¥¼ ë®ë„ë¡ í¬ê¸° ì¡°ì ˆ (ë˜ëŠ” contain) */
        background-position: center; /* ğŸ‘ˆ ì´ë¯¸ì§€ë¥¼ ì¤‘ì•™ì— ë°°ì¹˜ */
        image-rendering: pixelated;
      }

      #player-b-area {
        /* 1. ì´ë¯¸ì§€ íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸° */
        background-image: url("assets/paper.png"); /* ğŸ‘ˆ ì‚¬ìš©í•  ë‹¨ì¼ ì´ë¯¸ì§€ ê²½ë¡œ */
        background-repeat: no-repeat; /* ğŸ‘ˆ ì´ë¯¸ì§€ ë°˜ë³µ ì•ˆ í•¨ */
        background-size: cover; /* ğŸ‘ˆ ë°•ìŠ¤ë¥¼ ë®ë„ë¡ í¬ê¸° ì¡°ì ˆ (ë˜ëŠ” contain) */
        background-position: center; /* ğŸ‘ˆ ì´ë¯¸ì§€ë¥¼ ì¤‘ì•™ì— ë°°ì¹˜ */
        image-rendering: pixelated;
      }
      /* style íƒœê·¸ ì•ˆ, ê°€ì¥ ì•„ë˜ìª½ì— ì¶”ê°€ */
      body::after {
        position: absolute;
        width: 0;
        height: 0;
        overflow: hidden;
        z-index: -1; /* í™”ë©´ì— ë³´ì´ì§€ ì•Šê²Œ ì²˜ë¦¬ */
        content: url("assets/new_hover.png") url("assets/full_hover.png")
          url("assets/tuto_hover.png") url("assets/mode_hover.png")
          url("assets/card_white_hover.png") url("assets/card_black_hover.png")
          url("assets/complete_hover.png") url("assets/undo_hover.png")
          url("assets/end_hover.png") url("assets/eureka_1.png")
          url("assets/close_hover.png") url("assets/confirm_hover.png")
          url("assets/think_hover.png"); /* ê¹œë¹¡ì´ëŠ” ëª¨ë“  hover ì´ë¯¸ì§€ ê²½ë¡œ ì¶”ê°€ */
      }

      /* ...existing code... */
      .main-center-bg {
        position: absolute;
        inset: 0; /* top:0; right:0; bottom:0; left:0; */
        width: 96%;
        height: 96%;
        background: transparent;
        z-index: 1; /* ë°°ê²½ ì—­í•  */
        pointer-events: auto;
        border-width: 15px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/papiru_1.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: round;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .main-center-buttons {
        display: flex;
        flex-direction: column; /* ì„¸ë¡œë¡œ ë°°ì¹˜ */
        gap: 24px;
        align-items: center;
        z-index: 2;
        position: relative;
      }

      .main-center-buttons {
        display: flex;
        flex-direction: column;
        gap: 24px;
        align-items: center;
        z-index: 2;
        position: relative;
      }

      .mode-selector {
        display: flex;
        flex-direction: column; /* ë²„íŠ¼ì„ ì„¸ë¡œë¡œ ë°°ì¹˜ */
        gap: 30px; /* ë²„íŠ¼ ì‚¬ì´ ë„‰ë„‰í•˜ê²Œ */
        width: 100%;
      }

      .mode-selector button,
      #tutorial-btn {
        min-width: 0;
        width: 100%;
        max-width: 1000px;
        padding: 8px 50px; /* ìœ„ì•„ë˜ ì¢ê²Œ, ì¢Œìš° ë„“ê²Œ */
        font-size: 1.5em;
        box-sizing: border-box;
      }

      .main-center-bg.hidden {
        display: none !important;
      }

      /* Add these CSS rules inside the <style> tag */

      #character-selection-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 500;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 40px;
        box-sizing: border-box;
      }

      #character-selection-screen.hidden {
        display: none !important;
      }

      .player-display-area {
        width: 28%;
        height: 80%;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
        box-sizing: border-box;
        border: 4px solid #b95941;
        background-color: rgba(238, 218, 165, 0.85);
        position: relative;
      }

      .portrait-area {
        width: 100%;
        height: 50%;
        background-color: #333;
        background-size: contain;
        background-position: center;
        background-repeat: no-repeat;
        image-rendering: pixelated;
        border: 2px solid #9a4b37;
      }

      .philosopher-name {
        font-size: 2.5em;
        color: #9a4b37;
        margin-top: 20px;
        font-weight: bold;
      }

      .skill-area {
        width: 100%;
        margin-top: 20px;
        text-align: left;
      }

      .skill-title {
        font-size: 1.5em;
        color: #333;
        border-bottom: 2px solid #b95941;
        padding-bottom: 5px;
        margin-bottom: 10px;
      }

      #p1-skill-desc,
      #p2-skill-desc {
        font-size: 1.1em;
        line-height: 1.6;
      }

      .ready-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(44, 62, 80, 0.8);
        color: #f1c40f;
        font-size: 8em;
        display: none; /* Initially hidden */
        align-items: center;
        justify-content: center;
        font-weight: bold;
        text-shadow: 4px 4px 0 #000;
      }

      .ready-overlay.visible {
        display: flex;
      }

      .shared-selection-area {
        width: 40%;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 30px;
      }

      .char-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr); /* 4ì—´ ê·¸ë¦¬ë“œ, í•„ìš”ì‹œ ì¡°ì • */
        gap: 15px;
        width: 100%;
        padding: 20px;
        background-color: rgba(0, 0, 0, 0.3);
        border: 2px solid #fff;
      }

      .char-icon {
        aspect-ratio: 1 / 1;
        background-size: cover;
        background-position: center;
        border: 4px solid transparent;
        cursor: pointer;
        transition: all 0.2s ease;
        image-rendering: pixelated;
      }

      .char-icon:hover {
        border-color: #f1c40f;
        transform: scale(1.05);
      }

      .char-icon.selected {
        border-color: #e74c3c;
        box-shadow: 0 0 15px #e74c3c;
      }

      #confirm-selection-btn {
        padding: 15px 50px;
        font-size: 1.8em;
        border: none;
        cursor: pointer;
        background-color: #2ecc71;
        color: white;
        transition: background-color 0.2s;
      }

      #confirm-selection-btn:hover:not(:disabled) {
        background-color: #27ae60;
      }

      #confirm-selection-btn:disabled {
        background-color: #7f8c8d;
        cursor: not-allowed;
      }

      #turn-order-modal .modal-content-small h2 {
        font-size: 1.8em;
        margin-bottom: 25px;
      }
    </style>
  </head>
  <body>
    <!-- Language Selection Modal -->
    <div id="background-box"></div>
    <div id="background-box_1"></div>
    <div id="bottom-background-box"></div>
    <div id="language-modal" class="modal visible">
      <div class="modal-content-small">
        <h2>Choose Language / ì–¸ì–´ ì„ íƒ</h2>
        <div id="language-buttons" class="selection-buttons">
          <button id="lang-en">English</button>
          <button id="lang-ko">í•œêµ­ì–´</button>
        </div>
      </div>
    </div>

    <!-- Character Selection Modal -->
    <div id="character-select-modal" class="modal">
      <div class="modal-content-small">
        <h2 id="character-select-title"></h2>
        <div id="character-buttons" class="selection-buttons">
          <button id="select-socrates"></button>
          <button id="select-plato"></button>
        </div>
      </div>
    </div>

    <div id="character-selection-screen" class="hidden">
      <div class="player-display-area" id="p1-display">
        <div class="portrait-area" id="p1-portrait"></div>
        <div class="philosopher-name" id="p1-philosopher-name"></div>
        <div class="skill-area" id="p1-skill">
          <h3 class="skill-title">ê³ ìœ  ëŠ¥ë ¥</h3>
          <p id="p1-skill-desc"></p>
        </div>
        <div class="ready-overlay" id="p1-ready-overlay">READY</div>
      </div>

      <div class="shared-selection-area">
        <div class="char-grid" id="shared-char-grid"></div>
        <button id="confirm-selection-btn" disabled>í™• ì¸</button>
      </div>

      <div class="player-display-area" id="p2-display">
        <div class="portrait-area" id="p2-portrait"></div>
        <div class="philosopher-name" id="p2-philosopher-name"></div>
        <div class="skill-area" id="p2-skill">
          <h3 class="skill-title">ê³ ìœ  ëŠ¥ë ¥</h3>
          <p id="p2-skill-desc"></p>
        </div>
        <div class="ready-overlay" id="p2-ready-overlay">READY</div>
      </div>
    </div>

    <div id="turn-order-modal" class="modal">
      <div class="modal-content-small">
        <h2 id="turn-order-title">ëŒ€ì „ ìˆœì„œë¥¼ ì„ íƒí•˜ì„¸ìš”</h2>
        <div id="turn-order-buttons" class="selection-buttons">
          <button id="select-first-player">ì„ ê³µ</button>
          <button id="select-second-player">í›„ê³µ</button>
        </div>
      </div>
    </div>

    <div class="container" id="container">
      <header>
        <h1 id="main-title">LOGOS</h1>
      </header>

      <div id="info-box">
        <div class="header-buttons-left">
          <button id="new-game-btn"></button>
        </div>
        <div class="round-display" id="round-display"></div>
        <div class="header-buttons-right">
          <button id="main-menu-btn"></button>
          <button id="fullscreen-btn"></button>
        </div>
      </div>

      <div class="player-area" id="player-a-area">
        <div class="player-title-box">
          <h3 id="player-a-title"></h3>
        </div>
        <div class="hand" id="player-a-hand"></div>
        <button class="eureka-btn" id="eureka-a"></button>
      </div>

      <div class="game-board">
        <div class="main-center-bg">
          <div class="main-center-buttons">
            <div class="mode-selector">
              <button id="vs-player-btn"></button>
              <button id="vs-ai-btn"></button>
            </div>
            <button id="tutorial-btn"></button>
          </div>
        </div>
        <div id="current-proposition">
          <h3 id="current-proposition-title"></h3>
          <div id="proposition-display"></div>
          <div id="proposition-controls">
            <button id="complete-btn"></button>
            <button id="undo-btn"></button>
            <button id="end-turn-btn"></button>
          </div>
        </div>
        <div id="true-propositions">
          <h3 id="true-propositions-title"></h3>
          <ul id="true-list"></ul>
        </div>
        <div id="thinking-time-controls">
          <h2 id="thinking-time-title"></h2>
          <p id="thinking-time-desc"></p>
          <button id="end-thinking-time-btn"></button>
        </div>
      </div>

      <div class="player-area" id="player-b-area">
        <div class="player-title-box">
          <h3 id="player-b-title"></h3>
        </div>
        <div class="hand" id="player-b-hand"></div>
        <button class="eureka-btn" id="eureka-b"></button>
      </div>

      <div class="status-bar" id="status"></div>
    </div>

    <div id="character-selection-screen" class="hidden">
      <div class="player-display-area" id="p1-display">
        <div class="portrait-area" id="p1-portrait"></div>
        <div class="skill-area" id="p1-skill">
          <h3>ìŠ¤í‚¬ ì„¤ëª…</h3>
          <p id="p1-skill-desc"></p>
        </div>
      </div>

      <div class="shared-selection-area">
        <div class="char-grid" id="shared-char-grid"></div>
        <button id="confirm-selection-btn" disabled>í™•ì¸</button>
      </div>

      <div class="player-display-area" id="p2-display">
        <div class="portrait-area" id="p2-portrait"></div>
        <div class="skill-area" id="p2-skill">
          <h3>ìŠ¤í‚¬ ì„¤ëª…</h3>
          <p id="p2-skill-desc"></p>
        </div>
      </div>
    </div>

    <!-- Main Eureka Modal -->
    <div id="eureka-modal" class="modal">
      <div class="modal-content">
        <span class="close-button" id="close-eureka-modal-btn">&times;</span>
        <h2 id="eureka-title"></h2>
        <div id="workbench-controls">
          <select id="inference-rule-select"></select>
          <button id="apply-rule-btn"></button>
          <button id="add-assumption-btn"></button>
          <button id="cancel-assumption-btn"></button>
        </div>
        <div class="proof-container">
          <div class="premise-selection">
            <h3 id="premise-selection-title"></h3>
            <ul id="premise-list"></ul>
          </div>
        </div>
        <button id="modal-confirm-btn"></button>
      </div>
    </div>

    <!-- Tutorial Modal (previously Rules Modal) -->
    <div id="tutorial-modal" class="modal">
      <div class="modal-content">
        <span class="close-button" id="close-tutorial-modal-btn">&times;</span>
        <h2 id="tutorial-modal-title"></h2>
        <div id="tutorial-content">
          <!-- Tutorial content will be generated here by JavaScript -->
        </div>
      </div>
    </div>

    <!-- Custom Alert Modal -->
    <div id="alert-modal" class="modal">
      <div class="modal-content-small">
        <p id="alert-message"></p>
        <div class="modal-buttons">
          <button id="alert-ok-btn"></button>
        </div>
      </div>
    </div>

    <!-- Custom Prompt Modal -->
    <div id="prompt-modal" class="modal">
      <div class="modal-content-small">
        <p id="prompt-message"></p>
        <input type="text" id="prompt-input" />
        <div class="modal-buttons">
          <button id="prompt-cancel-btn"></button>
          <button id="prompt-confirm-btn"></button>
        </div>
      </div>
    </div>

    <!-- Tutorial Guide UI -->
    <div id="tutorial-guide" class="hidden">
      <p id="tutorial-text"></p>
      <button id="tutorial-next-btn"></button>
    </div>

    <div id="game-over-modal" class="modal">
      <div class="game-over-content">
        <button class="close-button" onclick="closeGameOverModal()">X</button>

        <img src="assets/endgame.png" alt="ê²Œì„ ì¢…ë£Œ" class="game-over-image" />

        <div id="overlay-container">
          <img
            id="socrates-bird-overlay"
            src="assets/so_bird.png"
            class="overlay-image hidden"
          />
          <img
            id="socrates-dog-overlay"
            src="assets/so_dog.png"
            class="overlay-image hidden"
          />
          <img
            id="socrates-fish-overlay"
            src="assets/so_fish.png"
            class="overlay-image hidden"
          />
          <img
            id="socrates-wise-overlay"
            src="assets/so_wise.png"
            class="overlay-image hidden"
          />
          <img
            id="socrates-foolish-overlay"
            src="assets/so_foolish.png"
            class="overlay-image hidden"
          />
          <img
            id="socrates-good-overlay"
            src="assets/so_good.png"
            class="overlay-image hidden"
          />
          <img
            id="socrates-evil-overlay"
            src="assets/so_evil.png"
            class="overlay-image hidden"
          />
          <img
            id="socrates-win-overlay"
            src="assets/so_wins.png"
            class="overlay-image hidden"
          />

          <img
            id="plato-win-overlay"
            src="assets/pl_wins.png"
            class="overlay-image hidden"
          />
          <img
            id="plato-bird-overlay"
            src="assets/pl_bird.png"
            class="overlay-image hidden"
          />
          <img
            id="plato-fish-overlay"
            src="assets/pl_fish.png"
            class="overlay-image hidden"
          />
          <img
            id="plato-dog-overlay"
            src="assets/pl_dog.png"
            class="overlay-image hidden"
          />
          <img
            id="plato-wise-overlay"
            src="assets/pl_wise.png"
            class="overlay-image hidden"
          />
          <img
            id="plato-foolish-overlay"
            src="assets/pl_foolish.png"
            class="overlay-image hidden"
          />
          <img
            id="plato-good-overlay"
            src="assets/pl_good.png"
            class="overlay-image hidden"
          />
          <img
            id="plato-evil-overlay"
            src="assets/pl_evil.png"
            class="overlay-image hidden"
          />
        </div>
      </div>
    </div>

    <script>
      // --- MULTILINGUAL TEXT DATA ---
      const TEXTS = {
        ko: {
          langCode: "ko",
          ui: {
            title: "LOGOS",
            tutorialButton: "íŠœí† ë¦¬ì–¼",
            endTutorialButton: "íŠœí† ë¦¬ì–¼ ì¢…ë£Œ",
            newGameButton: "ìƒˆ ê²Œì„",
            vsAIButton: "1ì¸ ëŒ€ì „",
            vsPlayerButton: "2ì¸ ëŒ€ì „",
            fullscreenButton: "ì „ì²´í™”ë©´",
            playerAName: "ì†Œí¬ë¼í…ŒìŠ¤",
            playerAColor: "âšªï¸ ë°±",
            playerBName: "í”Œë¼í†¤",
            playerBColor: "âš«ï¸ í‘",
            currentPropositionTitle: "í˜„ì¬ ëª…ì œ",
            completeButton: "ëª…ì œ ì™„ì„±",
            undoButton: "ë˜ëŒë¦¬ê¸°",
            endTurnButton: "í„´ ì¢…ë£Œ",
            truePropositionsTitle: "ì°¸ ëª…ì œ ëª©ë¡",
            eurekaButton: "ìœ ë ˆì¹´!",
            addTheoremButton: "ì •ë¦¬ ì¶”ê°€ â•",
            roundDisplay: "ì œ {round} ë¼ìš´ë“œ",
            axiomTitle: "ê¸°ë³¸ ê³µë¦¬ (í¼ì³ë³´ê¸°)",
            statusTurn: "ì˜ í„´ì…ë‹ˆë‹¤.",
            statusAITurn: "AIê°€ ìƒê° ì¤‘ì…ë‹ˆë‹¤...",
            thinkingTimeStatus: "ì‚¬ìœ  ì‹œê°„ì…ë‹ˆë‹¤. ìƒˆë¡œìš´ ì •ë¦¬ë¥¼ ë„ì¶œí•˜ì„¸ìš”.",
            thinkingTimeTitle: "ì‚¬ìœ (æ€æƒŸ) ì‹œê°„",
            thinkingTimeDesc:
              "ìƒˆë¡œìš´ ì •ë¦¬ë¥¼ ë„ì¶œí•˜ê³  'ì •ë¦¬ ì¶”ê°€' ë²„íŠ¼ìœ¼ë¡œ ëª©ë¡ì— ë°˜ì˜í•˜ì„¸ìš”.<br>ì¤€ë¹„ë˜ë©´ ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ ë‹¤ìŒ ë¼ìš´ë“œë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.",
            endThinkingTimeButton: "ì‚¬ìœ  ì‹œê°„ ì¢…ë£Œ & ë‹¤ìŒ ë¼ìš´ë“œ ì‹œì‘",
            victoryMessage: "í”Œë ˆì´ì–´ì˜ ìŠ¹ë¦¬!",
            victorySubMessage: "ë…¼ë¦¬ì ì¸ ì¦ëª…ì— ì„±ê³µí–ˆìŠµë‹ˆë‹¤!",
            okButton: "í™•ì¸",
            cancelButton: "ì·¨ì†Œ",
            nextButton: "ë‹¤ìŒ",
            cancelAssumptionButton: "ê°€ì • ì·¨ì†Œ",
          },
          modals: {
            characterSelectTitle: "ì² í•™ì ì„ íƒ",
            selectSocrates: "ì†Œí¬ë¼í…ŒìŠ¤ (ë°±) âšªï¸",
            selectPlato: "í”Œë¼í†¤ (í‘) âš«ï¸",
            eurekaTitleVictory: "ìœ ë ˆì¹´! ë…¼ì¦ êµ¬ì„±",
            eurekaTitleTheorem: "ì‚¬ìœ  ì‹œê°„: ì •ë¦¬(Theorem) êµ¬ì„±",
            premiseSelectionTitle: "ì‚¬ìš© ê°€ëŠ¥í•œ ì „ì œ ëª©ë¡",
            applyRuleButton: "ê·œì¹™ ì ìš©",
            addAssumptionButton: "ê°€ì •í•˜ê¸°",
            confirmVictoryButton: "ì´ ë…¼ì¦ìœ¼ë¡œ ìŠ¹ë¦¬ ì¦ëª…!",
            confirmTheoremButton: "ì„ íƒí•œ ì •ë¦¬ë“¤ì„ ì°¸ ëª©ë¡ì— ì¶”ê°€ â•",
            tutorialTitle: "LOGOS íŠœí† ë¦¬ì–¼",
            promptInputPlaceholder: "ëª…ì œë¥¼ ì…ë ¥í•˜ì„¸ìš”...",
          },
          tutorial: [
            // Stage 1 (Index 0)
            [
              "LOGOSì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!",
              "ì‹œì‘í•˜ê¸° ì „ì—, ëª‡ ê°€ì§€ í•µì‹¬ ê·œì¹™ì„ ì•Œë ¤ë“œë¦´ê²Œìš”.",
              "<strong>ìŠ¹ë¦¬ ì¡°ê±´:</strong> ë§¤ ê²Œì„ ì‹œì‘ ì‹œ, ê°ì ê³ ìœ í•˜ê³  ë¬´ì‘ìœ„ë¡œ ì •í•´ì§„ <strong>ìŠ¹ë¦¬ ì¡°ê±´</strong>ì„ ë°›ìŠµë‹ˆë‹¤.<br><br><strong>ìœ ë ˆì¹´!</strong>ë¥¼ ì„ ì–¸í•˜ì—¬ <strong>ìì‹ ì˜ ìŠ¹ë¦¬</strong>ë¥¼ ì¦ëª…í•˜ê±°ë‚˜ <strong>ìƒëŒ€ì˜ íŒ¨ë°°</strong>ë¥¼ ì¦ëª…í•˜ë©´ ì´ê¹ë‹ˆë‹¤.<br><br>ì˜ˆë¥¼ ë“¤ì–´, ë‹¹ì‹ ì˜ ì² í•™ìê°€ ì†Œí¬ë¼í…ŒìŠ¤ë¼ë©´<br><strong>ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤</strong>ë‚˜ <strong>í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤ ëŠ” ê±°ì§“ì´ë‹¤</strong>ë¥¼ ì¦ëª…í•˜ë©´ ë©ë‹ˆë‹¤.",
              "<strong>ì²« í„´:</strong> ì²« ë¼ìš´ë“œëŠ” ì–¸ì œë‚˜ ì†Œí¬ë¼í…ŒìŠ¤(ë°±)ê°€ ë¨¼ì € ì‹œì‘í•©ë‹ˆë‹¤.<br><br><strong>ì„ ê³µ êµëŒ€:</strong> ë¼ìš´ë“œê°€ ë°”ë€” ë•Œë§ˆë‹¤ ì„ ê³µí•˜ëŠ” í”Œë ˆì´ì–´ê°€ êµëŒ€ë©ë‹ˆë‹¤.",
              "ê·¸ëŸ¼, ê°€ì¥ ê¸°ë³¸ì¸ <strong>ëª…ì œ</strong>ë¥¼ ë§Œë“œëŠ” ë²•ë¶€í„° ë°°ì›Œë³´ì£ .",
              "ì´ê³³ì´ ë‹¹ì‹ ì˜ <strong>íŒ¨</strong>ì…ë‹ˆë‹¤. ì—¬ëŸ¬ ë‹¨ì–´ ì¹´ë“œê°€ ìˆì£ .",
              "ì¹´ë“œë¥¼ ì´ê³³ìœ¼ë¡œ ì˜®ê²¨ <strong>ëª…ì œ</strong>ë¥¼ ë§Œë“¤ê²Œ ë©ë‹ˆë‹¤.",
              "ì¹´ë“œë¥¼ í´ë¦­í•´ì„œ <strong>í˜„ì¬ ëª…ì œ</strong> ì˜ì—­ìœ¼ë¡œ ì˜®ê²¨ë³´ì„¸ìš”.",
              "ì•„ì£¼ ì¢‹ìŠµë‹ˆë‹¤! <strong>ì†Œí¬ë¼í…ŒìŠ¤ëŠ”</strong> ê°™ì€ <strong>ê³ ìœ  ëª…ì‚¬</strong>ëŠ” ë°”ë¡œ ëª…ì œë¥¼ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
              "í•˜ì§€ë§Œ <strong>ê°œëŠ”</strong>, <strong>ìƒˆëŠ”</strong>, <strong>ë¬¼ê³ ê¸°ëŠ”</strong> ê°™ì€ <strong>ê°œì²´</strong> ì¹´ë“œëŠ”, ë°˜ë“œì‹œ <strong>ëª¨ë“ </strong>ì´ë‚˜ <strong>ì–´ë–¤</strong>ê³¼ ê°™ì€ <strong>ì–‘í™”ì‚¬</strong> ì¹´ë“œ ë’¤ì—ë§Œ ë†“ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ì ì„ ê¼­ ê¸°ì–µí•´ì£¼ì„¸ìš”!",
              "ì, ì´ì œ í„´ì„ ë§ˆì³ë³¼ê¹Œìš”? LOGOSì—ì„œëŠ” ë°˜ë“œì‹œ í•œ í„´ì— í•œ ì¥ì˜ ì¹´ë“œë¥¼ ë‚´ì•¼ í•©ë‹ˆë‹¤.",
              "<strong>í„´ ì¢…ë£Œ</strong> ë²„íŠ¼ì„ ëˆŒëŸ¬ ìƒëŒ€ì—ê²Œ í„´ì„ ë„˜ê²¨ì£¼ì„¸ìš”.",
              "ê·œì¹™ì„ ì˜ ì´í•´í•˜ì…¨êµ°ìš”!<br><br>ì´ì œ ìƒëŒ€ë°©ì´ ì™„ì„±í•œ ëª…ì œì— ì–´ë–»ê²Œ ëŒ€ì‘í•˜ëŠ”ì§€ ë°°ì›Œë³´ê² ìŠµë‹ˆë‹¤.",
            ],
            // Stage 2 (Index 1)
            [
              "ìƒëŒ€ë°©ì˜ í„´ì´ ëë‚¬ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë‹¹ì‹ ì˜ í„´ì…ë‹ˆë‹¤.",
              "ìƒëŒ€ë°©ì´ ë§Œë“  ëª…ì œê°€ ë¬¸ë²•ì ìœ¼ë¡œ ì™„ì„±ë˜ì—ˆë„¤ìš”. ì´ë•Œ ì—¬ëŸ¬ í–‰ë™ì„ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
              "<strong>ì²« ë²ˆì§¸ ì„ íƒ: ëª…ì œ ì™„ì„±.</strong> ìƒëŒ€ë°©ì˜ ì£¼ì¥ì„ <strong>ì°¸</strong>ìœ¼ë¡œ ì¸ì •í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ì§€ê¸ˆì€ ì•„ë¬´ëŸ° ëª¨ìˆœì´ ì—†ìœ¼ë‹ˆ, <strong>ëª…ì œ ì™„ì„±</strong> ë²„íŠ¼ì„ ëˆŒëŸ¬ <strong>ì°¸ ëª…ì œ ëª©ë¡</strong>ì— ì¶”ê°€í•´ ë´…ì‹œë‹¤.",
              "í›Œë¥­í•©ë‹ˆë‹¤! í•˜ì§€ë§Œ ëª…ì œê°€ ì¶”ê°€ë˜ë ¤ë©´ ë‘ ê°€ì§€ ì¤‘ìš”í•œ ì¡°ê±´ì´ ìˆìŠµë‹ˆë‹¤.",
              "ì²«ì§¸, ì™„ì „íˆ ê°™ì€ ëª…ì œê°€ ì´ë¯¸ ì¡´ì¬í•œë‹¤ë©´ ë‹¤ì‹œ ì¶”ê°€í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
              "ë‘˜ì§¸, ê¸°ì¡´ì˜ ì§„ë¦¬ì™€ ëª¨ìˆœë˜ëŠ” ëª…ì œëŠ” ì¶”ê°€í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
              "ì´ì œ ëª…ì œ ì™„ì„±ì˜ ê·œì¹™ì„ ì™„ì „íˆ ì´í•´í•˜ì…¨ìŠµë‹ˆë‹¤.<br>ëª…ì œë¥¼ ì™„ì„±í•˜ëŠ” ëŒ€ì‹ , ë‹¤ë¥¸ ì„ íƒë„ ê°€ëŠ¥í•©ë‹ˆë‹¤.",
              "<strong>ë‘ ë²ˆì§¸ ì„ íƒ: í™•ì¥í•˜ê¸°.</strong> <strong>ê·¸ë¦¬ê³ </strong>, <strong>ë˜ëŠ”</strong>, <strong>ë¼ë©´</strong> ê°™ì€ <strong>ì—°ê²°ì‚¬</strong> ì¹´ë“œë¥¼ ì¶”ê°€í•˜ì—¬ ëª…ì œë¥¼ ë” ë³µì¡í•˜ê²Œ ë§Œë“¤ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ë‹¨, ì—°ê²°ì‚¬ëŠ” í•˜ë‚˜ì˜ ëª…ì œì— í•œ ë²ˆë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤ëŠ” ì ì„ ê¸°ì–µí•˜ì„¸ìš”.",
              "<strong>ì„¸ ë²ˆì§¸ ì„ íƒ: ë¶€ì •í•˜ê¸°.</strong> ìì‹ ì—ê²Œ ë¶ˆë¦¬í•œ ëª…ì œë¼ë©´, ì†íŒ¨ì˜ <strong>ëŠ” ê±°ì§“ì´ë‹¤</strong> ì¹´ë“œë¥¼ ì¶”ê°€í•˜ì—¬ ëª…ì œë¥¼ ë¶€ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.<br>í•˜ì§€ë§Œ ì¡°ì‹¬í•˜ì„¸ìš”! ë§Œì•½ ìƒëŒ€ë°©ë„ ë¶€ì • ì¹´ë“œë¥¼ ë‚¸ë‹¤ë©´, <strong>ì´ì¤‘ ë¶€ì •</strong> ê·œì¹™ì— ë”°ë¼ ë‹¹ì‹ ì˜ ë¶€ì •ì´ ë°”ë¡œ ë¬´íš¨í™”ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.<br><br>ë˜í•œ, ì—°ê²°ì‚¬ë¡œ ì—°ê²°ëœ ë¬¸ì¥ì— <strong>ëŠ” ê±°ì§“ì´ë‹¤</strong>ê°€ ë¶™ìœ¼ë©´, ë¬¸ì¥ ì „ì²´ê°€ ì•„ë‹Œ ì—°ê²°ì‚¬ê°€ ê²°í•©ëœ ìµœì†Œ ë‹¨ìœ„ ëª…ì œë§Œ ë¶€ì •ë©ë‹ˆë‹¤.<br><br>ì˜ˆë¥¼ ë“¤ì–´, <strong>ì–´ë–¤ ê°œëŠ” ì„ í•˜ë‹¤ ê·¸ë¦¬ê³  ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤</strong>ì—ì„œ ë¶€ì •ë˜ëŠ” ë¶€ë¶„ì€ <strong>ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì•…í•˜ë‹¤</strong> ë¿ì…ë‹ˆë‹¤.",
              "ì´ì œ ìƒëŒ€ì˜ ëª…ì œì— ëŒ€ì‘í•˜ëŠ” ì—¬ëŸ¬ ë°©ë²•ì„ ë°°ì› ìŠµë‹ˆë‹¤. ë‹¤ìŒìœ¼ë¡œ, ìš°ë¦¬ê°€ ë…¼ì¦ì˜ ê¸°ë°˜ìœ¼ë¡œ ì‚¼ì„ ìˆ˜ ìˆëŠ” <strong>ê¸°ë³¸ ê³µë¦¬</strong>ì— ëŒ€í•´ ì•Œì•„ë´…ì‹œë‹¤.",
            ],
            // Stage 3 (Index 2)
            [
              "ì°¸ ëª…ì œ ëª©ë¡ì—ëŠ” ìš°ë¦¬ê°€ ë§Œë“  ëª…ì œë¿ë§Œ ì•„ë‹ˆë¼, ëª¨ë“  ë…¼ì¦ì˜ ê¸°ë°˜ì´ ë˜ëŠ” <strong>ê¸°ë³¸ ê³µë¦¬</strong>ê°€ ë“¤ì–´ìˆìŠµë‹ˆë‹¤.",
              "ì´ í•­ëª©ì„ í´ë¦­í•´ì„œ ì–´ë–¤ ê³µë¦¬ë“¤ì´ ìˆëŠ”ì§€ í™•ì¸í•´ ë³´ì„¸ìš”.",
              "ê³µë¦¬ëŠ” ì¦ëª…í•  í•„ìš” ì—†ì´ ì°¸ìœ¼ë¡œ ë°›ì•„ë“¤ì—¬ì§€ëŠ” ëª…ì œë“¤ì…ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ 'ëª¨ë“  ê°œëŠ” ê°œì´ë‹¤' ì™€ ê°™ì€ ê²ƒë“¤ì´ì£ .",
              "ê³µë¦¬ì— ë”°ë¼, ë™ì¼í•œ ê°œì²´ê°€ 'ì„ í•˜ë‹¤'ì™€ 'ì•…í•˜ë‹¤'ì²˜ëŸ¼ <strong>ë‘ ê°€ì§€ ìƒë°˜ëœ ì†ì„±ì„ ë™ì‹œì— ê°€ì§ˆ ìˆ˜ ì—†ìŠµë‹ˆë‹¤</strong>.",
              "ë…¼ì¦ì„ êµ¬ì„±í•  ë•Œ, ì´ ê³µë¦¬ë“¤ì„ ì¤‘ìš”í•œ ì „ì œë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
              "ì´ì œ ê¸°ë³¸ì ì¸ ì§„ë¦¬ë“¤ì„ í™•ì¸í–ˆìœ¼ë‹ˆ, ì¹´ë“œë¥¼ ë‚¼ ìˆ˜ ì—†ì„ ë•Œ ì–´ë–¤ ì¼ì´ ì¼ì–´ë‚˜ëŠ”ì§€ ì•Œì•„ë´…ì‹œë‹¤.",
            ],
            // Stage 4 (Index 3)
            [
              "í„´ì´ ëŒì•„ì˜¨ í”Œë ˆì´ì–´ê°€ í•  ìˆ˜ ìˆëŠ” í–‰ë™ì´ ì—†ë‹¤ë©´ ë¼ìš´ë“œê°€ ì¢…ë£Œë˜ê³  <strong>ì‚¬ìœ  ì‹œê°„</strong>ì´ ì‹œì‘ë©ë‹ˆë‹¤.",
              "ì‚¬ìœ  ì‹œê°„ì—ëŠ” <strong>ìœ ë ˆì¹´!</strong> ë²„íŠ¼ì´ <strong>ì •ë¦¬ ì¶”ê°€</strong> ë²„íŠ¼ìœ¼ë¡œ ë°”ë€ë‹ˆë‹¤.",
              "ì´ ë²„íŠ¼ì„ ëˆŒëŸ¬, ì´ë¯¸ ì¦ëª…ëœ ì§„ë¦¬ë“¤ì„ ë°”íƒ•ìœ¼ë¡œ ìƒˆë¡œìš´ <strong>ì •ë¦¬</strong>ë¥¼ ë§Œë“¤ì–´ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë²„íŠ¼ì„ ëˆŒëŸ¬ë³´ì„¸ìš”.",
              "ë…¼ì¦ êµ¬ì„±ì°½ì´ ì—´ë ¸ìŠµë‹ˆë‹¤. ì´ì œ <strong>ë³´í¸ ì ìš©</strong> ê·œì¹™ì„ ì‚¬ìš©í•´ ìƒˆë¡œìš´ ì •ë¦¬ë¥¼ ë§Œë“¤ì–´ ë´…ì‹œë‹¤.",
              "ì „ì œ ëª©ë¡ì—ì„œ <strong>ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ê°œì´ë‹¤</strong>ì™€ <strong>ëª¨ë“  ê°œëŠ” ì§€í˜œë¡­ë‹¤</strong>ë¥¼ ì„ íƒí•˜ì„¸ìš”.",
              "ì¶”ë¡  ê·œì¹™ì—ì„œ <strong>ë³´í¸ ì ìš©</strong>ì„ ì„ íƒí•˜ê³ , <strong>ê·œì¹™ ì ìš©</strong> ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.",
              "ì¢‹ìŠµë‹ˆë‹¤! <strong>ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì§€í˜œë¡­ë‹¤</strong>ë¼ëŠ” ìƒˆë¡œìš´ ì •ë¦¬ê°€ ë„ì¶œë˜ì—ˆìŠµë‹ˆë‹¤.<br><br>ì´ì œ ì´ ì •ë¦¬ë¥¼ ì„ íƒí•˜ê³  <strong>ì„ íƒí•œ ì •ë¦¬ë“¤ì„ ì°¸ ëª©ë¡ì— ì¶”ê°€</strong> ë²„íŠ¼ì„ ëˆŒëŸ¬ ì¦ëª…ì„ ë§ˆì¹©ì‹œë‹¤.",
              "ìƒˆë¡œìš´ ì •ë¦¬ê°€ <strong>ì°¸ ëª…ì œ ëª©ë¡</strong>ì— ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤!<br><br>ì´ì œ <strong>ì‚¬ìœ  ì‹œê°„ ì¢…ë£Œ</strong> ë²„íŠ¼ì„ ëˆŒëŸ¬ ë‹¤ìŒ ë¼ìš´ë“œë¥¼ ì‹œì‘í•˜ì„¸ìš”.<br>ë¼ìš´ë“œê°€ ìƒˆë¡œ ì‹œì‘ë˜ë©´ ëƒˆë˜ ëª¨ë“  ì¹´ë“œë¥¼ ëŒë ¤ë°›ìœ¼ë©°, ì°¸ ëª…ì œ ëª©ë¡ì€ ê·¸ëŒ€ë¡œ ìœ ì§€ë©ë‹ˆë‹¤.",
            ],
            // Stage 5 (Index 4) - UPDATED & EXPANDED
            [
              "ì§€ê¸ˆê¹Œì§€ ê²Œì„ì˜ íë¦„ì„ ë°°ì› ìŠµë‹ˆë‹¤. ë§ˆì§€ë§‰ìœ¼ë¡œ, ìŠ¹ë¦¬ë¥¼ ìœ„í•´ ê°€ì¥ ì¤‘ìš”í•œ <strong>ì¶”ë¡  ê·œì¹™</strong>ë“¤ì„ í•˜ë‚˜ì”© ìµí˜€ë´…ì‹œë‹¤. <strong>ìœ ë ˆì¹´!</strong> ë²„íŠ¼ì„ ëˆŒëŸ¬ ë…¼ì¦ êµ¬ì„±ì°½ì„ ì—¬ì„¸ìš”.",
              // 1. Modus Ponens
              "ë¨¼ì € <strong>ì „ê±´ ê¸ì •</strong>ì…ë‹ˆë‹¤. (P, Pâ†’Q)ì´ë©´ Që¥¼ ë„ì¶œí•˜ëŠ”, ê°€ì¥ ì§ê´€ì ì¸ ê·œì¹™ì´ì£ .",
              "ì „ì œ ëª©ë¡ì—ì„œ <strong>ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤</strong>ì™€ <strong>ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤ ë¼ë©´ ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤</strong>ë¥¼ ì„ íƒí•˜ì„¸ìš”.",
              "ê·œì¹™ ëª©ë¡ì—ì„œ <strong>ì „ê±´ ê¸ì •</strong>ì„ ì„ íƒí•˜ê³  <strong>ê·œì¹™ ì ìš©</strong> ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.",
              // 2. Modus Tollens
              "ì¢‹ìŠµë‹ˆë‹¤. <strong>ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤</strong>ëŠ” ê²°ë¡ ì´ ë„ì¶œë˜ì—ˆìŠµë‹ˆë‹¤. ì´ë²ˆì—ëŠ” <strong>í›„ê±´ ë¶€ì •</strong>ì„ ì—°ìŠµí•´ ë´…ì‹œë‹¤.",
              "ì „ì œ ëª©ë¡ì—ì„œ <strong>í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤</strong>ì™€ <strong>í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤</strong>ë¥¼ ì„ íƒí•˜ì„¸ìš”.",
              "ê·œì¹™ ëª©ë¡ì—ì„œ <strong>í›„ê±´ ë¶€ì •</strong>ì„ ì„ íƒí•˜ê³  <strong>ê·œì¹™ ì ìš©</strong> ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.",
              // 3. Disjunctive Syllogism
              "í›Œë¥­í•©ë‹ˆë‹¤! <strong>í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤ ëŠ” ê±°ì§“ì´ë‹¤</strong>ë¼ëŠ” ê²°ë¡ ì´ ë‚˜ì™”êµ°ìš”. ë‹¤ìŒì€ <strong>ì„ ì–¸ì  ì‚¼ë‹¨ë…¼ë²•</strong>ì…ë‹ˆë‹¤.",
              "ì „ì œ ëª©ë¡ì—ì„œ <strong>ì–´ë–¤ ìƒˆëŠ” ë¬¼ê³ ê¸°ì´ë‹¤ ë˜ëŠ” ì–´ë–¤ ìƒˆëŠ” ìƒˆì´ë‹¤</strong>ì™€ <strong>ì–´ë–¤ ìƒˆëŠ” ë¬¼ê³ ê¸°ì´ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤</strong>ë¥¼ ì„ íƒí•˜ì„¸ìš”. <strong>ë˜ëŠ”</strong>ìœ¼ë¡œ ì—°ê²°ëœ ê²ƒ ì¤‘ í•˜ë‚˜ê°€ ê±°ì§“ì´ë©´, ë‚˜ë¨¸ì§€ëŠ” ì°¸ì´ê² ì£ ?",
              "ê·œì¹™ ëª©ë¡ì—ì„œ <strong>ì„ ì–¸ì  ì‚¼ë‹¨ë…¼ë²•</strong>ì„ ì„ íƒí•˜ê³  <strong>ê·œì¹™ ì ìš©</strong> ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.",
              // 4. Hypothetical Syllogism
              "<strong>ì–´ë–¤ ìƒˆëŠ” ìƒˆì´ë‹¤'</strong>ê°€ ë„ì¶œë˜ì—ˆìŠµë‹ˆë‹¤. ì´ë²ˆì—” <strong>ê°€ì„¤ì  ì‚¼ë‹¨ë…¼ë²•</strong>ì…ë‹ˆë‹¤. ê¼¬ë¦¬ë¬¼ê¸°ì²˜ëŸ¼ ì´ì–´ì§€ëŠ” ë‘ ëª…ì œë¥¼ í•˜ë‚˜ë¡œ í•©ì³ë´…ì‹œë‹¤.",
              "ì „ì œ ëª©ë¡ì—ì„œ <strong>í”Œë¼í†¤ì€ ê°œì´ë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ì„ í•˜ë‹¤</strong>ì™€ <strong>í”Œë¼í†¤ì€ ì„ í•˜ë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤</strong>ë¥¼ ì„ íƒí•˜ì„¸ìš”.",
              "ê·œì¹™ ëª©ë¡ì—ì„œ <strong>ê°€ì„¤ì  ì‚¼ë‹¨ë…¼ë²•</strong>ì„ ì„ íƒí•˜ê³  <strong>ê·œì¹™ ì ìš©</strong> ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.",
              // 5. Conjunction Elimination (Simplification)
              "ì¢‹ìŠµë‹ˆë‹¤! <strong>í”Œë¼í†¤ì€ ê°œì´ë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤</strong>ë¼ëŠ” ë” ê°„ê²°í•œ ëª…ì œê°€ ë§Œë“¤ì–´ì¡ŒìŠµë‹ˆë‹¤. ë‹¤ìŒì€ <strong>ë‹¨ìˆœí™”</strong> ê·œì¹™ì…ë‹ˆë‹¤.",
              "<strong>ê·¸ë¦¬ê³ </strong>ë¡œ ì—°ê²°ëœ ëª…ì œëŠ” ê°ê°ì´ ì°¸ì…ë‹ˆë‹¤. ì „ì œ ëª©ë¡ì—ì„œ <strong>ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì§€í˜œë¡­ë‹¤ ê·¸ë¦¬ê³  í”Œë¼í†¤ì€ ì–´ë¦¬ì„ë‹¤</strong>ë¥¼ ì„ íƒí•˜ì„¸ìš”.",
              "ê·œì¹™ ëª©ë¡ì—ì„œ <strong>ë‹¨ìˆœí™”</strong>ë¥¼ ì„ íƒí•˜ê³  <strong>ê·œì¹™ ì ìš©</strong> ë²„íŠ¼ì„ ëˆŒëŸ¬ë³´ì„¸ìš”. ë‘ ê°œì˜ ëª…ì œê°€ í•œ ë²ˆì— ë„ì¶œë  ê²ë‹ˆë‹¤.",
              // 6. Double Negation Elimination
              "ë³´ì‹œë‹¤ì‹œí”¼ ë‘ ëª…ì œê°€ ê°ê° ë¶„ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ì œ <strong>ì´ì¤‘ ë¶€ì • ì œê±°</strong> ê·œì¹™ì„ ë°°ì›Œë´…ì‹œë‹¤. ë¶€ì •ì„ ë‘ ë²ˆ í•˜ë©´ ê¸ì •ì´ ë˜ì£ .",
              "ì „ì œ ëª©ë¡ì—ì„œ <strong>ì–´ë–¤ ë¬¼ê³ ê¸°ëŠ” ì„ í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤</strong>ë¥¼ ì„ íƒí•˜ì„¸ìš”.",
              "ê·œì¹™ ëª©ë¡ì—ì„œ <strong>ì´ì¤‘ ë¶€ì • ì œê±°</strong>ë¥¼ ì„ íƒí•˜ê³  <strong>ê·œì¹™ ì ìš©</strong> ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.",
              // 7. Universal Application
              "ì›ë˜ì˜ ê¸ì • ëª…ì œë¡œ ëŒì•„ì™”ìŠµë‹ˆë‹¤. ë‹¤ìŒì€ <strong>ë³´í¸ ì ìš©</strong> ê·œì¹™ì…ë‹ˆë‹¤. ë³´í¸ì ì¸ ê·œì¹™ì€ ê°œë³„ ì‚¬ë¡€ì—ë„ ì ìš©ë©ë‹ˆë‹¤.",
              "ì „ì œ ëª©ë¡ì—ì„œ <strong>ëª¨ë“  ìƒˆëŠ” ì„ í•˜ë‹¤</strong>ì™€ <strong>í”Œë¼í†¤ì€ ìƒˆì´ë‹¤</strong>ë¥¼ ì„ íƒí•˜ì„¸ìš”.",
              "ê·œì¹™ ëª©ë¡ì—ì„œ <strong>ë³´í¸ ì ìš©</strong>ì„ ì„ íƒí•˜ê³  <strong>ê·œì¹™ ì ìš©</strong> ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.",
              // 8. Existential Instantiation
              "ì •í™•í•©ë‹ˆë‹¤. ë§ˆì§€ë§‰ìœ¼ë¡œ <strong>ì¡´ì¬í™”</strong> ê·œì¹™ì…ë‹ˆë‹¤. <strong>ëª¨ë“ </strong>ì´ ì°¸ì´ë¼ë©´, <strong>ì–´ë–¤</strong> ì¼ë¶€ë„ ë‹¹ì—°íˆ ì°¸ì…ë‹ˆë‹¤.",
              "ì „ì œ ëª©ë¡ì—ì„œ <strong>ëª¨ë“  ê°œëŠ” ì„ í•˜ë‹¤</strong>ë¥¼ ì„ íƒí•˜ì„¸ìš”.",
              "ê·œì¹™ ëª©ë¡ì—ì„œ <strong>ì¡´ì¬í™”</strong>ë¥¼ ì„ íƒí•˜ê³  <strong>ê·œì¹™ ì ìš©</strong> ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.",
              // End of Stage 5
              "í›Œë¥­í•©ë‹ˆë‹¤! ì´ì œ LOGOSì˜ ëª¨ë“  ê¸°ë³¸ ì¶”ë¡  ê·œì¹™ì„ ë§ˆìŠ¤í„°í•˜ì…¨ìŠµë‹ˆë‹¤. ë‹¤ìŒìœ¼ë¡œ ì—¬ëŸ¬ ê°œì˜ ëª…ì œë¥¼ í•œë²ˆì— ì¡°í•©í•˜ëŠ” ê°•ë ¥í•œ ê·œì¹™ì„ ë°°ì›Œë´…ì‹œë‹¤.",
            ],
            // Stage 6 (Index 5)
            [
              "ì´ë²ˆì— ë°°ìš¸ <strong>ê²½ìš° ë…¼ì¦</strong>ì€ ì—¬ëŸ¬ ê°ˆë˜ì˜ ê¸¸ì„ í•˜ë‚˜ì˜ ê²°ë¡ ìœ¼ë¡œ ëª¨ìœ¼ëŠ” ê°•ë ¥í•œ ê·œì¹™ì…ë‹ˆë‹¤.",
              "<strong>í”Œë¼í†¤ì€ ì„ í•˜ê±°ë‚˜ ì•…í•˜ë‹¤</strong>ëŠ” ë‘ ê°€ì§€ ê²½ìš°ê°€ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ°ë° ì–´ëŠ ê²½ìš°ë“  <strong>í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤</strong>ëŠ” ê²°ë¡ ì— ë„ë‹¬í•˜ëŠ”êµ°ìš”. ë¨¼ì €, í•„ìš”í•œ ì „ì œ ì„¸ ê°€ì§€ë¥¼ ëª¨ë‘ ì„ íƒí•´ì£¼ì„¸ìš”.",
              "ì¢‹ìŠµë‹ˆë‹¤. ì´ì œ ì¶”ë¡  ê·œì¹™ ëª©ë¡ì—ì„œ <strong>ê²½ìš° ë…¼ì¦</strong>ì„ ì„ íƒí•˜ê³  <strong>ê·œì¹™ ì ìš©</strong> ë²„íŠ¼ì„ ëˆŒëŸ¬ ê²°ë¡ ì„ ë„ì¶œí•˜ì„¸ìš”.",
              "ì™„ë²½í•©ë‹ˆë‹¤! <strong>í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤</strong>ëŠ” ê²°ë¡ ì´ ë„ì¶œë˜ì—ˆìŠµë‹ˆë‹¤. ê¸°ë³¸ì ì¸ ê·œì¹™ë“¤ì— ìµìˆ™í•´ì§€ì…¨êµ°ìš”. ë‹¤ìŒì€ ë…¼ë¦¬í•™ì˜ ê½ƒì´ë¼ ë¶ˆë¦¬ëŠ” <strong>ê°€ì •</strong>ì„ ì‚¬ìš©í•˜ëŠ” ê·œì¹™ì…ë‹ˆë‹¤.",
            ],
            // Stage 7 (Index 6) - â˜…â˜…â˜… MODIFIED SECTION â˜…â˜…â˜…
            [
              "ë•Œë¡œëŠ” ì¦ëª…ì„ ìœ„í•´ ë¬´ì–¸ê°€ë¥¼ <strong>ë§Œì•½ ~ë¼ë©´</strong> í•˜ê³  ê°€ì •í•´ì•¼ í•  ë•Œê°€ ìˆìŠµë‹ˆë‹¤. ì´ë²ˆì—ëŠ” ë‘ ê°œì˜ ì „ì œë¥¼ ë…¼ë¦¬ì ìœ¼ë¡œ ì—°ê²°í•´ ë´…ì‹œë‹¤.",
              "<strong>ê°€ì •í•˜ê¸°</strong> ë²„íŠ¼ì„ ëˆŒëŸ¬ <strong>ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì§€í˜œë¡­ë‹¤</strong>ë¥¼ ì…ë ¥í•´ ê°€ì •í•´ ë³´ì„¸ìš”.",
              "ì¢‹ìŠµë‹ˆë‹¤. ì´ì œ ê°€ì •ê³¼ ì²« ë²ˆì§¸ ì „ì œì¸ <strong>ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì§€í˜œë¡­ë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ê°œì´ë‹¤</strong>ë¥¼ ì„ íƒí•˜ì„¸ìš”.",
              "<strong>ì „ê±´ ê¸ì •</strong> ê·œì¹™ì„ ì ìš©í•´ ì¤‘ê°„ ê²°ë¡ ì„ ë„ì¶œí•˜ì„¸ìš”.",
              "í›Œë¥­í•©ë‹ˆë‹¤! ì´ì œ ë°©ê¸ˆ ì–»ì€ ì¤‘ê°„ ê²°ë¡ ê³¼ ë‘ ë²ˆì§¸ ì „ì œì¸ <strong>í”Œë¼í†¤ì€ ê°œì´ë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ì„ í•˜ë‹¤</strong>ë¥¼ ì„ íƒí•˜ì„¸ìš”.",
              "ë‹¤ì‹œ <strong>ì „ê±´ ê¸ì •</strong> ê·œì¹™ì„ ì ìš©í•´ ìµœì¢… ê²°ë¡ ì„ ì´ëŒì–´ë‚´ì„¸ìš”.",
              "ì™„ë²½í•©ë‹ˆë‹¤! ì´ì œ <strong>ì¡°ê±´ë¬¸ ë„ì…</strong>ì˜ ë§ˆë²•ì„ ë³¼ ì‹œê°„ì…ë‹ˆë‹¤. ìµœì¢… ê²°ê³¼ë¬¼ì¸ <strong>í”Œë¼í†¤ì€ ì„ í•˜ë‹¤</strong>ë¥¼ ì„ íƒí•˜ì„¸ìš”.",
              "ë§ˆì§€ë§‰ìœ¼ë¡œ, <strong>ì¡°ê±´ë¬¸ ë„ì…</strong> ê·œì¹™ì„ ì ìš©í•˜ì„¸ìš”. ê·¸ëŸ¬ë©´ <strong>ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì§€í˜œë¡­ë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ì„ í•˜ë‹¤</strong>ë¼ëŠ” ìƒˆë¡œìš´ ì •ë¦¬ê°€ ì™„ì„±ë©ë‹ˆë‹¤!",
              "í›Œë¥­í•©ë‹ˆë‹¤! ì´ì œ ê·€ë¥˜ë²•ì— ëŒ€í•´ ì•Œì•„ë´…ì‹œë‹¤.",
            ],
            // Stage 8 (Index 7) - NEWLY ADDED
            [
              "<strong>ê·€ë¥˜ë²•</strong>ì€ ì¦ëª…í•˜ê³  ì‹¶ì€ ê²ƒì˜ <strong>ë°˜ëŒ€</strong>ë¥¼ ê°€ì •í•˜ì—¬ ëª¨ìˆœì„ ì´ëŒì–´ë‚´ëŠ” ë°©ë²•ì…ë‹ˆë‹¤.",
              "ìš°ë¦¬ì˜ ëª©í‘œëŠ” <strong>ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì•…í•˜ë‹¤</strong>ë¥¼ ì¦ëª…í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. <strong>ê°€ì •í•˜ê¸°</strong>ë¡œ ê·¸ ë°˜ëŒ€ì¸ <strong>ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤</strong>ë¥¼ ê°€ì •í•˜ì„¸ìš”.",
              "ê°€ì •ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ì œ ì´ ê°€ì •ì„ ì´ìš©í•´ ëª…ë°±í•œ ëª¨ìˆœ, ì¦‰ 'P'ì™€ '~P' í˜•íƒœì˜ í•œ ìŒì„ ë§Œë“¤ì–´ ë´…ì‹œë‹¤. ë°©ê¸ˆ ë§Œë“  ê°€ì •ê³¼ ë‹¤ë¥¸ ì „ì œë¥¼ ì„ íƒí•˜ê³  <strong>ì „ê±´ ê¸ì •</strong> ê·œì¹™ì„ ì ìš©í•´ ë³´ì„¸ìš”.",
              "ë³´ì„¸ìš”! <strong>í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤</strong>ê°€ ë„ì¶œë˜ì—ˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ì´ë¯¸ ì°¸ì¸ ëª…ì œ ëª©ë¡ì— <strong>í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤</strong>ê°€ ìˆì—ˆì£ . ì´ê²ƒì´ ë°”ë¡œ ëª¨ìˆœì…ë‹ˆë‹¤!",
              "ì´ì œ ëª¨ìˆœë˜ëŠ” ë‘ ëª…ì œë¥¼ ëª¨ë‘ ì„ íƒí•˜ê³  <strong>ê·€ë¥˜ë²•</strong> ê·œì¹™ì„ ì ìš©í•˜ì„¸ìš”.",
              "ìµœì´ˆì˜ ê°€ì •ì´ í‹€ë ¸ë‹¤ëŠ” ê²ƒì´ ì¦ëª…ë˜ì—ˆìŠµë‹ˆë‹¤! ì´ì œ ë§ˆì§€ë§‰ìœ¼ë¡œ <strong>ì´ì¤‘ ë¶€ì • ì œê±°</strong> ê·œì¹™ì„ ì ìš©í•˜ì—¬ ìµœì¢… ê²°ë¡ ì„ ì–»ì–´ë‚´ì„¸ìš”.",
              "ì™„ë²½í•©ë‹ˆë‹¤! ì´ì œ LOGOSì˜ ëª¨ë“  ê²ƒì„ ë°°ìš°ì…¨ìŠµë‹ˆë‹¤. ì§ì ‘ ë…¼ë¦¬ì˜ ëŒ€ê²°ì— ì°¸ì—¬í•˜ì—¬ ë‹¹ì‹ ì˜ ì§€í˜œë¥¼ ì¦ëª…í•´ ë³´ì„¸ìš”!",
            ],
          ],
          inferenceRules: {
            basic: "ê¸°ë³¸ ê·œì¹™",
            modusPonens: "ì „ê±´ ê¸ì • (P, Pâ†’Q âˆ´ Q)",
            modusTollens: "í›„ê±´ ë¶€ì • (~Q, Pâ†’Q âˆ´ ~P)",
            hypotheticalSyllogism: "ê°€ì„¤ì  ì‚¼ë‹¨ë…¼ë²• (Pâ†’Q, Qâ†’R âˆ´ Pâ†’R)",
            disjunctiveSyllogism: "ì„ ì–¸ì  ì‚¼ë‹¨ë…¼ë²• (Pâˆ¨Q, ~P âˆ´ Q)",
            universalApplication: "ë³´í¸ ì ìš© (AëŠ” Pë‹¤, ëª¨ë“  PëŠ” Që‹¤ âˆ´ AëŠ” Që‹¤)",
            existentialInstantiation: "ì¡´ì¬í™” (ëª¨ë“  PëŠ” Që‹¤ âˆ´ ì–´ë–¤ PëŠ” Që‹¤)",
            conjunctionElimination: "ë‹¨ìˆœí™” (Pâˆ§Q âˆ´ P, Q)",
            doubleNegationElimination: "ì´ì¤‘ ë¶€ì • ì œê±° (~(~P) âˆ´ P)",
            assumptionBased: "ê°€ì • ê¸°ë°˜ ê·œì¹™",
            conditionalIntroduction: "ì¡°ê±´ë¬¸ ë„ì… (P ê°€ì •, Q ë„ì¶œ âˆ´ Pâ†’Q)",
            reductioAdAbsurdum: "ê·€ë¥˜ë²• (P ê°€ì •, ëª¨ìˆœ ë„ì¶œ âˆ´ ~P)",
            advanced: "ê³ ê¸‰ ê·œì¹™",
            proofByCases: "ê²½ìš° ë…¼ì¦ (Pâˆ¨Q, Pâ†’R, Qâ†’R âˆ´ R)",
          },
          alerts: {
            invalidCard: "ê·œì¹™ì— ë§ì§€ ì•ŠëŠ” ì¹´ë“œì…ë‹ˆë‹¤!",
            incompleteProposition:
              "ì™„ì„±ë˜ì§€ ì•Šì€ ëª…ì œì´ê±°ë‚˜ íŒŒì‹±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
            duplicateProposition: "ê°™ì€ ëª…ì œê°€ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤.",
            contradictionFound:
              "ëª¨ìˆœì´ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤! ì´ ëª…ì œëŠ” ê¸°ì¡´ì˜ ì°¸ ëª…ì œë“¤ê³¼ ì–‘ë¦½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
            undoLastCard: "ë§ˆì§€ë§‰ìœ¼ë¡œ ë†“ì€ ì¹´ë“œë¥¼ ë˜ëŒë ¸ìŠµë‹ˆë‹¤.",
            undoLastProposition: "ë§ˆì§€ë§‰ìœ¼ë¡œ ì™„ì„±ëœ ëª…ì œë¥¼ ë˜ëŒë ¸ìŠµë‹ˆë‹¤.",
            nothingToUndo: "ë˜ëŒë¦´ ìˆ˜ ìˆëŠ” ì™„ì„±ëœ ëª…ì œê°€ ì—†ìŠµë‹ˆë‹¤.",
            roundEndNoMoves:
              "'{player}' í”Œë ˆì´ì–´ê°€ ë” ì´ìƒ ë‚¼ ìˆ˜ ìˆëŠ” ì¹´ë“œê°€ ì—†ì–´ ë¼ìš´ë“œë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤.",
            criticalErrorUndo:
              "ì§„ë¦¬ ì²´ê³„ë¥¼ ì¬êµ¬ì„±í•˜ëŠ” ì¤‘ ì‹¬ê°í•œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ê²Œì„ì„ ìƒˆë¡œ ì‹œì‘í•´ì•¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
            oneAssumptionOnly: "ê°€ì •ì€ í•œ ë²ˆì— í•˜ë‚˜ë§Œ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
            parsingFailed:
              "ëª…ì œë¥¼ íŒŒì‹±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì˜¬ë°”ë¥¸ í˜•ì‹ìœ¼ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.",
            premiseNeededForIntro:
              "ì¡°ê±´ë¬¸ ë„ì… ê·œì¹™ì€ ê°€ì •ìœ¼ë¡œë¶€í„° ë„ì¶œëœ 'ê²°ë¡ ' ëª…ì œ í•˜ë‚˜ë§Œ ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤.",
            assumptionNeededForIntro:
              "ì¡°ê±´ë¬¸ ë„ì… ê·œì¹™ì„ ì‚¬ìš©í•˜ë ¤ë©´ ë¨¼ì € 'ê°€ì •í•˜ê¸°'ë¥¼ í†µí•´ ê°€ì •ì„ í•´ì•¼ í•©ë‹ˆë‹¤.",
            premiseNotFromAssumption:
              "ì„ íƒí•œ ëª…ì œëŠ” í˜„ì¬ ê°€ì •ê³¼ ë¬´ê´€í•©ë‹ˆë‹¤. ê°€ì •ìœ¼ë¡œë¶€í„° íŒŒìƒëœ ëª…ì œë¥¼ ì„ íƒí•˜ì„¸ìš”.",
            premiseCountError: "ì´ ê·œì¹™ì€ {count}ê°œì˜ ì „ì œê°€ í•„ìš”í•©ë‹ˆë‹¤.",
            contradictionNeededForRAA:
              "ê·€ë¥˜ë²•ì€ ì„œë¡œ ëª¨ìˆœë˜ëŠ” 2ê°œì˜ ì „ì œê°€ í•„ìš”í•©ë‹ˆë‹¤.",
            assumptionNeededForRAA:
              "ê·€ë¥˜ë²•ì„ ì ìš©í•˜ë ¤ë©´ ë¨¼ì € 'ê°€ì •í•˜ê¸°'ë¥¼ í†µí•´ ê°€ì •ì„ í•´ì•¼ í•©ë‹ˆë‹¤.",
            notAContradiction:
              "ëª¨ìˆœ ê´€ê³„ê°€ ì•„ë‹™ë‹ˆë‹¤. ê·€ë¥˜ë²•ì„ ì ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
            ruleFailed: "ê·œì¹™ ì ìš©ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì „ì œë“¤ì„ í™•ì¸í•´ì£¼ì„¸ìš”.",
            noTheoremsToAdd: "ì¶”ê°€í•  ìƒˆë¡œìš´ ì •ë¦¬ê°€ ì—†ìŠµë‹ˆë‹¤.",
            proofIncomplete:
              "ì¦ëª…ì´ ì™„ë£Œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\nìì‹ ì˜ ìŠ¹ë¦¬ [{myGoal}] ë˜ëŠ”\nìƒëŒ€ì˜ íŒ¨ë°° [{opponentGoal}] ë¥¼ ë„ì¶œí•´ì•¼ í•©ë‹ˆë‹¤.",
            oneCardPerTurn: "í•œ í„´ì— í•œ ì¥ì˜ ì¹´ë“œë§Œ ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
            aiEurekaDeclared: "AIê°€ 'ìœ ë ˆì¹´!'ë¥¼ ì„ ì–¸í–ˆìŠµë‹ˆë‹¤!",
          },
          keywords: {
            if: "ë¼ë©´",
            and: "ê·¸ë¦¬ê³ ",
            or: "ë˜ëŠ”",
            not: "ëŠ” ê±°ì§“ì´ë‹¤",
            wins: "ìŠ¹ë¦¬í•œë‹¤",
            socrates: "ì†Œí¬ë¼í…ŒìŠ¤ëŠ”",
            plato: "í”Œë¼í†¤ì€",
            universal_q: "ëª¨ë“ ",
            existential_q: "ì–´ë–¤",
          },
          cards: [
            { type: "ì–‘í™”ì‚¬", text: "ì–´ë–¤" },
            { type: "ì–‘í™”ì‚¬", text: "ëª¨ë“ " },
            { type: "ì—°ì‚°ì", text: "ë¼ë©´" },
            { type: "ì—°ì‚°ì", text: "ê·¸ë¦¬ê³ " },
            { type: "ì—°ì‚°ì", text: "ë˜ëŠ”" },
            { type: "ì—°ì‚°ì", text: "ëŠ” ê±°ì§“ì´ë‹¤" },
            { type: "ê°œì²´", text: "ìƒˆëŠ”" },
            { type: "ê°œì²´", text: "ë¬¼ê³ ê¸°ëŠ”" },
            { type: "ê°œì²´", text: "ê°œëŠ”" },
            { type: "ê³ ìœ ëª…ì‚¬", text: "ì†Œí¬ë¼í…ŒìŠ¤ëŠ”" },
            { type: "ê³ ìœ ëª…ì‚¬", text: "í”Œë¼í†¤ì€" },
            { type: "ì„œìˆ ì–´", text: "ì„ í•˜ë‹¤" },
            { type: "ì„œìˆ ì–´", text: "ì•…í•˜ë‹¤" },
            { type: "ì„œìˆ ì–´", text: "ì§€í˜œë¡­ë‹¤" },
            { type: "ì„œìˆ ì–´", text: "ì–´ë¦¬ì„ë‹¤" },
            { type: "ì„œìˆ ì–´", text: "ìƒˆì´ë‹¤" },
            { type: "ì„œìˆ ì–´", text: "ë¬¼ê³ ê¸°ì´ë‹¤" },
            { type: "ì„œìˆ ì–´", text: "ê°œì´ë‹¤" },
            { type: "ì„œìˆ ì–´", text: "ìŠ¹ë¦¬í•œë‹¤" },
          ],
          cardTypes: ["ê³ ìœ ëª…ì‚¬", "ì–‘í™”ì‚¬", "ê°œì²´", "ì„œìˆ ì–´", "ì—°ì‚°ì"],
          axiom_templates: {
            identity: [
              "ì–´ë–¤ ìƒˆëŠ” ìƒˆì´ë‹¤",
              "ì–´ë–¤ ë¬¼ê³ ê¸°ëŠ” ë¬¼ê³ ê¸°ì´ë‹¤",
              "ì–´ë–¤ ê°œëŠ” ê°œì´ë‹¤",
              "ëª¨ë“  ìƒˆëŠ” ìƒˆì´ë‹¤",
              "ëª¨ë“  ë¬¼ê³ ê¸°ëŠ” ë¬¼ê³ ê¸°ì´ë‹¤",
              "ëª¨ë“  ê°œëŠ” ê°œì´ë‹¤",
            ],
            opposition_subjects: [
              "{S} ì„ í•˜ë‹¤ ë˜ëŠ” {S} ì•…í•˜ë‹¤",
              "{S} ì„ í•˜ë‹¤ ë¼ë©´ {S} ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
              "{S} ì§€í˜œë¡­ë‹¤ ë˜ëŠ” {S} ì–´ë¦¬ì„ë‹¤",
              "{S} ì§€í˜œë¡­ë‹¤ ë¼ë©´ {S} ì–´ë¦¬ì„ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
            ],
            opposition_quantifiers: [
              "ëª¨ë“  ìƒˆëŠ” ì„ í•˜ë‹¤ ë¼ë©´ ì–´ë–¤ ìƒˆëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
              "ëª¨ë“  ìƒˆëŠ” ì•…í•˜ë‹¤ ë¼ë©´ ì–´ë–¤ ìƒˆëŠ” ì„ í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
              "ëª¨ë“  ë¬¼ê³ ê¸°ëŠ” ì„ í•˜ë‹¤ ë¼ë©´ ì–´ë–¤ ë¬¼ê³ ê¸°ëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
              "ëª¨ë“  ë¬¼ê³ ê¸°ëŠ” ì•…í•˜ë‹¤ ë¼ë©´ ì–´ë–¤ ë¬¼ê³ ê¸°ëŠ” ì„ í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
              "ëª¨ë“  ê°œëŠ” ì„ í•˜ë‹¤ ë¼ë©´ ì–´ë–¤ ê°œëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
              "ëª¨ë“  ê°œëŠ” ì•…í•˜ë‹¤ ë¼ë©´ ì–´ë–¤ ê°œëŠ” ì„ í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
              "ëª¨ë“  ìƒˆëŠ” ì§€í˜œë¡­ë‹¤ ë¼ë©´ ì–´ë–¤ ìƒˆëŠ” ì–´ë¦¬ì„ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
              "ëª¨ë“  ìƒˆëŠ” ì–´ë¦¬ì„ë‹¤ ë¼ë©´ ì–´ë–¤ ìƒˆëŠ” ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
              "ëª¨ë“  ë¬¼ê³ ê¸°ëŠ” ì§€í˜œë¡­ë‹¤ ë¼ë©´ ì–´ë–¤ ë¬¼ê³ ê¸°ëŠ” ì–´ë¦¬ì„ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
              "ëª¨ë“  ë¬¼ê³ ê¸°ëŠ” ì–´ë¦¬ì„ë‹¤ ë¼ë©´ ì–´ë–¤ ë¬¼ê³ ê¸°ëŠ” ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
              "ëª¨ë“  ê°œëŠ” ì§€í˜œë¡­ë‹¤ ë¼ë©´ ì–´ë–¤ ê°œëŠ” ì–´ë¦¬ì„ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
              "ëª¨ë“  ê°œëŠ” ì–´ë¦¬ì„ë‹¤ ë¼ë©´ ì–´ë–¤ ê°œëŠ” ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
              "ì–´ë–¤ ìƒˆëŠ” ì„ í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ëª¨ë“  ìƒˆëŠ” ì•…í•˜ë‹¤",
              "ì–´ë–¤ ìƒˆëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ëª¨ë“  ìƒˆëŠ” ì„ í•˜ë‹¤",
              "ì–´ë–¤ ë¬¼ê³ ê¸°ëŠ” ì„ í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ëª¨ë“  ë¬¼ê³ ê¸°ëŠ” ì•…í•˜ë‹¤",
              "ì–´ë–¤ ë¬¼ê³ ê¸°ëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ëª¨ë“  ë¬¼ê³ ê¸°ëŠ” ì„ í•˜ë‹¤",
              "ì–´ë–¤ ê°œëŠ” ì„ í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ëª¨ë“  ê°œëŠ” ì•…í•˜ë‹¤",
              "ì–´ë–¤ ê°œëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ëª¨ë“  ê°œëŠ” ì„ í•˜ë‹¤",
              "ì–´ë–¤ ìƒˆëŠ” ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ëª¨ë“  ìƒˆëŠ” ì–´ë¦¬ì„ë‹¤",
              "ì–´ë–¤ ìƒˆëŠ” ì–´ë¦¬ì„ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ëª¨ë“  ìƒˆëŠ” ì§€í˜œë¡­ë‹¤",
              "ì–´ë–¤ ë¬¼ê³ ê¸°ëŠ” ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ëª¨ë“  ë¬¼ê³ ê¸°ëŠ” ì–´ë¦¬ì„ë‹¤",
              "ì–´ë–¤ ë¬¼ê³ ê¸°ëŠ” ì–´ë¦¬ì„ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ëª¨ë“  ë¬¼ê³ ê¸°ëŠ” ì§€í˜œë¡­ë‹¤",
              "ì–´ë–¤ ê°œëŠ” ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ëª¨ë“  ê°œëŠ” ì–´ë¦¬ì„ë‹¤",
              "ì–´ë–¤ ê°œëŠ” ì–´ë¦¬ì„ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ëª¨ë“  ê°œëŠ” ì§€í˜œë¡­ë‹¤",
            ],
          },
          victoryPredicates: ["ì„ í•˜ë‹¤", "ì•…í•˜ë‹¤", "ì§€í˜œë¡­ë‹¤", "ì–´ë¦¬ì„ë‹¤"],
          contradictoryPredicates: { ì„ í•˜ë‹¤: "ì•…í•˜ë‹¤", ì§€í˜œë¡­ë‹¤: "ì–´ë¦¬ì„ë‹¤" },
          labels: {
            proposition: "[ëª…ì œ]",
            axiom: "[ê³µë¦¬]",
            victory_condition: "[ìŠ¹ë¦¬ ì¡°ê±´]",
            theorem: "[ì •ë¦¬]",
            assumption: "[ê°€ì •]",
            ci_theorem: "[ì¡°ê±´ë¬¸ ë„ì…]",
            raa_theorem: "[ê·€ë¥˜ë²• ì¦ëª…]",
            theorem_source: "[ì •ë¦¬] {text} (R{round} ì‚¬ìœ )",
            victory_text: "{owner} ìŠ¹ë¦¬ ì¡°ê±´: <strong>{text}</strong>",
          },
        },
        en: {
          langCode: "en",
          ui: {
            title: "LOGOS",
            tutorialButton: "Tutorial",
            endTutorialButton: "End Tutorial",
            newGameButton: "New Game",
            fullscreenButton: "Fullscreen",
            vsAIButton: "1P vs AI",
            vsPlayerButton: "1P vs 2P",
            playerAName: "Socrates",
            playerAColor: "âšªï¸ White",
            playerBName: "Plato",
            playerBColor: "âš«ï¸ Black",
            currentPropositionTitle: "Current Proposition",
            completeButton: "Complete",
            undoButton: "Undo",
            endTurnButton: "End Turn",
            truePropositionsTitle: "True Propositions",
            eurekaButton: "Eureka!",
            addTheoremButton: "Add Theorem â•",
            roundDisplay: "Round {round}",
            axiomTitle: "Basic Axioms (Click to expand)",
            statusTurn: "'s Turn",
            statusAITurn: "AI is thinking...",
            thinkingTimeStatus: "Thinking Time. Derive new theorems.",
            thinkingTimeTitle: "Thinking Time",
            thinkingTimeDesc:
              "Derive new theorems and add them to the list using the 'Add Theorem' button.<br>When ready, press the button below to start the next round.",
            endThinkingTimeButton: "End Thinking Time & Start Next Round",
            victoryMessage: "Player Wins!",
            victorySubMessage: "You have succeeded with a logical proof!",
            okButton: "OK",
            cancelButton: "Cancel",
            nextButton: "Next",
            cancelAssumptionButton: "Cancel",
          },
          modals: {
            characterSelectTitle: "Select Your Philosopher",
            selectSocrates: "Socrates (White) âšªï¸",
            selectPlato: "Plato (Black) âš«ï¸",
            eurekaTitleVictory: "Eureka! Construct Proof",
            eurekaTitleTheorem: "Thinking Time: Construct Theorem",
            premiseSelectionTitle: "Available Premises List",
            applyRuleButton: "Apply",
            addAssumptionButton: "Assume",
            confirmVictoryButton: "Prove Victory with this Argument!",
            confirmTheoremButton: "Add Selected Theorems to True List â•",
            tutorialTitle: "LOGOS Tutorial",
            promptInputPlaceholder: "Enter proposition...",
          },
          tutorial: [
            // Stage 1 (Index 0)
            [
              "Welcome to LOGOS!",
              "Before we begin, let's go over a few core rules.",
              "<strong>Win Condition:</strong> At the start of each game, you get a unique, random <strong>Win Condition</strong>.<br><br>You win by declaring <strong>Eureka!</strong> and proving either <strong>your own victory</strong> or <strong>your opponent's defeat</strong>.<br><br>For example, if your philosopher is Socrates, you win by proving either <strong>Socrates wins</strong> or <strong>Plato wins is false</strong>.",
              "<strong>First Turn:</strong> The first round always begins with Socrates (White).<br><br><strong>Alternating Turns:</strong> The starting player alternates each round.",
              "Now, let's learn the most basic action: how to form a <strong>proposition</strong>.",
              "This is your <strong>hand</strong>. It contains various word cards.",
              "You will move cards here to form a <strong>proposition</strong>.",
              "Click a card to move it to the <strong>Current Proposition</strong> area.",
              "Excellent! A <strong>Proper Noun</strong> like <strong>Socrates</strong> can start a proposition directly.",
              "However, <strong>Entity</strong> cards like <strong>dog</strong>, <strong>bird</strong>, and <strong>fish</strong> must always follow a <strong>Quantifier</strong> card like <strong>Every</strong> or <strong>Some</strong>. Please remember this rule!",
              "Now, shall we end the turn? In LOGOS, you must play exactly one card per turn.",
              "Press the <strong>End Turn</strong> button to pass the turn to your opponent.",
              "You've got it!<br><br>Now let's see how to respond to a proposition your opponent has made.",
            ],
            // Stage 2 (Index 1)
            [
              "Your opponent's turn is over, and now it's your turn.",
              "The proposition your opponent made is grammatically complete. You have several options now.",
              "<strong>First Option: Complete Proposition.</strong> This accepts the opponent's statement as <strong>true</strong>. Since there are no contradictions for now, let's press the <strong>Complete Proposition</strong> button to add it to the <strong>List of True Propositions</strong>.",
              "Excellent! However, there are two important conditions for a proposition to be added.",
              "First, you cannot add a proposition if the exact same one already exists.",
              "Second, you cannot add a proposition that contradicts an existing truth.",
              "Now you fully understand the rules for completing a proposition. Instead of completing it, other options are also available.",
              "<strong>Second Option: Extend.</strong> You can add <strong>connective</strong> cards like <strong>and</strong>, <strong>or</strong>, or <strong>then</strong> to make the proposition more complex. Remember, you can only use one connective per proposition.",
              "<strong>Third Option: Negate.</strong> If a proposition is disadvantageous, you can add the <strong>is false</strong> card from your hand to negate it.<br>But be careful! If your opponent also plays a negation card, your negation can be immediately nullified by the <strong>Double Negation</strong> rule.<br><br>Also, when <strong>is false</strong> is attached to a sentence with a connective, it only negates the smallest proposition it's attached to, not the whole sentence.<br><br>For example, in <strong>Some dog is good and Socrates is evil is false</strong>, only the <strong>Socrates is evil</strong> part is negated.",
              "Now you've learned the various ways to respond to an opponent's proposition. Next, let's learn about the <strong>Basic Axioms</strong> that form the foundation of our arguments.",
            ],
            // Stage 3 (Index 2)
            [
              "The List of True Propositions contains not only the propositions we've made, but also the <strong>Basic Axioms</strong> which are the foundation of all arguments.",
              "Click this item to see what axioms are available.",
              "Axioms are propositions that are accepted as true without proof, such as 'Every dog is a dog'.",
              "According to the axioms, the same entity <strong>cannot have two opposing properties at the same time</strong>, like being both <strong>good</strong> and <strong>evil</strong>.",
              "You can use these axioms as important premises when constructing your arguments.",
              "Now that you've checked the basic truths, let's find out what happens when you cannot play any card.",
            ],
            // Stage 4 (Index 3)
            [
              "If the current player has no possible moves, the round ends and <strong>Thinking Time</strong> begins.",
              "During Thinking Time, the <strong>Eureka!</strong> button changes to an <strong>Add Theorem</strong> button.",
              "Press this button to create new <strong>theorems</strong> based on already proven truths. Let's try it now.",
              "The proof workbench has opened. Let's create a new theorem using the <strong>Universal Application</strong> rule.",
              "Select the premises <strong>Socrates is a dog</strong> and <strong>Every dog is wise</strong> from the list.",
              "Now, select <strong>Universal Application</strong> from the dropdown and click <strong>Apply Rule</strong>.",
              "Great! The new theorem <strong>Socrates is wise</strong> has been derived.<br><br>Now, select this theorem and press the <strong>Add Selected Theorems to True List</strong> button to finalize the proof.",
              "The new theorem has been added to the <strong>List of True Propositions</strong>!<br><br>Now press the <strong>End Thinking Time</strong> button to start the next round.<br>When a new round starts, you get all your played cards back, and the List of True Propositions remains.",
            ],
            // Stage 5 (Index 4) - UPDATED & EXPANDED
            [
              "You've learned the game flow. Finally, let's learn the most important <strong>inference rules</strong> for victory, one by one. Press the <strong>Eureka!</strong> button to open the proof workbench.",
              // 1. Modus Ponens
              "First up is <strong>Modus Ponens</strong>. It's the most intuitive rule: if you have (P) and (P â†’ Q), you can derive (Q).",
              "From the premise list, select <strong>Socrates is good</strong> and <strong>Socrates is good then Socrates wins</strong>.",
              "Select <strong>Modus Ponens</strong> from the rule list and click <strong>Apply Rule</strong>.",
              // 2. Modus Tollens
              "Great. The conclusion <strong>Socrates wins</strong> has been derived. Now let's practice <strong>Modus Tollens</strong>.",
              "From the premise list, select <strong>Plato is wise is false</strong> and <strong>Plato wins then Plato is wise</strong>.",
              "Select <strong>Modus Tollens</strong> from the rule list and click <strong>Apply Rule</strong>.",
              // 3. Disjunctive Syllogism
              "Excellent! The conclusion <strong>Plato wins is false</strong> has been derived. Next is <strong>Disjunctive Syllogism</strong>.",
              "From the premise list, select <strong>Some bird is a fish or Some bird is a bird</strong> and <strong>Some bird is a fish is false</strong>. If one part of an <strong>or</strong> statement is false, the other must be true, right?",
              "Select <strong>Disjunctive Syllogism</strong> from the rule list and click <strong>Apply Rule</strong>.",
              // 4. Hypothetical Syllogism
              "<strong>Some bird is a bird</strong> has been derived. Now for <strong>Hypothetical Syllogism</strong>. Let's link two chaining propositions into one.",
              "Select <strong>Plato is a dog then Plato is good</strong> and <strong>Plato is good then Plato wins</strong>.",
              "Select <strong>Hypothetical Syllogism</strong> from the rule list and click <strong>Apply Rule</strong>.",
              // 5. Conjunction Elimination (Simplification)
              "Great! A more concise proposition <strong>Plato is a dog then Plato wins</strong> has been created. Next is the <strong>Simplification</strong> rule.",
              "A statement connected by <strong>and</strong> means both parts are true. From the premise list, select <strong>Socrates is wise and Plato is foolish</strong>.",
              "Select <strong>Simplification</strong> from the rule list and click <strong>Apply Rule</strong>. You'll see two propositions derived at once.",
              // 6. Double Negation Elimination
              "As you can see, the two propositions have been separated. Now let's learn the <strong>Double Negation Elimination</strong> rule. Two negatives make a positive.",
              "Select <strong>Some fish is good is false is false</strong> from the premise list.",
              "Select <strong>Double Negation Elimination</strong> from the rule list and click <strong>Apply Rule</strong>.",
              // 7. Universal Application
              "It's back to the original positive statement. Next up is the <strong>Universal Application</strong> rule. A universal rule applies to specific instances.",
              "Select <strong>Every bird is good</strong> and <strong>Plato is a bird</strong> from the premise list.",
              "Select <strong>Universal Application</strong> from the rule list and click <strong>Apply Rule</strong>.",
              // 8. Existential Instantiation
              "Exactly. Lastly, the <strong>Existential Instantiation</strong> rule. If <strong>Every</strong> is true, then <strong>Some</strong> must also be true.",
              "Select <strong>Every dog is good</strong> from the premise list.",
              "Select <strong>Existential Instantiation</strong> from the rule list and click <strong>Apply Rule</strong>.",
              // End of Stage 5
              "Excellent! You have now mastered all the basic inference rules of LOGOS. Next, let's learn a powerful rule for combining multiple propositions.",
            ],
            // Stage 6 (Index 5)
            [
              "The <strong>Proof by Cases</strong> rule we'll learn now is a powerful tool for merging multiple paths into a single conclusion.",
              "We have two cases: <strong>Plato is good or Plato is evil</strong>. However, in either case, we reach the same conclusion <strong>Plato is wise</strong>. First, please select all three required premises.",
              "Great. Now, select <strong>Proof by Cases</strong> from the rule list and click <strong>Apply Rule</strong> to derive the conclusion.",
              "Perfect! The conclusion <strong>Plato is wise</strong> has been derived. You've become familiar with the basic rules. Next up are rules that use <strong>assumptions</strong>, the heart of logic.",
            ],
            // Stage 7 (Index 6) - â˜…â˜…â˜… MODIFIED SECTION â˜…â˜…â˜…
            [
              "Sometimes, to prove something, you need to assume <strong>what if...</strong>. This time, let's logically connect two premises.",
              "Click the <strong>Assume</strong> button and assume <strong>Socrates is wise</strong> by typing it in.",
              "Great. Now, select the assumption and the first premise: 'Socrates is wise then Plato is a dog'.",
              "Apply the <strong>Modus Ponens</strong> rule to derive an intermediate conclusion.",
              "Excellent! Now, select the intermediate conclusion you just got and the second premise: <strong>Plato is a dog then Plato is good</strong>.",
              "Apply the <strong>Modus Ponens</strong> rule again to derive the final conclusion.",
              "Perfect! Now for the magic of <strong>Conditional Introduction</strong>. Select the final result, <strong>Plato is good</strong>.",
              "Finally, apply the <strong>Conditional Introduction</strong> rule. This creates the new theorem <strong>Socrates is wise then Plato is good</strong>, a solid truth we never had before, independent of the assumption!",
              "Excellent! Now let's learn about Reductio ad Absurdum.",
            ],
            // Stage 8 (Index 7) - NEWLY ADDED
            [
              "<strong>Reductio ad Absurdum</strong> is a method of proving something by assuming its <strong>opposite</strong> to find a contradiction.",
              "Our goal is to prove <strong>Socrates is evil</strong>. Let's assume the opposite by clicking <strong>Assume</strong> and entering <strong>Socrates is evil is false</strong>.",
              "The assumption has been added. Now, let's use it to create an obvious contradiction, a pair of 'P' and '~P'. Select the assumption you just made and the other premise, then apply the 'Modus Ponens' rule.",
              "Look! <strong>Plato is wise</strong> has been derived. But we already have <strong>Plato is wise is false</strong> in our list of true propositions. This is a contradiction!",
              "Now, select the two contradictory propositions and apply the <strong>Reductio ad Absurdum</strong> rule.",
              "This proves our initial assumption was wrong! Now, apply the <strong>Double Negation Elimination</strong> rule to the result to get our final conclusion.",
              "Perfect! You have now learned everything about LOGOS. Go ahead and prove your wisdom in a real battle of wits!",
            ],
          ],
          inferenceRules: {
            basic: "Basic Rules",
            modusPonens: "Modus Ponens (P, Pâ†’Q âˆ´ Q)",
            modusTollens: "Modus Tollens (~Q, Pâ†’Q âˆ´ ~P)",
            hypotheticalSyllogism: "Hypothetical Syllogism (Pâ†’Q, Qâ†’R âˆ´ Pâ†’R)",
            disjunctiveSyllogism: "Disjunctive Syllogism (Pâˆ¨Q, ~P âˆ´ Q)",
            universalApplication:
              "Universal Application (A is P, Every P are Q âˆ´ A is Q)",
            existentialInstantiation:
              "Existential Instantiation (Every P is Q âˆ´ Some P is Q)",
            conjunctionElimination: "Simplification (Pâˆ§Q âˆ´ P, Q)",
            doubleNegationElimination:
              "Double Negation Elimination (~(~P) âˆ´ P)",
            assumptionBased: "Assumption-Based Rules",
            conditionalIntroduction:
              "Conditional Introduction (Assume P, derive Q âˆ´ Pâ†’Q)",
            reductioAdAbsurdum:
              "Reductio ad Absurdum (Assume P, derive contradiction âˆ´ ~P)",
            advanced: "Advanced Rules",
            proofByCases: "Proof by Cases (Pâˆ¨Q, Pâ†’R, Qâ†’R âˆ´ R)",
          },
          alerts: {
            invalidCard: "This card cannot be played here.",
            incompleteProposition:
              "The proposition is incomplete or could not be parsed.",
            duplicateProposition: "The same proposition already exists.",
            contradictionFound:
              "Contradiction found! This proposition is not compatible with the set of true propositions.",
            undoLastCard: "Reverted the last played card.",
            undoLastProposition: "Reverted the last completed proposition.",
            nothingToUndo: "There are no completed propositions to undo.",
            roundEndNoMoves:
              "Player '{player}' has no valid moves. The round ends.",
            criticalErrorUndo:
              "A critical error occurred while rebuilding the truth set. You may need to restart the game.",
            oneAssumptionOnly: "You can only have one assumption at a time.",
            parsingFailed:
              "Could not parse the proposition. Please check the format.",
            premiseNeededForIntro:
              "For Conditional Introduction, you must select exactly one conclusion derived from the assumption.",
            assumptionNeededForIntro:
              "You must make an assumption first to use Conditional Introduction.",
            premiseNotFromAssumption:
              "The selected proposition does not depend on the current assumption.",
            premiseCountError: "This rule requires {count} premises.",
            contradictionNeededForRAA:
              "Reductio ad Absurdum requires 2 contradictory premises.",
            assumptionNeededForRAA:
              "You must make an assumption first to use Reductio ad Absurdum.",
            notAContradiction: "The selected premises are not a contradiction.",
            ruleFailed: "Failed to apply the rule. Please check your premises.",
            noTheoremsToAdd: "There are no new, non-dependent theorems to add.",
            proofIncomplete:
              "Proof incomplete.\nYou must derive your victory [{myGoal}] or your opponent's defeat [{opponentGoal}].",
            oneCardPerTurn: "You can only play one card per turn.",
            aiEurekaDeclared: "AI has declared 'Eureka!'",
          },
          keywords: {
            if: "then",
            and: "and",
            or: "or",
            not: "is false",
            wins: "wins",
            socrates: "Socrates",
            plato: "Plato",
            universal_q: "Every",
            existential_q: "Some",
          },
          cards: [
            { type: "Quantifier", text: "Some" },
            { type: "Quantifier", text: "Every" },
            { type: "Operator", text: "then" },
            { type: "Operator", text: "and" },
            { type: "Operator", text: "or" },
            { type: "Operator", text: "is false" },
            { type: "Entity", text: "bird" },
            { type: "Entity", text: "fish" },
            { type: "Entity", text: "dog" },
            { type: "Proper Noun", text: "Socrates" },
            { type: "Proper Noun", text: "Plato" },
            { type: "Predicate", text: "is good" },
            { type: "Predicate", text: "is evil" },
            { type: "Predicate", text: "is wise" },
            { type: "Predicate", text: "is foolish" },
            { type: "Predicate", text: "is a bird" },
            { type: "Predicate", text: "is a fish" },
            { type: "Predicate", text: "is a dog" },
            { type: "Predicate", text: "wins" },
          ],
          cardTypes: [
            "Proper Noun",
            "Quantifier",
            "Entity",
            "Predicate",
            "Operator",
          ],
          axiom_templates: {
            identity: [
              "Some bird is a bird",
              "Some fish is a fish",
              "Some dog is a dog",
              "Every bird is a bird",
              "Every fish is a fish",
              "Every dog is a dog",
            ],
            opposition_subjects: [
              "{S} is good or {S} is evil",
              "{S} is good then {S} is evil is false",
              "{S} is wise or {S} is foolish",
              "{S} is wise then {S} is foolish is false",
            ],
            opposition_quantifiers: [
              "Every bird is good then Some bird is evil is false",
              "Every bird is evil then Some bird is good is false",
              "Every fish is good then Some fish is evil is false",
              "Every fish is evil then Some fish is good is false",
              "Every dog is good then Some dog is evil is false",
              "Every dog is evil then Some dog is good is false",
              "Every bird is wise then Some bird is foolish is false",
              "Every bird is foolish then Some bird is wise is false",
              "Every fish is wise then Some fish is foolish is false",
              "Every fish is foolish then Some fish is wise is false",
              "Every dog is wise then Some dog is foolish is false",
              "Every dog is foolish then Some dog is wise is false",
              "Some bird is good is false then Every bird is evil",
              "Some bird is evil is false then Every bird is good",
              "Some fish is good is false then Every fish is evil",
              "Some fish is evil is false then Every fish is good",
              "Some dog is good is false then Every dog is evil",
              "Some dog is evil is false then Every dog is good",
              "Some bird is wise is false then Every bird is foolish",
              "Some bird is foolish is false then Every bird is wise",
              "Some fish is wise is false then Every fish is foolish",
              "Some fish is foolish is false then Every fish is wise",
              "Some dog is wise is false then Every dog is foolish",
              "Some dog is foolish is false then Every dog is wise",
            ],
          },
          victoryPredicates: ["is good", "is evil", "is wise", "is foolish"],
          contradictoryPredicates: {
            "is good": "is evil",
            "is wise": "is foolish",
          },
          labels: {
            proposition: "[Prop]",
            axiom: "[Axiom]",
            victory_condition: "[WinCon]",
            theorem: "[Thm]",
            assumption: "[Asmp]",
            ci_theorem: "[CI Thm]",
            raa_theorem: "[RAA Thm]",
            theorem_source: "[Thm] {text} (R{round} Thinking)",
            victory_text: "{owner} Win Condition: {text}",
          },
        },
      };

      // Add this right after the const TEXTS = { ... }; line

      const PHILOSOPHERS = {
        socrates: {
          id: "socrates",
          name: { ko: "ì†Œí¬ë¼í…ŒìŠ¤", en: "Socrates" },
          cardText: { ko: "ì†Œí¬ë¼í…ŒìŠ¤ëŠ”", en: "Socrates" },
          image: "assets/so_portrait.png", // ğŸ‘ˆ ì² í•™ì í° ì´ë¯¸ì§€ ê²½ë¡œ
          icon: "assets/so_icon.png", // ğŸ‘ˆ ì„ íƒ ê²©ìì— ë“¤ì–´ê°ˆ ì•„ì´ì½˜ ì´ë¯¸ì§€ ê²½ë¡œ
          skill: {
            ko: 'ë„ˆ ìì‹ ì„ ì•Œë¼: ì²« ë¼ìš´ë“œë¥¼ íŒ¨ë°°ë¡œ ì‹œì‘í•©ë‹ˆë‹¤. ëŒ€ì‹ , ê²Œì„ ì‹œì‘ ì‹œ ì¶”ê°€ "ì •ë¦¬"ë¥¼ 2ê°œ ê°€ì§‘ë‹ˆë‹¤.',
            en: 'Know Thyself: Starts the first round with a loss. Instead, gains 2 extra "Theorems" at the start of the game.',
          },
        },
        plato: {
          id: "plato",
          name: { ko: "í”Œë¼í†¤", en: "Plato" },
          image: "assets/pl_portrait.png",
          cardText: { ko: "í”Œë¼í†¤ì€", en: "Plato" },
          icon: "assets/pl_icon.png",
          skill: {
            ko: 'ì´ë°ì•„: "ìœ ë ˆì¹´" ì„ ì–¸ ì‹œ, ì¦ëª…ì— í•„ìš”í•œ ì „ì œë¥¼ í•˜ë‚˜ ëœ ì‚¬ìš©í•´ë„ ë©ë‹ˆë‹¤ (ìµœì†Œ 1ê°œëŠ” í•„ìš”).',
            en: 'Theory of Forms: May use one less premise when declaring "Eureka!" (minimum of 1 is still required).',
          },
        },
        aristotle: {
          id: "aristotle",
          name: { ko: "ì•„ë¦¬ìŠ¤í† í…”ë ˆìŠ¤", en: "Aristotle" },
          cardText: { ko: "ì•„ë¦¬ìŠ¤í† í…”ë ˆìŠ¤ëŠ”", en: "Aristotle" },
          image: "assets/ar_portrait.png",
          icon: "assets/ar_icon.png",
          skill: {
            ko: 'ì‚¼ë‹¨ë…¼ë²•: "ì‚¬ìœ  ì‹œê°„"ì— "ë³´í¸ ì ìš©" ê·œì¹™ì˜ ë¹„ìš©ì´ ì ˆë°˜ìœ¼ë¡œ ê°ì†Œí•©ë‹ˆë‹¤.',
            en: 'Syllogism: The cost of the "Universal Application" rule is halved during "Thinking Time".',
          },
        },
        nietzsche: {
          id: "nietzsche",
          name: { ko: "ë‹ˆì²´", en: "Nietzsche" },
          cardText: { ko: "ë‹ˆì²´ëŠ”", en: "Nietzsche" },
          image: "assets/ni_portrait.png",
          icon: "assets/ni_icon.png",
          skill: {
            ko: 'ì´ˆì¸: ìƒëŒ€ë°©ì˜ ìŠ¹ë¦¬ ì¡°ê±´ì„ ë§Œì¡±ì‹œí‚¤ëŠ” ëª…ì œë¥¼ "ê±°ì§“"ìœ¼ë¡œ ë§Œë“¤ì—ˆì„ ë•Œ, ì¶”ê°€ í„´ì„ ì–»ìŠµë‹ˆë‹¤.',
            en: "Ãœbermensch: Gains an extra turn when successfully negating a proposition that satisfies the opponent's win condition.",
          },
        },
      };

      // --- GLOBAL STATE ---
      // --- GLOBAL STATE ---
      let currentLang;
      let fullDeck, cardTypeOrder;
      let playerA_Hand = [],
        playerB_Hand = [];
      let truePropositions = [];
      let parsedAxioms = [];
      let currentProposition = [];
      let currentPlayer = "A";
      let propositionStarter = "A";
      let gameIsOver = false;
      let currentRound = 1;
      let isThinkingTime = false;
      let lastPropositionMaker = null;
      let internalTruthSet = [];
      let derivedPropositionsInModal = [];
      let currentAssumption = null;
      let lastCardPlayer = null;
      let cardsPlayedThisTurn = { A: 0, B: 0 };

      let playerA_Data = null;
      let playerB_Data = null;

      let currentAxioms = []; // í˜„ì¬ ê²Œì„ì˜ ê³µë¦¬ë¥¼ ì €ì¥í•  ë°°ì—´

      // --- AI Mode State ---
      let gameMode = null;
      let playerCharacter = null;
      let aiPlayer = null;

      // --- TUTORIAL STATE ---
      let inTutorialMode = false;
      let tutorialStep = 0;
      let tutorialSubStep = 0;
      let temporaryListener = null;

      // --- Character Selection State (NEW) ---
      let selectionMode = null; // '2P' or 'AI'
      let characterSelectionTurn = null; // 'P1', 'P2'
      let tempSelections = { p1: null, p2: null };
      let humanPlayerId = null; // In AI mode, is the human 'P1' or 'P2'?
      // --- LOGIC ENGINE: PARSING & COMPARISON (MOVED UP) ---

      let aiTimeoutId = null;

      function parseTokensToProposition(tokens) {
        if (!tokens || tokens.length === 0) return null;
        if (tokens[0] === "(" && tokens[tokens.length - 1] === ")") {
          let balance = 0;
          let isOuterParens = true;
          for (let i = 0; i < tokens.length - 1; i++) {
            if (tokens[i] === "(") balance++;
            else if (tokens[i] === ")") balance--;
            if (balance === 0) {
              isOuterParens = false;
              break;
            }
          }
          if (isOuterParens) {
            return parseTokensToProposition(tokens.slice(1, -1));
          }
        }
        let balance = 0;
        for (let i = tokens.length - 1; i >= 0; i--) {
          if (tokens[i] === ")") balance++;
          else if (tokens[i] === "(") balance--;
          if (balance === 0 && tokens[i] === currentLang.keywords.if) {
            const left = parseTokensToProposition(tokens.slice(0, i));
            const right = parseTokensToProposition(tokens.slice(i + 1));
            if (!left || !right) return null;
            return { type: "conditional", left: left, right: right };
          }
        }
        balance = 0;
        for (let i = tokens.length - 1; i >= 0; i--) {
          if (tokens[i] === ")") balance++;
          else if (tokens[i] === "(") balance--;
          if (balance === 0 && tokens[i] === currentLang.keywords.or) {
            const left = parseTokensToProposition(tokens.slice(0, i));
            const right = parseTokensToProposition(tokens.slice(i + 1));
            if (!left || !right) return null;
            return { type: "disjunction", left: left, right: right };
          }
        }
        balance = 0;
        for (let i = tokens.length - 1; i >= 0; i--) {
          if (tokens[i] === ")") balance++;
          else if (tokens[i] === "(") balance--;
          if (balance === 0 && tokens[i] === currentLang.keywords.and) {
            const left = parseTokensToProposition(tokens.slice(0, i));
            const right = parseTokensToProposition(tokens.slice(i + 1));
            if (!left || !right) return null;
            return { type: "conjunction", left: left, right: right };
          }
        }
        if (
          tokens.length > 1 &&
          tokens[tokens.length - 1] === currentLang.keywords.not
        ) {
          const prop = parseTokensToProposition(tokens.slice(0, -1));
          if (!prop) return null;
          return { type: "negation", proposition: prop };
        }
        const cardInfo = tokens.map((t) => fullDeck.find((c) => c.text === t));
        if (cardInfo.some((c) => !c)) {
          const [properNoun, quantifier, entity, predicate] =
            currentLang.cardTypes;
          const types = tokens.map((t) => {
            const card = fullDeck.find((c) => c.text === t);
            return card ? card.type : null;
          });
          if (types.length === 2 && types[0] === properNoun) {
            return { type: "atomic", subject: tokens[0], predicate: tokens[1] };
          }
          if (types.length === 3 && types[0] === quantifier) {
            return {
              type:
                tokens[0] === currentLang.keywords.universal_q
                  ? "universal"
                  : "existential",
              entity: tokens[1],
              predicate: tokens[2],
            };
          }
          return null;
        }
        const types = cardInfo.map((c) => c.type);
        const [properNoun, quantifier, entity, predicate] =
          currentLang.cardTypes;
        if (types.length === 2 && types[0] === properNoun) {
          return { type: "atomic", subject: tokens[0], predicate: tokens[1] };
        }
        if (types.length === 3 && types[0] === quantifier) {
          return {
            type:
              tokens[0] === currentLang.keywords.universal_q
                ? "universal"
                : "existential",
            entity: tokens[1],
            predicate: tokens[2],
          };
        }
        return null;
      }

      function parsePropositionFromString(str) {
        const allKeywords = [...fullDeck.map((c) => c.text), "(", ")"].sort(
          (a, b) => b.length - a.length
        );
        let tempStr = str.trim();
        const tokens = [];
        while (tempStr.length > 0) {
          const foundToken = allKeywords.find((k) => tempStr.startsWith(k));
          if (foundToken) {
            tokens.push(foundToken);
            tempStr = tempStr.substring(foundToken.length).trim();
          } else {
            console.error(
              "Tokenizer failed for string:",
              str,
              "at substring:",
              tempStr
            );
            return null;
          }
        }
        return parseTokensToProposition(tokens);
      }

      function parsePropositionFromCards(propInfoArray) {
        if (!propInfoArray || propInfoArray.length === 0) return null;
        const tokens = propInfoArray.map((info) => info.card.text);
        return parseTokensToProposition(tokens);
      }

      function arePropositionsEqual(prop1, prop2) {
        if (!prop1 || !prop2 || prop1.type !== prop2.type) return false;
        switch (prop1.type) {
          case "atomic":
            return (
              prop1.subject === prop2.subject &&
              prop1.predicate === prop2.predicate
            );
          case "universal":
          case "existential":
            return (
              prop1.entity === prop2.entity &&
              prop1.predicate === prop2.predicate
            );
          case "negation":
            return arePropositionsEqual(prop1.proposition, prop2.proposition);
          case "conjunction":
          case "disjunction":
          case "conditional":
            return (
              arePropositionsEqual(prop1.left, prop2.left) &&
              arePropositionsEqual(prop1.right, prop2.right)
            );
          default:
            return false;
        }
      }

      function propositionToText(prop) {
        if (!prop) return "";
        switch (prop.type) {
          case "atomic":
            return `${prop.subject} ${prop.predicate}`;
          case "universal":
            return `${currentLang.keywords.universal_q} ${prop.entity} ${prop.predicate}`;
          case "existential":
            return `${currentLang.keywords.existential_q} ${prop.entity} ${prop.predicate}`;
          case "negation":
            return `~(${propositionToText(prop.proposition)})`;
          case "conjunction":
            return `(${propositionToText(prop.left)}) âˆ§ (${propositionToText(
              prop.right
            )})`;
          case "disjunction":
            return `(${propositionToText(prop.left)}) âˆ¨ (${propositionToText(
              prop.right
            )})`;
          case "conditional":
            return `(${propositionToText(prop.left)}) â†’ (${propositionToText(
              prop.right
            )})`;
          default:
            return "Unknown Proposition";
        }
      }

      function propositionToNaturalText(prop) {
        if (!prop) return "";
        switch (prop.type) {
          case "atomic":
            return `${prop.subject} ${prop.predicate}`;
          case "universal":
            return `${currentLang.keywords.universal_q} ${prop.entity} ${prop.predicate}`;
          case "existential":
            return `${currentLang.keywords.existential_q} ${prop.entity} ${prop.predicate}`;
          case "negation":
            const innerProp = prop.proposition;
            const innerText = propositionToNaturalText(innerProp);
            if (
              innerProp.type === "conjunction" ||
              innerProp.type === "disjunction" ||
              innerProp.type === "conditional"
            ) {
              return `(${innerText}) ${currentLang.keywords.not}`;
            }
            return `${innerText} ${currentLang.keywords.not}`;
          case "conjunction":
            return `(${propositionToNaturalText(prop.left)}) ${
              currentLang.keywords.and
            } (${propositionToNaturalText(prop.right)})`;
          case "disjunction":
            return `(${propositionToNaturalText(prop.left)}) ${
              currentLang.keywords.or
            } (${propositionToNaturalText(prop.right)})`;
          case "conditional":
            return `(${propositionToNaturalText(prop.left)}) ${
              currentLang.keywords.if
            } (${propositionToNaturalText(prop.right)})`;
          default:
            return "Unknown Proposition";
        }
      }

      // ê¸°ì¡´ initializeGame í•¨ìˆ˜ë¥¼ ì•„ë˜ ì½”ë“œë¡œ êµì²´í•˜ì„¸ìš”.
      function initializeGame(lang) {
        currentLang = TEXTS[lang];
        document.documentElement.lang = currentLang.langCode;
        document.title = currentLang.ui.title;

        fullDeck = currentLang.cards;
        cardTypeOrder = currentLang.cardTypes; // 'axioms' ê´€ë ¨ ë¼ì¸ ì œê±°

        document.getElementById("language-modal").classList.remove("visible");
        setupUI();
        showMainMenu();
      }

      function showMainMenu() {
        document.getElementById("container").classList.add("ready");
        document.querySelector(".main-center-bg").classList.remove("hidden");
        updateMainMenuBtnVisibility();
        updateMainCenterVisibility();
      }

      function setupUI() {
        document.getElementById("main-menu-btn").textContent =
          currentLang.langCode === "ko" ? "ë©”ì¸ìœ¼ë¡œ" : "Main Menu";

        document.getElementById("main-title").textContent =
          currentLang.ui.title;
        document.getElementById("new-game-btn").textContent =
          currentLang.ui.newGameButton;
        document.getElementById("vs-ai-btn").textContent =
          currentLang.ui.vsAIButton;
        document.getElementById("vs-player-btn").textContent =
          currentLang.ui.vsPlayerButton;
        document.getElementById("tutorial-btn").textContent =
          currentLang.ui.tutorialButton;
        document.getElementById(
          "player-a-title"
        ).innerHTML = `${currentLang.ui.playerAName} - ${currentLang.ui.playerAColor}`;
        document.getElementById(
          "player-b-title"
        ).innerHTML = `${currentLang.ui.playerBName} - ${currentLang.ui.playerBColor}`;
        document.getElementById("eureka-a").textContent =
          currentLang.ui.eurekaButton;
        document.getElementById("eureka-b").textContent =
          currentLang.ui.eurekaButton;
        document.getElementById("current-proposition-title").textContent =
          currentLang.ui.currentPropositionTitle;
        document.getElementById("complete-btn").textContent =
          currentLang.ui.completeButton;
        document.getElementById("undo-btn").textContent =
          currentLang.ui.undoButton;
        document.getElementById("end-turn-btn").textContent =
          currentLang.ui.endTurnButton;
        document.getElementById("true-propositions-title").textContent =
          currentLang.ui.truePropositionsTitle;
        document.getElementById("thinking-time-title").textContent =
          currentLang.ui.thinkingTimeTitle;
        document.getElementById("thinking-time-desc").innerHTML =
          currentLang.ui.thinkingTimeDesc;
        document.getElementById("end-thinking-time-btn").textContent =
          currentLang.ui.endThinkingTimeButton;
        document.getElementById("fullscreen-btn").textContent =
          currentLang.ui.fullscreenButton;
        document.getElementById("tutorial-btn").textContent =
          currentLang.ui.tutorialButton;

        document.getElementById("character-select-title").textContent =
          currentLang.modals.characterSelectTitle;
        document.getElementById("select-socrates").textContent =
          currentLang.modals.selectSocrates;
        document.getElementById("select-plato").textContent =
          currentLang.modals.selectPlato;
        document.getElementById("close-eureka-modal-btn").textContent = "X";
        document.getElementById("close-tutorial-modal-btn").textContent = "X";
        document.getElementById("tutorial-modal-title").textContent =
          currentLang.modals.tutorialTitle;
        document.getElementById("alert-ok-btn").textContent =
          currentLang.ui.okButton;
        document.getElementById("prompt-cancel-btn").textContent =
          currentLang.ui.cancelButton;
        document.getElementById("prompt-confirm-btn").textContent =
          currentLang.ui.okButton;
        document.getElementById("prompt-input").placeholder =
          currentLang.modals.promptInputPlaceholder;

        document.getElementById("premise-selection-title").textContent =
          currentLang.modals.premiseSelectionTitle;
        document.getElementById("apply-rule-btn").textContent =
          currentLang.modals.applyRuleButton;
        document.getElementById("add-assumption-btn").textContent =
          currentLang.modals.addAssumptionButton;
        document.getElementById("cancel-assumption-btn").textContent =
          currentLang.ui.cancelAssumptionButton;

        const select = document.getElementById("inference-rule-select");
        select.innerHTML = `
            <optgroup label="${currentLang.inferenceRules.basic}">
                <option value="modusPonens">${currentLang.inferenceRules.modusPonens}</option>
                <option value="modusTollens">${currentLang.inferenceRules.modusTollens}</option>
                <option value="hypotheticalSyllogism">${currentLang.inferenceRules.hypotheticalSyllogism}</option>
                <option value="disjunctiveSyllogism">${currentLang.inferenceRules.disjunctiveSyllogism}</option>
                <option value="universalApplication">${currentLang.inferenceRules.universalApplication}</option>
                <option value="existentialInstantiation">${currentLang.inferenceRules.existentialInstantiation}</option>
                <option value="conjunctionElimination">${currentLang.inferenceRules.conjunctionElimination}</option>
                <option value="doubleNegationElimination">${currentLang.inferenceRules.doubleNegationElimination}</option>
            </optgroup>
            <optgroup label="${currentLang.inferenceRules.assumptionBased}">
                <option value="conditionalIntroduction" style="color:#27ae60; font-weight:normal;">${currentLang.inferenceRules.conditionalIntroduction}</option>
                <option value="reductioAdAbsurdum" style="color:#c0392b; font-weight:normal;">${currentLang.inferenceRules.reductioAdAbsurdum}</option>
            </optgroup>
            <optgroup label="${currentLang.inferenceRules.advanced}">
                <option value="proofByCases" style="color:#2980b9; font-weight:normal;">${currentLang.inferenceRules.proofByCases}</option>
            </optgroup>
        `;
      }

      function generateAxioms(subjectA, subjectB, langData) {
        const templates = langData.axiom_templates;
        const generated = [];

        generated.push(...templates.identity);

        templates.opposition_subjects.forEach((template) => {
          generated.push(template.replaceAll("{S}", subjectA));
        });

        templates.opposition_subjects.forEach((template) => {
          generated.push(template.replaceAll("{S}", subjectB));
        });

        generated.push(...templates.opposition_quantifiers);

        return generated;
      }

      function setupGame(selectedCharacters) {
        playerA_Data = PHILOSOPHERS[selectedCharacters.p1];
        playerB_Data = PHILOSOPHERS[selectedCharacters.p2];

        const p1_id = selectedCharacters.p1;
        const p2_id = selectedCharacters.p2;

        let p1_card_obj, p2_card_obj;
        let subjectA, subjectB;

        subjectA = playerA_Data.cardText[currentLang.langCode];
        subjectB = playerB_Data.cardText[currentLang.langCode];

        if (p1_id === p2_id) {
          if (currentLang.langCode === "ko") {
            subjectA = `${playerA_Data.name.ko}(ë°±)ëŠ”`;
            subjectB = `${playerB_Data.name.ko}(í‘)ì€`;
          } else {
            subjectA = `${playerA_Data.name.en} (White)`;
            subjectB = `${playerB_Data.name.en} (Black)`;
          }
          document.getElementById("player-a-title").innerHTML = `âšªï¸ ${
            playerA_Data.name[currentLang.langCode]
          }(ë°±)`;
          document.getElementById("player-b-title").innerHTML = `âš«ï¸ ${
            playerB_Data.name[currentLang.langCode]
          }(í‘)`;
        } else {
          document.getElementById("player-a-title").innerHTML = `âšªï¸ ${
            playerA_Data.name[currentLang.langCode]
          }`;
          document.getElementById("player-b-title").innerHTML = `âš«ï¸ ${
            playerB_Data.name[currentLang.langCode]
          }`;
        }

        const properNounType =
          currentLang.langCode === "ko" ? "ê³ ìœ ëª…ì‚¬" : "Proper Noun";
        p1_card_obj = { type: properNounType, text: subjectA };
        p2_card_obj = { type: properNounType, text: subjectB };

        const masterDeck = currentLang.cards;
        const allPhilosopherCardTexts = Object.values(PHILOSOPHERS).map(
          (p) => p.cardText[currentLang.langCode]
        );
        const baseDeck = masterDeck.filter(
          (card) => !allPhilosopherCardTexts.includes(card.text)
        );

        const currentGameDeck = [...baseDeck, p1_card_obj, p2_card_obj];
        fullDeck = currentGameDeck;

        const nonPlayerCards = ["ìŠ¹ë¦¬í•œë‹¤", "wins"];
        playerA_Hand = JSON.parse(
          JSON.stringify(
            fullDeck.filter((c) => !nonPlayerCards.includes(c.text))
          )
        );
        playerB_Hand = JSON.parse(
          JSON.stringify(
            fullDeck.filter((c) => !nonPlayerCards.includes(c.text))
          )
        );

        currentAxioms = generateAxioms(subjectA, subjectB, currentLang);

        parsedAxioms = currentAxioms
          .map((str) => ({
            type: "axiom",
            proposition: parsePropositionFromString(str),
          }))
          .filter((a) => a.proposition);

        internalTruthSet = parsedAxioms.map((a) => a.proposition);

        const { if: ifKeyword, wins, and } = currentLang.keywords;

        const predicateA =
          currentLang.victoryPredicates[
            Math.floor(Math.random() * currentLang.victoryPredicates.length)
          ];
        const victoryTextA = `((${subjectA} ${predicateA}) ${ifKeyword} (${subjectA} ${wins})) ${and} ((${subjectA} ${wins}) ${ifKeyword} ((${subjectA} ${predicateA})))`;
        const parsedVictoryA = parsePropositionFromString(victoryTextA);
        const ultimateTargetA = {
          type: "atomic",
          subject: subjectA,
          predicate: wins,
        };
        const coreGoalA = {
          type: "atomic",
          subject: subjectA,
          predicate: predicateA,
        };

        truePropositions.push({
          type: "victory",
          text: victoryTextA,
          owner: "A",
          proposition: parsedVictoryA,
          ultimate_target: ultimateTargetA,
          core_goal: coreGoalA,
        });
        if (parsedVictoryA) internalTruthSet.push(parsedVictoryA);

        const predicateB =
          currentLang.victoryPredicates[
            Math.floor(Math.random() * currentLang.victoryPredicates.length)
          ];
        const victoryTextB = `((${subjectB} ${predicateB}) ${ifKeyword} (${subjectB} ${wins})) ${and} ((${subjectB} ${wins}) ${ifKeyword} ((${subjectB} ${predicateB})))`;
        const parsedVictoryB = parsePropositionFromString(victoryTextB);
        const ultimateTargetB = {
          type: "atomic",
          subject: subjectB,
          predicate: wins,
        };
        const coreGoalB = {
          type: "atomic",
          subject: subjectB,
          predicate: predicateB,
        };

        truePropositions.push({
          type: "victory",
          text: victoryTextB,
          owner: "B",
          proposition: parsedVictoryB,
          ultimate_target: ultimateTargetB,
          core_goal: coreGoalB,
        });
        if (parsedVictoryB) internalTruthSet.push(parsedVictoryB);

        render();
        checkNextTurn();
      }

      function resetGame(selectedCharacters) {
        // â–¼â–¼â–¼â–¼â–¼ ì—¬ê¸°ì— ì•ˆì •ì„± ì½”ë“œ ì¶”ê°€ â–¼â–¼â–¼â–¼â–¼
        // ë§Œì•½ ì„ íƒëœ ìºë¦­í„° ì •ë³´ê°€ ì—†ë‹¤ë©´, ê¸°ë³¸ê°’ìœ¼ë¡œ ì†Œí¬ë¼í…ŒìŠ¤ì™€ í”Œë¼í†¤ì„ ì„¤ì •í•©ë‹ˆë‹¤.
        if (!selectedCharacters) {
          selectedCharacters = { p1: "socrates", p2: "plato" };
        }
        // â–²â–²â–²â–²â–² ì—¬ê¸°ê¹Œì§€ ì¶”ê°€ â–²â–²â–²â–²â–²

        clearAllAITimeouts();
        playerA_Hand = [];
        playerB_Hand = [];
        truePropositions = [];
        currentProposition = [];
        currentPlayer = "A";
        gameIsOver = false;
        currentRound = 1;
        isThinkingTime = false;

        document.getElementById("thinking-time-controls").style.display =
          "none";
        document.getElementById("status").innerHTML = "";

        setupGame(selectedCharacters);
      }
      // --- EVENT LISTENERS ---
      // MODIFIED Event Listeners
      document
        .getElementById("lang-en")
        .addEventListener("click", () => initializeGame("en"));
      document
        .getElementById("lang-ko")
        .addEventListener("click", () => initializeGame("ko"));

      document.getElementById("new-game-btn").addEventListener("click", () => {
        if (inTutorialMode) return;

        // í˜„ì¬ ê²Œì„ ëª¨ë“œê°€ ì„¤ì •ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
        if (gameMode) {
          clearAllAITimeouts(); // ì§„í–‰ ì¤‘ì¸ AI ë™ì‘ì´ ìˆë‹¤ë©´ ì¤‘ì§€
          // í˜„ì¬ ê²Œì„ ëª¨ë“œë¡œ ìºë¦­í„° ì„ íƒì„ ë‹¤ì‹œ ì‹œì‘í•©ë‹ˆë‹¤.
          startCharacterSelection(gameMode);
        } else {
          // í˜¹ì‹œ ëª¨ë“œê°€ ì„¤ì •ë˜ì§€ ì•Šì€ ì˜ˆì™¸ì ì¸ ê²½ìš°, ë©”ì¸ ë©”ë‰´ë¡œ ì´ë™í•©ë‹ˆë‹¤.
          showMainMenu();
        }
      });

      document.getElementById("vs-player-btn").addEventListener("click", () => {
        if (inTutorialMode) return;
        startCharacterSelection("2P");
      });
      document.getElementById("vs-ai-btn").addEventListener("click", () => {
        if (inTutorialMode) return;
        startCharacterSelection("AI");
      });

      // NEW Event Listener for the single confirm button
      document
        .getElementById("confirm-selection-btn")
        .addEventListener("click", handleConfirmClick);

      // Keep other event listeners like those for complete-btn, undo-btn, etc. as they are.

      document.getElementById("complete-btn").addEventListener("click", () => {
        if (!inTutorialMode) completeProposition();
      });
      document.getElementById("undo-btn").addEventListener("click", () => {
        if (!inTutorialMode) undoProposition();
      });
      document.getElementById("end-turn-btn").addEventListener("click", () => {
        if (!inTutorialMode) endTurn();
      });
      document.getElementById("eureka-a").addEventListener("click", () => {
        if (!inTutorialMode) declareEureka("A");
      });
      document.getElementById("eureka-b").addEventListener("click", () => {
        if (!inTutorialMode) declareEureka("B");
      });
      document
        .getElementById("close-eureka-modal-btn")
        .addEventListener("click", () => {
          if (!inTutorialMode)
            document.getElementById("eureka-modal").classList.remove("visible");
        });
      document
        .getElementById("close-tutorial-modal-btn")
        .addEventListener("click", () =>
          document.getElementById("tutorial-modal").classList.remove("visible")
        );
      document
        .getElementById("tutorial-btn")
        .addEventListener("click", startTutorial);
      document
        .getElementById("apply-rule-btn")
        .addEventListener("click", () => {
          if (!inTutorialMode) applyRule();
        });
      document
        .getElementById("add-assumption-btn")
        .addEventListener("click", addAssumption);
      document
        .getElementById("cancel-assumption-btn")
        .addEventListener("click", cancelAssumption);
      document
        .getElementById("end-thinking-time-btn")
        .addEventListener("click", () => {
          if (!inTutorialMode) endThinkingTime();
        });
      document
        .getElementById("alert-ok-btn")
        .addEventListener("click", () =>
          document.getElementById("alert-modal").classList.remove("visible")
        );
      document
        .getElementById("tutorial-next-btn")
        .addEventListener("click", advanceTutorial);

      // --- CHARACTER SELECTION LOGIC (NEW SECTION) ---

      function startCharacterSelection(mode) {
        selectionMode = mode;
        tempSelections = { p1: null, p2: null };

        document.querySelector(".main-center-bg").classList.add("hidden");
        document
          .getElementById("character-selection-screen")
          .classList.remove("hidden");

        updatePlayerDisplay("p1", null);
        updatePlayerDisplay("p2", null);
        document.getElementById("p1-ready-overlay").classList.remove("visible");
        document.getElementById("p2-ready-overlay").classList.remove("visible");

        if (mode === "AI") {
          const turnModal = document.getElementById("turn-order-modal");
          turnModal.classList.add("visible");

          document.getElementById("select-first-player").onclick = () => {
            humanPlayerId = "P1";
            aiPlayer = "B";
            turnModal.classList.remove("visible");
            beginPlayerSelectionTurn("P1");
          };
          document.getElementById("select-second-player").onclick = () => {
            humanPlayerId = "P2";
            aiPlayer = "A";
            turnModal.classList.remove("visible");
            beginPlayerSelectionTurn("P1");
          };
        } else {
          aiPlayer = null;
          humanPlayerId = null;
          beginPlayerSelectionTurn("P1");
        }
      }

      function beginPlayerSelectionTurn(player) {
        characterSelectionTurn = player;
        const statusEl = document.getElementById("status");
        const lang = currentLang.ui;

        let instruction =
          player === "P1" ? lang.selectP1Philosopher : lang.selectP2Philosopher;
        if (selectionMode === "AI") {
          instruction =
            player === humanPlayerId
              ? lang.selectYourPhilosopher
              : lang.selectAIPhilosopher;
        }
        statusEl.innerHTML = `<span class="turn-indicator">${instruction}</span>`;

        const grid = document.getElementById("shared-char-grid");
        grid.innerHTML = "";
        for (const key in PHILOSOPHERS) {
          const philosopher = PHILOSOPHERS[key];
          const iconEl = document.createElement("div");
          iconEl.className = "char-icon";
          iconEl.dataset.id = key;
          iconEl.style.backgroundImage = `url('${philosopher.icon}')`;
          iconEl.onclick = () => handleCharacterClick(key);
          grid.appendChild(iconEl);
        }

        if (selectionMode === "AI" && player !== humanPlayerId) {
          const available = Object.keys(PHILOSOPHERS).filter(
            (id) => id !== tempSelections.p1
          );
          const randomChoice =
            available[Math.floor(Math.random() * available.length)];
          handleCharacterClick(randomChoice);
          setTimeout(handleConfirmClick, 1000);
        }
      }

      function handleCharacterClick(philosopherId) {
        const targetPlayer = characterSelectionTurn === "P1" ? "p1" : "p2";
        tempSelections[targetPlayer] = philosopherId;
        updatePlayerDisplay(targetPlayer, philosopherId);

        document.querySelectorAll(".char-icon").forEach((icon) => {
          icon.classList.toggle("selected", icon.dataset.id === philosopherId);
        });

        document.getElementById("confirm-selection-btn").disabled = false;
      }

      function updatePlayerDisplay(player, philosopherId) {
        const portraitEl = document.getElementById(`${player}-portrait`);
        const nameEl = document.getElementById(`${player}-philosopher-name`);
        const skillDescEl = document.getElementById(`${player}-skill-desc`);

        if (philosopherId) {
          const p = PHILOSOPHERS[philosopherId];
          portraitEl.style.backgroundImage = `url('${p.image}')`;
          nameEl.textContent = p.name[currentLang.langCode];
          skillDescEl.textContent = p.skill[currentLang.langCode];
        } else {
          portraitEl.style.backgroundImage = "none";
          nameEl.textContent = "";
          skillDescEl.textContent = currentLang.ui.waitingForOpponent;
        }
      }

      function handleConfirmClick() {
        document.getElementById("confirm-selection-btn").disabled = true;

        if (characterSelectionTurn === "P1") {
          document.getElementById("p1-ready-overlay").classList.add("visible");
          beginPlayerSelectionTurn("P2");
        } else {
          document.getElementById("p2-ready-overlay").classList.add("visible");
          finalizeSelection();
        }
      }

      function finalizeSelection() {
        document.getElementById(
          "status"
        ).innerHTML = `<span class="turn-indicator">${currentLang.ui.gameStartingSoon}</span>`;

        setTimeout(() => {
          document
            .getElementById("character-selection-screen")
            .classList.add("hidden");
          document
            .getElementById("turn-order-modal")
            .classList.remove("visible");
          updateMainMenuBtnVisibility();
          updateMainCenterVisibility();
          resetGame(tempSelections);
        }, 2000);
      }

      function startTutorial() {
        // â–¼â–¼â–¼â–¼â–¼ ì—¬ê¸°ì— ì´ˆê¸°í™” ì½”ë“œ ì¶”ê°€ â–¼â–¼â–¼â–¼â–¼
        // íŠœí† ë¦¬ì–¼ ì‹œì‘ ì‹œ, ì² í•™ìë¥¼ ì†Œí¬ë¼í…ŒìŠ¤ì™€ í”Œë¼í†¤ìœ¼ë¡œ ê°•ì œ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
        playerA_Data = PHILOSOPHERS["socrates"];
        playerB_Data = PHILOSOPHERS["plato"];
        // â–²â–²â–²â–²â–² ì—¬ê¸°ê¹Œì§€ ì¶”ê°€ â–²â–²â–²â–²â–²

        inTutorialMode = true;
        tutorialStep = 0;
        tutorialSubStep = 0;

        const tutorialBtn = document.getElementById("tutorial-btn");
        tutorialBtn.textContent = currentLang.ui.endTutorialButton;
        tutorialBtn.removeEventListener("click", startTutorial);
        tutorialBtn.addEventListener("click", endTutorial);

        document.querySelector(".main-center-bg").classList.add("hidden");
        updateMainMenuBtnVisibility();
        updateMainCenterVisibility();

        document
          .querySelectorAll(
            ".header-buttons-left button, .header-buttons-right button"
          )
          .forEach((btn) => {
            if (btn.id !== "tutorial-btn" && btn.id !== "main-menu-btn") {
              btn.disabled = true;
            }
          });

        document.getElementById("tutorial-guide").classList.remove("hidden");
        document.getElementById("tutorial-next-btn").textContent =
          currentLang.ui.nextButton;

        setupTutorialScenario(1);
        advanceTutorial();
      }

      function advanceTutorial() {
        // Clear previous temporary listeners to prevent stacking
        if (temporaryListener) {
          temporaryListener.element.removeEventListener(
            temporaryListener.type,
            temporaryListener.handler
          );
          temporaryListener = null;
        }

        const script = currentLang.tutorial[tutorialStep];
        if (!script || tutorialSubStep >= script.length) {
          tutorialStep++;
          tutorialSubStep = 0;
          if (tutorialStep >= currentLang.tutorial.length) {
            endTutorial();
            return;
          }
          setupTutorialScenario(tutorialStep + 1); // Setup for the *next* stage
        }

        const newScript = currentLang.tutorial[tutorialStep];
        if (!newScript || tutorialSubStep >= newScript.length) {
          endTutorial();
          return;
        }

        const guideTextEl = document.getElementById("tutorial-text");
        const tutorialGuideEl = document.getElementById("tutorial-guide");
        const nextBtn = document.getElementById("tutorial-next-btn");
        guideTextEl.innerHTML = newScript[tutorialSubStep];
        nextBtn.classList.remove("hidden");

        // Reset position and highlights
        tutorialGuideEl.classList.remove("top");
        clearHighlights();

        handleTutorialStepLogic();

        tutorialSubStep++;
      }

      function handleTutorialStepLogic() {
        if (tutorialStep === 0) {
          // Stage 1
          switch (tutorialSubStep) {
            case 5:
              highlightElement("#player-a-hand");
              break;
            case 6:
              highlightElement("#proposition-display");
              break;
            case 7:
              const cardToClick = Array.from(
                document.querySelectorAll("#player-a-hand .card")
              ).find((c) => c.textContent === currentLang.keywords.socrates);
              if (cardToClick) {
                highlightElement(cardToClick);
                document
                  .getElementById("tutorial-next-btn")
                  .classList.add("hidden");
                waitForInteraction(cardToClick, "click", () => {
                  const cardData = playerA_Hand.find(
                    (c) => c.text === currentLang.keywords.socrates
                  );
                  playCardTutorial(cardData);
                  advanceTutorial();
                });
              }
              break;
            case 9:
              clearHighlights();
              const entityCards = Array.from(
                document.querySelectorAll("#player-a-hand .card")
              ).filter((c) => {
                const cardData = fullDeck.find(
                  (card) => card.text === c.textContent
                );
                return cardData && cardData.type === currentLang.cardTypes[2]; // ê°œì²´ or Entity
              });
              const quantifierCards = Array.from(
                document.querySelectorAll("#player-a-hand .card")
              ).filter((c) => {
                const cardData = fullDeck.find(
                  (card) => card.text === c.textContent
                );
                return cardData && cardData.type === currentLang.cardTypes[1]; // ì–‘í™”ì‚¬ or Quantifier
              });
              entityCards.forEach((card) =>
                card.classList.add("tutorial-highlight")
              );
              quantifierCards.forEach((card) =>
                card.classList.add("tutorial-highlight")
              );
              break;
            case 11:
              const endTurnBtn = document.getElementById("end-turn-btn");
              highlightElement(endTurnBtn);
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              waitForInteraction(endTurnBtn, "click", () => {
                endTurnTutorial();
                advanceTutorial();
              });
              break;
          }
        } else if (tutorialStep === 1) {
          // Stage 2
          switch (tutorialSubStep) {
            case 2:
              const completeBtn = document.getElementById("complete-btn");
              highlightElement(completeBtn);
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              waitForInteraction(completeBtn, "click", () => {
                completePropositionTutorial();
                advanceTutorial();
              });
              break;
            case 7:
              clearHighlights();
              const connectiveCards = Array.from(
                document.querySelectorAll("#player-a-hand .card")
              ).filter(
                (c) =>
                  c.textContent === currentLang.keywords.and ||
                  c.textContent === currentLang.keywords.or ||
                  c.textContent === currentLang.keywords.if
              );
              connectiveCards.forEach((card) =>
                card.classList.add("tutorial-highlight")
              );
              break;
            case 8:
              const negationCard = Array.from(
                document.querySelectorAll("#player-a-hand .card")
              ).find((c) => c.textContent === currentLang.keywords.not);
              if (negationCard) highlightElement(negationCard);
              break;
          }
        } else if (tutorialStep === 2) {
          // Stage 3
          switch (tutorialSubStep) {
            case 0:
              highlightElement("#true-propositions");
              break;
            case 1:
              const axiomSummary = document.querySelector(
                ".axiom-wrapper summary"
              );
              if (axiomSummary) {
                highlightElement(axiomSummary);
                document
                  .getElementById("tutorial-next-btn")
                  .classList.add("hidden");
                waitForInteraction(axiomSummary, "click", () => {
                  advanceTutorial();
                });
              }
              break;
            case 2:
            case 3:
            case 4:
              document.getElementById("tutorial-guide").classList.add("top");
              break;
          }
        } else if (tutorialStep === 3) {
          // Stage 4
          document.getElementById("tutorial-guide").classList.add("top");
          switch (tutorialSubStep) {
            case 2:
              const addTheoremBtn = document.getElementById("eureka-a");
              highlightElement(addTheoremBtn);
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              waitForInteraction(addTheoremBtn, "click", () => {
                openEurekaModalTutorial();
                advanceTutorial();
              });
              break;
            case 4:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? ["ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ê°œì´ë‹¤", "ëª¨ë“  ê°œëŠ” ì§€í˜œë¡­ë‹¤"]
                  : ["Socrates is a dog", "Every dog is wise"]
              );
              break;
            case 5:
              handleTutorialRuleApplication("universalApplication");
              break;
            case 6:
              const confirmBtn = document.getElementById("modal-confirm-btn");
              const newTheoremText =
                currentLang.langCode === "ko"
                  ? "ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì§€í˜œë¡­ë‹¤"
                  : "Socrates is wise";
              const newTheoremProp = parsePropositionFromString(newTheoremText);
              const theoremLi = Array.from(
                document.querySelectorAll("#premise-list li")
              ).find((li) => {
                const data = JSON.parse(li.dataset.propObject);
                return (
                  data.type === "theorem" &&
                  arePropositionsEqual(data.proposition, newTheoremProp)
                );
              });

              if (theoremLi && confirmBtn) {
                highlightElement(theoremLi);
                confirmBtn.classList.add("tutorial-highlight");
                document
                  .getElementById("tutorial-next-btn")
                  .classList.add("hidden");

                const confirmHandler = () => {
                  const checkbox = theoremLi.querySelector("input");
                  if (checkbox && checkbox.checked) {
                    addTheoremsToListTutorial();
                    advanceTutorial();
                  } else {
                    showAlert(
                      currentLang.langCode === "ko"
                        ? "ìƒˆë¡œ ë„ì¶œëœ ì •ë¦¬ë¥¼ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”."
                        : "Please select the newly derived theorem first."
                    );
                  }
                };
                waitForInteraction(confirmBtn, "click", confirmHandler);
              }
              break;
            case 7:
              const endThinkingBtn = document.getElementById(
                "end-thinking-time-btn"
              );
              highlightElement(endThinkingBtn);
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              waitForInteraction(endThinkingBtn, "click", () => {
                endThinkingTime();
                advanceTutorial();
              });
              break;
          }
        } else if (tutorialStep === 4) {
          // Stage 5 - Basic Rules
          document.getElementById("tutorial-guide").classList.add("top");
          switch (tutorialSubStep) {
            // Intro
            case 0:
              const eurekaBtn = document.getElementById("eureka-a");
              highlightElement(eurekaBtn);
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              waitForInteraction(eurekaBtn, "click", () => {
                openEurekaModalTutorial();
                advanceTutorial();
              });
              break;
            // Modus Ponens
            case 2:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? [
                      "ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤",
                      "(ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤) ë¼ë©´ (ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤)",
                    ]
                  : [
                      "Socrates is good",
                      "(Socrates is good) then (Socrates wins)",
                    ]
              );
              break;
            case 3:
              handleTutorialRuleApplication("modusPonens");
              break;
            // Modus Tollens
            case 5:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? [
                      "í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
                      "(í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤)",
                    ]
                  : [
                      "Plato is wise is false",
                      "(Plato wins) then (Plato is wise)",
                    ]
              );
              break;
            case 6:
              handleTutorialRuleApplication("modusTollens");
              break;
            // Disjunctive Syllogism
            case 8:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? [
                      "(ì–´ë–¤ ìƒˆëŠ” ë¬¼ê³ ê¸°ì´ë‹¤) ë˜ëŠ” (ì–´ë–¤ ìƒˆëŠ” ìƒˆì´ë‹¤)",
                      "ì–´ë–¤ ìƒˆëŠ” ë¬¼ê³ ê¸°ì´ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
                    ]
                  : [
                      "(Some bird is a fish) or (Some bird is a bird)",
                      "Some bird is a fish is false",
                    ]
              );
              break;
            case 9:
              handleTutorialRuleApplication("disjunctiveSyllogism");
              break;
            // Hypothetical Syllogism
            case 11:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? [
                      "(í”Œë¼í†¤ì€ ê°œì´ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì„ í•˜ë‹¤)",
                      "(í”Œë¼í†¤ì€ ì„ í•˜ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤)",
                    ]
                  : [
                      "(Plato is a dog) then (Plato is good)",
                      "(Plato is good) then (Plato wins)",
                    ]
              );
              break;
            case 12:
              handleTutorialRuleApplication("hypotheticalSyllogism");
              break;
            // Conjunction Elimination
            case 14:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? ["(ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì§€í˜œë¡­ë‹¤) ê·¸ë¦¬ê³  (í”Œë¼í†¤ì€ ì–´ë¦¬ì„ë‹¤)"]
                  : ["(Socrates is wise) and (Plato is foolish)"]
              );
              break;
            case 15:
              handleTutorialRuleApplication("conjunctionElimination");
              break;
            // Double Negation
            case 17:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? ["ì–´ë–¤ ë¬¼ê³ ê¸°ëŠ” ì„ í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤"]
                  : ["Some fish is good is false is false"]
              );
              break;
            case 18:
              handleTutorialRuleApplication("doubleNegationElimination");
              break;
            // Universal Application
            case 20:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? ["ëª¨ë“  ìƒˆëŠ” ì„ í•˜ë‹¤", "í”Œë¼í†¤ì€ ìƒˆì´ë‹¤"]
                  : ["Every bird is good", "Plato is a bird"]
              );
              break;
            case 21:
              handleTutorialRuleApplication("universalApplication");
              break;
            // Existential Instantiation
            case 23:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? ["ëª¨ë“  ê°œëŠ” ì„ í•˜ë‹¤"]
                  : ["Every dog is good"]
              );
              break;
            case 24:
              handleTutorialRuleApplication("existentialInstantiation");
              break;
          }
        } else if (tutorialStep === 5) {
          // Stage 6 - Advanced Rules (Proof by Cases)
          document.getElementById("tutorial-guide").classList.add("top");
          switch (tutorialSubStep) {
            case 1:
              const premises =
                currentLang.langCode === "ko"
                  ? [
                      "í”Œë¼í†¤ì€ ì„ í•˜ë‹¤ ë˜ëŠ” í”Œë¼í†¤ì€ ì•…í•˜ë‹¤",
                      "(í”Œë¼í†¤ì€ ì„ í•˜ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤)",
                      "(í”Œë¼í†¤ì€ ì•…í•˜ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤)",
                    ]
                  : [
                      "Plato is good or Plato is evil",
                      "(Plato is good) then (Plato is wise)",
                      "(Plato is evil) then (Plato is wise)",
                    ];
              handleTutorialRuleInteraction(premises);
              break;
            case 2:
              handleTutorialRuleApplication("proofByCases");
              break;
          }
        } else if (tutorialStep === 6) {
          // Stage 7 - Assumption (Conditional Intro) â˜…â˜…â˜… MODIFIED SECTION â˜…â˜…â˜…
          document.getElementById("tutorial-guide").classList.add("top");
          switch (tutorialSubStep) {
            case 1: // Assume
              highlightElement("#add-assumption-btn");
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              const correctAssumptionCI =
                currentLang.langCode === "ko"
                  ? "ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì§€í˜œë¡­ë‹¤"
                  : "Socrates is wise";
              const originalShowPrompt = window.showPrompt;
              window.showPrompt = (message, callback) => {
                originalShowPrompt(message, (value) => {
                  if (value === correctAssumptionCI) {
                    window.showPrompt = originalShowPrompt;
                    callback(value);
                    advanceTutorial();
                  } else {
                    showAlert(
                      currentLang.langCode === "ko"
                        ? "ì˜¬ë°”ë¥¸ ëª…ì œë¥¼ ì…ë ¥í•´ ì£¼ì‹­ì‹œì˜¤."
                        : "Please enter a valid proposition."
                    );
                    callback(null);
                  }
                });
              };
              break;
            case 2: // Select premises for 1st MP
              const premisesCI_1 =
                currentLang.langCode === "ko"
                  ? [
                      "ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì§€í˜œë¡­ë‹¤",
                      "(ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì§€í˜œë¡­ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ê°œì´ë‹¤)",
                    ]
                  : [
                      "Socrates is wise",
                      "(Socrates is wise) then (Plato is a dog)",
                    ];
              handleTutorialRuleInteraction(premisesCI_1);
              break;
            case 3: // Apply 1st MP
              handleTutorialRuleApplication("modusPonens");
              break;
            case 4: // Select premises for 2nd MP
              const premisesCI_2 =
                currentLang.langCode === "ko"
                  ? [
                      "í”Œë¼í†¤ì€ ê°œì´ë‹¤",
                      "(í”Œë¼í†¤ì€ ê°œì´ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì„ í•˜ë‹¤)",
                    ]
                  : ["Plato is a dog", "(Plato is a dog) then (Plato is good)"];
              handleTutorialRuleInteraction(premisesCI_2);
              break;
            case 5: // Apply 2nd MP
              handleTutorialRuleApplication("modusPonens");
              break;
            case 6: // Select final result
              const conclusionTextCI =
                currentLang.langCode === "ko"
                  ? "í”Œë¼í†¤ì€ ì„ í•˜ë‹¤"
                  : "Plato is good";
              const conclusionPropCI =
                parsePropositionFromString(conclusionTextCI);
              const conclusionLi = Array.from(
                document.querySelectorAll("#premise-list li")
              ).find((li) => {
                const data = JSON.parse(li.dataset.propObject);
                return (
                  data.dependsOnAssumption &&
                  arePropositionsEqual(data.proposition, conclusionPropCI)
                );
              });
              if (conclusionLi) {
                highlightElement(conclusionLi);
                document
                  .getElementById("tutorial-next-btn")
                  .classList.add("hidden");
                waitForInteraction(
                  document.getElementById("premise-list"),
                  "click",
                  () => {
                    const selectedCheckbox =
                      conclusionLi.querySelector("input");
                    const allCheckboxes = document.querySelectorAll(
                      "#premise-list input:checked"
                    );
                    if (
                      selectedCheckbox.checked &&
                      allCheckboxes.length === 1
                    ) {
                      advanceTutorial();
                    }
                  }
                );
              }
              break;
            case 7: // Apply CI
              handleTutorialRuleApplication("conditionalIntroduction");
              break;
          }
        } else if (tutorialStep === 7) {
          // Stage 8 - Assumption (RAA)
          document.getElementById("tutorial-guide").classList.add("top");
          switch (tutorialSubStep) {
            case 1:
              highlightElement("#add-assumption-btn");
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              const correctAssumptionRAA =
                currentLang.langCode === "ko"
                  ? "ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤"
                  : "Socrates is evil is false";
              const originalShowPrompt = window.showPrompt;
              window.showPrompt = (message, callback) => {
                originalShowPrompt(message, (value) => {
                  if (value === correctAssumptionRAA) {
                    window.showPrompt = originalShowPrompt;
                    callback(value);
                    advanceTutorial();
                  } else {
                    showAlert(
                      currentLang.langCode === "ko"
                        ? "ì˜¬ë°”ë¥¸ ëª…ì œë¥¼ ì…ë ¥í•´ ì£¼ì‹­ì‹œì˜¤."
                        : "Please enter a valid proposition."
                    );
                    callback(null);
                  }
                });
              };
              break;
            case 2:
              const premisesRAA_texts =
                currentLang.langCode === "ko"
                  ? [
                      "ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
                      "(ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤)",
                    ]
                  : [
                      "(Socrates is evil is false) then (Plato is wise)",
                      "Socrates is evil is false",
                    ];

              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              const premiseList_mp = document.getElementById("premise-list");
              const premiseProps_mp = premisesRAA_texts.map((text) =>
                parsePropositionFromString(text)
              );
              const premiseLis_mp = premiseProps_mp
                .map((prop) =>
                  Array.from(premiseList_mp.querySelectorAll("li")).find(
                    (li) => {
                      const data = JSON.parse(li.dataset.propObject);
                      return arePropositionsEqual(data.proposition, prop);
                    }
                  )
                )
                .filter(Boolean);

              premiseLis_mp.forEach((li) =>
                li.classList.add("tutorial-highlight")
              );
              document
                .getElementById("inference-rule-select")
                .classList.add("tutorial-highlight");
              document
                .getElementById("apply-rule-btn")
                .classList.add("tutorial-highlight");

              const applyBtn_mp = document.getElementById("apply-rule-btn");
              const select_mp = document.getElementById(
                "inference-rule-select"
              );

              const applyRuleHandler_mp = () => {
                const allChecked = premiseLis_mp.every(
                  (li) => li.querySelector("input").checked
                );
                const totalChecked =
                  premiseList_mp.querySelectorAll("input:checked").length;
                if (!allChecked || totalChecked !== premiseLis_mp.length) {
                  showAlert(
                    currentLang.langCode === "ko"
                      ? "ë¨¼ì € ê°€ì •ê³¼ ë‹¤ë¥¸ ì „ì œë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”."
                      : "Please select the assumption and the other premise first."
                  );
                  return;
                }

                if (select_mp.value === "modusPonens") {
                  applyRuleTutorial();
                  advanceTutorial(); // Advances to subStep 3
                } else {
                  showAlert(currentLang.alerts.ruleFailed);
                }
              };
              waitForInteraction(applyBtn_mp, "click", applyRuleHandler_mp);
              break;
            case 3:
              // This substep now just shows the result text.
              // The logic is handled in case 2.
              // We just need to clear highlights and let the user click "Next".
              clearHighlights();
              break;
            case 4: // This case now handles both selection and application for RAA.
              const contradictionPairTexts =
                currentLang.langCode === "ko"
                  ? ["í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤", "í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤"]
                  : ["Plato is wise", "Plato is wise is false"];

              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              const premiseList = document.getElementById("premise-list");
              const premiseProps = contradictionPairTexts.map((text) =>
                parsePropositionFromString(text)
              );
              const premiseLis = premiseProps
                .map((prop) =>
                  Array.from(premiseList.querySelectorAll("li")).find((li) => {
                    const data = JSON.parse(li.dataset.propObject);
                    return arePropositionsEqual(data.proposition, prop);
                  })
                )
                .filter(Boolean);

              premiseLis.forEach((li) =>
                li.classList.add("tutorial-highlight")
              );
              highlightElement("#inference-rule-select");
              document
                .getElementById("apply-rule-btn")
                .classList.add("tutorial-highlight");

              const applyBtn = document.getElementById("apply-rule-btn");
              const select = document.getElementById("inference-rule-select");

              const applyRuleHandler = () => {
                const allChecked = premiseLis.every(
                  (li) => li.querySelector("input").checked
                );
                const totalChecked =
                  premiseList.querySelectorAll("input:checked").length;
                if (!allChecked || totalChecked !== premiseLis.length) {
                  showAlert(
                    currentLang.langCode === "ko"
                      ? "ë¨¼ì € ëª¨ìˆœë˜ëŠ” ë‘ ì „ì œë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”."
                      : "Please select the two contradictory premises first."
                  );
                  return;
                }

                if (select.value === "reductioAdAbsurdum") {
                  applyRuleTutorial();
                  advanceTutorial(); // Advances to subStep 5
                } else {
                  showAlert(currentLang.alerts.ruleFailed);
                }
              };
              waitForInteraction(applyBtn, "click", applyRuleHandler);
              break;
            case 5: // This is the step where the RAA result is shown and DNE is expected
              clearHighlights();
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden"); // Hide the "Next" button

              const raaResultText =
                currentLang.langCode === "ko"
                  ? "ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤"
                  : "Socrates is evil is false is false";
              const raaResultProp = parsePropositionFromString(raaResultText);

              const premiseListForDNE = document.getElementById("premise-list");
              const raaResultLi = Array.from(
                premiseListForDNE.querySelectorAll("li")
              ).find((li) => {
                const data = JSON.parse(li.dataset.propObject);
                // Check if it's a theorem derived from RAA and matches the expected proposition
                return (
                  data.type === "theorem" &&
                  data.label === currentLang.labels.raa_theorem &&
                  arePropositionsEqual(data.proposition, raaResultProp)
                );
              });

              if (raaResultLi) {
                highlightElement(raaResultLi); // Highlight the RAA result
                highlightElement("#inference-rule-select"); // Highlight the rule dropdown
                document
                  .getElementById("apply-rule-btn")
                  .classList.add("tutorial-highlight"); // Highlight the apply button

                const applyBtnDNE = document.getElementById("apply-rule-btn");
                const selectDNE = document.getElementById(
                  "inference-rule-select"
                );

                const applyRuleHandlerDNE = () => {
                  const selectedCheckboxes = premiseListForDNE.querySelectorAll(
                    'input[type="checkbox"]:checked'
                  );
                  const isRaaResultSelected = Array.from(
                    selectedCheckboxes
                  ).some((chk) => chk.parentElement === raaResultLi);

                  // Check if exactly one premise is selected, it's the RAA result, and DNE rule is chosen
                  if (
                    selectedCheckboxes.length === 1 &&
                    isRaaResultSelected &&
                    selectDNE.value === "doubleNegationElimination"
                  ) {
                    applyRuleTutorial(); // Apply the rule
                    advanceTutorial(); // Proceed to the next tutorial step
                  } else {
                    showAlert(currentLang.alerts.ruleFailed); // Show error if conditions not met
                  }
                };
                waitForInteraction(applyBtnDNE, "click", applyRuleHandlerDNE);
              } else {
                // Fallback if RAA result not found (shouldn't happen in normal tutorial flow)
                console.error(
                  "Tutorial Error: RAA result not found for DNE step."
                );
                advanceTutorial(); // Proceed to next step if something went wrong
              }
              break;
            case 6: // This is the final text step
              clearHighlights();
              // No specific interaction needed, just display text and allow "Next" to end tutorial
              break;
          }
        }
      }

      function handleTutorialRuleInteraction(premiseTexts) {
        document.getElementById("tutorial-next-btn").classList.add("hidden");
        const premiseList = document.getElementById("premise-list");
        const premiseProps = premiseTexts.map((text) =>
          parsePropositionFromString(text)
        );
        const premiseLis = premiseProps
          .map((prop) =>
            Array.from(premiseList.querySelectorAll("li")).find((li) => {
              const data = JSON.parse(li.dataset.propObject);
              return arePropositionsEqual(data.proposition, prop);
            })
          )
          .filter(Boolean);

        if (premiseLis.length !== premiseTexts.length) {
          console.error(
            "Tutorial Error: Could not find all required premises in the list.",
            premiseTexts
          );
          return;
        }

        premiseLis.forEach((li) => li.classList.add("tutorial-highlight"));

        const checkPremises = () => {
          const allChecked = premiseLis.every(
            (li) => li.querySelector("input").checked
          );
          const totalChecked =
            premiseList.querySelectorAll("input:checked").length;
          if (allChecked && totalChecked === premiseLis.length) {
            advanceTutorial();
          }
        };
        waitForInteraction(premiseList, "click", checkPremises);
      }

      function handleTutorialRuleApplication(ruleValue) {
        document.getElementById("tutorial-next-btn").classList.add("hidden");
        highlightElement("#inference-rule-select");
        document
          .getElementById("apply-rule-btn")
          .classList.add("tutorial-highlight");

        const applyBtn = document.getElementById("apply-rule-btn");
        const select = document.getElementById("inference-rule-select");

        const applyRuleHandler = () => {
          if (select.value === ruleValue) {
            applyRuleTutorial();
            advanceTutorial();
          } else {
            showAlert(currentLang.alerts.ruleFailed);
          }
        };
        waitForInteraction(applyBtn, "click", applyRuleHandler);
      }

      function setupTutorialScenario(step) {
        if (step === 1) {
          // Initial setup for the whole tutorial.
          playerA_Hand = [];
          playerB_Hand = [];
          truePropositions = [];

          // íŠœí† ë¦¬ì–¼ì€ ì†Œí¬ë¼í…ŒìŠ¤ì™€ í”Œë¼í†¤ì„ ê¸°ì¤€ìœ¼ë¡œ ê³µë¦¬ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
          const socratesSubject = currentLang.keywords.socrates;
          const platoSubject = currentLang.keywords.plato;
          currentAxioms = generateAxioms(
            socratesSubject,
            platoSubject,
            currentLang
          );

          parsedAxioms = currentAxioms
            .map((str) => ({
              type: "axiom",
              proposition: parsePropositionFromString(str),
            }))
            .filter((a) => a.proposition);
          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentProposition = [];
          currentPlayer = "A";
          propositionStarter = "A";
          gameIsOver = false;
          currentRound = 1;
          isThinkingTime = false;
          lastPropositionMaker = null;
          currentAssumption = null;
          lastCardPlayer = null;
          cardsPlayedThisTurn = { A: 0, B: 0 };
          gameMode = "2P";

          const socratesCardText = currentLang.keywords.socrates;
          const requiredA_CardTexts = [
            socratesCardText,
            currentLang.keywords.and,
            currentLang.keywords.or,
            currentLang.keywords.if,
            currentLang.keywords.not,
            currentLang.langCode === "ko" ? "ê°œëŠ”" : "dog",
            currentLang.langCode === "ko" ? "ìƒˆëŠ”" : "bird",
            currentLang.langCode === "ko" ? "ë¬¼ê³ ê¸°ëŠ”" : "fish",
            currentLang.keywords.universal_q,
            currentLang.keywords.existential_q,
          ];
          playerA_Hand = fullDeck.filter((c) =>
            requiredA_CardTexts.includes(c.text)
          );

          const wiseCardText =
            currentLang.langCode === "ko" ? "ì§€í˜œë¡­ë‹¤" : "is wise";
          const requiredB_CardTexts = [
            wiseCardText,
            currentLang.keywords.plato,
          ];
          playerB_Hand = fullDeck.filter((c) =>
            requiredB_CardTexts.includes(c.text)
          );
          playerB_Hand.push(
            ...fullDeck
              .filter(
                (c) =>
                  !requiredB_CardTexts.includes(c.text) &&
                  c.type ===
                    (currentLang.langCode === "ko" ? "ì„œìˆ ì–´" : "Predicate")
              )
              .slice(0, 2)
          );
        } else if (step === 2) {
          const socratesCardInfo = currentProposition.find(
            (info) => info.card.text === currentLang.keywords.socrates
          );
          const wiseCardText =
            currentLang.langCode === "ko" ? "ì§€í˜œë¡­ë‹¤" : "is wise";
          const wiseCardIndex = playerB_Hand.findIndex(
            (c) => c.text === wiseCardText
          );

          if (socratesCardInfo && wiseCardIndex > -1) {
            const [wiseCard] = playerB_Hand.splice(wiseCardIndex, 1);
            currentProposition = [
              socratesCardInfo,
              { card: wiseCard, player: "B" },
            ];
            lastCardPlayer = "B";
            currentPlayer = "A";
          }
        } else if (step === 4) {
          currentProposition = [];
          playerA_Hand = fullDeck.filter(
            (c) =>
              c.type ===
                (currentLang.langCode === "ko" ? "ì—°ì‚°ì" : "Operator") &&
              c.text !== currentLang.keywords.not
          );
          playerB_Hand = fullDeck.filter(
            (c) =>
              c.type ===
                (currentLang.langCode === "ko" ? "ì„œìˆ ì–´" : "Predicate") &&
              c.text !== (currentLang.langCode === "ko" ? "ê°œì´ë‹¤" : "is a dog")
          );

          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);

          const premises = [
            currentLang.langCode === "ko"
              ? "ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ê°œì´ë‹¤"
              : "Socrates is a dog",
            currentLang.langCode === "ko"
              ? "ëª¨ë“  ê°œëŠ” ì§€í˜œë¡­ë‹¤"
              : "Every dog is wise",
          ];
          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (parsed) {
              truePropositions.push({
                type: "user-made",
                text: pText,
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
          startThinkingTime();
        } else if (step === 5) {
          // Setup for all basic inference rules
          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentPlayer = "A";
          isThinkingTime = false;
          document.getElementById("thinking-time-controls").style.display =
            "none";

          const premises = [
            // For Modus Ponens
            currentLang.langCode === "ko"
              ? "ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤"
              : "Socrates is good",
            currentLang.langCode === "ko"
              ? "(ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤) ë¼ë©´ (ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤)"
              : "(Socrates is good) then (Socrates wins)",
            // For Modus Tollens
            currentLang.langCode === "ko"
              ? "í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤"
              : "Plato is wise is false",
            currentLang.langCode === "ko"
              ? "(í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤)"
              : "(Plato wins) then (Plato is wise)",
            // For Disjunctive Syllogism
            currentLang.langCode === "ko"
              ? "(ì–´ë–¤ ìƒˆëŠ” ë¬¼ê³ ê¸°ì´ë‹¤) ë˜ëŠ” (ì–´ë–¤ ìƒˆëŠ” ìƒˆì´ë‹¤)"
              : "(Some bird is a fish) or (Some bird is a bird)",
            currentLang.langCode === "ko"
              ? "ì–´ë–¤ ìƒˆëŠ” ë¬¼ê³ ê¸°ì´ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤"
              : "Some bird is a fish is false",
            // For Hypothetical Syllogism
            currentLang.langCode === "ko"
              ? "(í”Œë¼í†¤ì€ ê°œì´ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì„ í•˜ë‹¤)"
              : "(Plato is a dog) then (Plato is good)",
            currentLang.langCode === "ko"
              ? "(í”Œë¼í†¤ì€ ì„ í•˜ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤)"
              : "(Plato is good) then (Plato wins)",
            // For Simplification
            currentLang.langCode === "ko"
              ? "(ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì§€í˜œë¡­ë‹¤) ê·¸ë¦¬ê³  (í”Œë¼í†¤ì€ ì–´ë¦¬ì„ë‹¤)"
              : "(Socrates is wise) and (Plato is foolish)",
            // For Double Negation
            currentLang.langCode === "ko"
              ? "ì–´ë–¤ ë¬¼ê³ ê¸°ëŠ” ì„ í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤"
              : "Some fish is good is false is false",
            // For Universal Application
            currentLang.langCode === "ko"
              ? "ëª¨ë“  ìƒˆëŠ” ì„ í•˜ë‹¤"
              : "Every bird is good",
            currentLang.langCode === "ko"
              ? "í”Œë¼í†¤ì€ ìƒˆì´ë‹¤"
              : "Plato is a bird",
            // For Existential Instantiation
            currentLang.langCode === "ko"
              ? "ëª¨ë“  ê°œëŠ” ì„ í•˜ë‹¤"
              : "Every dog is good",
          ];

          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (
              parsed &&
              !internalTruthSet.some((p) => arePropositionsEqual(p, parsed))
            ) {
              truePropositions.push({
                type: "user-made",
                text: pText,
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
        } else if (step === 6) {
          // Setup for Proof by Cases
          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentPlayer = "A";
          isThinkingTime = false;
          document.getElementById("thinking-time-controls").style.display =
            "none";

          const premises =
            currentLang.langCode === "ko"
              ? [
                  "í”Œë¼í†¤ì€ ì„ í•˜ë‹¤ ë˜ëŠ” í”Œë¼í†¤ì€ ì•…í•˜ë‹¤",
                  "(í”Œë¼í†¤ì€ ì„ í•˜ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤)",
                  "(í”Œë¼í†¤ì€ ì•…í•˜ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤)",
                ]
              : [
                  "Plato is good or Plato is evil",
                  "(Plato is good) then (Plato is wise)",
                  "(Plato is evil) then (Plato is wise)",
                ];

          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (
              parsed &&
              !internalTruthSet.some((p) => arePropositionsEqual(p, parsed))
            ) {
              truePropositions.push({
                type: "user-made",
                text: pText,
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
          openEurekaModalTutorial();
        } else if (step === 7) {
          // Setup for Conditional Introduction â˜…â˜…â˜… MODIFIED SECTION â˜…â˜…â˜…
          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentPlayer = "A";
          isThinkingTime = false;
          document.getElementById("thinking-time-controls").style.display =
            "none";
          const premises =
            currentLang.langCode === "ko"
              ? [
                  "(ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì§€í˜œë¡­ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ê°œì´ë‹¤)",
                  "(í”Œë¼í†¤ì€ ê°œì´ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì„ í•˜ë‹¤)",
                ]
              : [
                  "(Socrates is wise) then (Plato is a dog)",
                  "(Plato is a dog) then (Plato is good)",
                ];

          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (parsed) {
              truePropositions.push({
                type: "user-made",
                text: propositionToNaturalText(parsed),
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
          openEurekaModalTutorial();
        } else if (step === 8) {
          // Setup for Reductio ad Absurdum
          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentPlayer = "A";
          isThinkingTime = false;
          document.getElementById("thinking-time-controls").style.display =
            "none";
          const premises =
            currentLang.langCode === "ko"
              ? [
                  "(ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤)",
                  "í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
                ]
              : [
                  "(Socrates is evil is false) then (Plato is wise)",
                  "Plato is wise is false",
                ];

          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (
              parsed &&
              !internalTruthSet.some((p) => arePropositionsEqual(p, parsed))
            ) {
              truePropositions.push({
                type: "user-made",
                text: pText,
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
          openEurekaModalTutorial();
        }
        render();
      }

      function playCardTutorial(cardToPlay) {
        const hand = currentPlayer === "A" ? playerA_Hand : playerB_Hand;
        const cardIndex = hand.findIndex(
          (c) => c.text === cardToPlay.text && c.type === cardToPlay.type
        );

        if (cardIndex > -1) {
          const [playedCard] = hand.splice(cardIndex, 1);
          currentProposition.push({ card: playedCard, player: currentPlayer });
          cardsPlayedThisTurn[currentPlayer]++;
          lastCardPlayer = currentPlayer;
          render();
        }
      }

      function endTurnTutorial() {
        currentPlayer = currentPlayer === "A" ? "B" : "A";
        cardsPlayedThisTurn.A = 0;
        cardsPlayedThisTurn.B = 0;
        render();
      }

      function completePropositionTutorial() {
        const parsedProp = parsePropositionFromCards([...currentProposition]);
        if (parsedProp) {
          truePropositions.push({
            type: "user-made",
            round: currentRound,
            proposition: parsedProp,
            original_cards: [...currentProposition],
          });
          lastPropositionMaker =
            currentProposition[currentProposition.length - 1].player;
          currentPlayer = lastPropositionMaker === "A" ? "B" : "A";
          currentProposition = [];
          lastCardPlayer = null;
          cardsPlayedThisTurn = { A: 0, B: 0 };
          render();
        }
      }

      function openEurekaModalTutorial() {
        derivedPropositionsInModal = [];
        currentAssumption = null;
        const modal = document.getElementById("eureka-modal");
        const premiseList = document.getElementById("premise-list");
        premiseList.innerHTML = "";

        const allSelectablePropositions = [
          ...parsedAxioms,
          ...truePropositions.filter(
            (p) => p.type === "user-made" || p.type === "theorem"
          ),
        ];
        allSelectablePropositions.forEach((propData) => {
          let label;
          switch (propData.type) {
            case "axiom":
              label = currentLang.labels.axiom;
              break;
            case "victory":
              label = currentLang.labels.victory_condition;
              break;
            case "theorem":
              label = currentLang.labels.theorem;
              break;
            default:
              label = currentLang.labels.proposition;
          }
          addPremiseToWorkbench({
            proposition: propData.proposition,
            type: propData.type,
            dependsOnAssumption: false,
            isAssumption: false,
            label: label,
          });
        });

        const modalTitle = document.getElementById("eureka-title");
        const confirmBtn = document.getElementById("modal-confirm-btn");
        modalTitle.textContent = isThinkingTime
          ? currentLang.modals.eurekaTitleTheorem
          : currentLang.modals.eurekaTitleVictory;
        confirmBtn.textContent = isThinkingTime
          ? currentLang.modals.confirmTheoremButton
          : currentLang.modals.confirmVictoryButton;

        document.getElementById("cancel-assumption-btn").style.display =
          currentAssumption ? "inline-block" : "none";

        renderModal();
        modal.classList.add("visible");
      }

      function applyRuleTutorial() {
        const selectedLis = Array.from(
          document.querySelectorAll(
            '#premise-list input[type="checkbox"]:checked'
          )
        );
        const rule = document.getElementById("inference-rule-select").value;
        const premisesData = selectedLis
          .map((chk) => {
            const propString = chk.parentElement.dataset.propObject;
            return propString ? JSON.parse(propString) : null;
          })
          .filter(Boolean);

        const premises = premisesData.map((data) => data.proposition);
        let conclusions = [];

        const onePremiseRules = [
          "conjunctionElimination",
          "doubleNegationElimination",
          "existentialInstantiation",
        ];
        const twoPremiseRules = [
          "modusPonens",
          "modusTollens",
          "hypotheticalSyllogism",
          "disjunctiveSyllogism",
          "universalApplication",
        ];
        const threePremiseRules = ["proofByCases"];

        if (rule === "conditionalIntroduction") {
          const result = {
            type: "conditional",
            left: currentAssumption,
            right: premises[0],
          };
          if (result) {
            derivedPropositionsInModal = derivedPropositionsInModal.filter(
              (p) => !p.dependsOnAssumption
            );
            currentAssumption = null;
            addPremiseToWorkbench({
              proposition: result,
              type: "theorem",
              dependsOnAssumption: false,
              isAssumption: false,
              label: currentLang.labels.ci_theorem,
            });
          }
        } else if (rule === "reductioAdAbsurdum") {
          const result = reductioAdAbsurdum(
            premises[0],
            premises[1],
            currentAssumption
          );
          if (result) {
            derivedPropositionsInModal = derivedPropositionsInModal.filter(
              (p) => !p.dependsOnAssumption
            );
            currentAssumption = null;
            addPremiseToWorkbench({
              proposition: result,
              type: "theorem",
              dependsOnAssumption: false,
              isAssumption: false,
              label: currentLang.labels.raa_theorem,
            });
          }
        } else if (threePremiseRules.includes(rule)) {
          const result = window[rule](premises[0], premises[1], premises[2]);
          if (result) conclusions.push(result);
        } else if (twoPremiseRules.includes(rule)) {
          const result = window[rule](premises[0], premises[1]);
          if (result) conclusions.push(result);
        } else if (onePremiseRules.includes(rule)) {
          const result = window[rule](premises[0]);
          if (result) {
            if (Array.isArray(result)) conclusions.push(...result);
            else conclusions.push(result);
          }
        }

        if (conclusions.length > 0 && conclusions[0] != null) {
          const isDependent = premisesData.some((p) => p.dependsOnAssumption);
          conclusions.forEach((conc) => {
            addPremiseToWorkbench({
              proposition: conc,
              type: "theorem",
              dependsOnAssumption: isDependent,
              isAssumption: false,
              label: currentLang.labels.theorem,
            });
          });
        }
        renderModal();
      }

      function addTheoremsToListTutorial() {
        const selectedLis = Array.from(
          document.querySelectorAll(
            '#premise-list input[type="checkbox"]:checked'
          )
        );
        const newTheorems = selectedLis
          .map((li) => {
            const propString = li.parentElement.dataset.propObject;
            return propString ? JSON.parse(propString) : null;
          })
          .filter((p) => p && p.type === "theorem" && !p.dependsOnAssumption);

        newTheorems.forEach((theoremData) => {
          const isDuplicate = truePropositions.some((p) =>
            arePropositionsEqual(p.proposition, theoremData.proposition)
          );
          if (!isDuplicate) {
            truePropositions.push({
              type: "theorem",
              round: currentRound,
              proposition: theoremData.proposition,
            });
          }
        });
        document.getElementById("eureka-modal").classList.remove("visible");
        render();
      }

      function highlightElement(elementOrSelector, remove = false) {
        clearHighlights();
        if (remove) return;

        const element =
          typeof elementOrSelector === "string"
            ? document.querySelector(elementOrSelector)
            : elementOrSelector;
        if (element) {
          element.classList.add("tutorial-highlight");
        }
      }

      function clearHighlights() {
        document
          .querySelectorAll(".tutorial-highlight")
          .forEach((el) => el.classList.remove("tutorial-highlight"));
      }

      function waitForInteraction(element, eventType, callback) {
        if (temporaryListener) {
          temporaryListener.element.removeEventListener(
            temporaryListener.type,
            temporaryListener.handler
          );
        }
        const handler = (event) => {
          // For checkbox clicks, we don't want to stop propagation
          if (eventType !== "click" || event.target.type !== "checkbox") {
            event.stopPropagation();
          }
          callback(event);
        };
        element.addEventListener(eventType, handler, {
          once: eventType !== "click",
        });

        temporaryListener = { element, type: eventType, handler };
      }

      // ê¸°ì¡´ endTutorial í•¨ìˆ˜ë¥¼ ì•„ë˜ ì½”ë“œë¡œ êµì²´í•˜ì„¸ìš”.
      function endTutorial() {
        inTutorialMode = false;
        document.getElementById("tutorial-guide").classList.add("hidden");
        clearHighlights();

        const tutorialBtn = document.getElementById("tutorial-btn");
        tutorialBtn.textContent = currentLang.ui.tutorialButton;
        tutorialBtn.removeEventListener("click", endTutorial);
        tutorialBtn.addEventListener("click", startTutorial);

        document
          .querySelectorAll(
            ".header-buttons-left button, .header-buttons-right button"
          )
          .forEach((btn) => {
            btn.disabled = false;
          });
        document.getElementById("eureka-modal").classList.remove("visible");

        // â–¼â–¼â–¼â–¼â–¼ ì´ ë¶€ë¶„ì„ ìˆ˜ì •í•©ë‹ˆë‹¤ â–¼â–¼â–¼â–¼â–¼
        // resetGame() ëŒ€ì‹  ë©”ì¸ ë©”ë‰´ë¥¼ í‘œì‹œí•˜ì—¬ ìƒíƒœë¥¼ ì™„ì „íˆ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
        showMainMenu();
        // â–²â–²â–²â–²â–² ì—¬ê¸°ê¹Œì§€ ìˆ˜ì • â–²â–²â–²â–²â–²
      }

      function showAlert(message, callback) {
        const modal = document.getElementById("alert-modal");
        document.getElementById("alert-message").textContent = message;
        modal.classList.add("visible");

        // ê¸°ì¡´ ì´ë²¤íŠ¸ ì œê±°
        const okBtn = document.getElementById("alert-ok-btn");
        const newBtn = okBtn.cloneNode(true);
        okBtn.parentNode.replaceChild(newBtn, okBtn);

        newBtn.addEventListener("click", () => {
          modal.classList.remove("visible");
          if (callback) callback();
        });
      }

      function showPrompt(message, callback) {
        const modal = document.getElementById("prompt-modal");
        document.getElementById("prompt-message").textContent = message;
        const input = document.getElementById("prompt-input");
        const confirmBtn = document.getElementById("prompt-confirm-btn");
        const cancelBtn = document.getElementById("prompt-cancel-btn");
        input.value = "";

        const confirmHandler = () => {
          cleanup();
          callback(input.value);
        };
        const cancelHandler = () => {
          cleanup();
          callback(null);
        };
        const cleanup = () => {
          modal.classList.remove("visible");
          confirmBtn.removeEventListener("click", confirmHandler);
          cancelBtn.removeEventListener("click", cancelHandler);
        };

        confirmBtn.addEventListener("click", confirmHandler);
        cancelBtn.addEventListener("click", cancelHandler);
        modal.classList.add("visible");
        input.focus();
      }

      // --- GAME FLOW & TURN MANAGEMENT ---
      function modusPonens(p1, p2) {
        if (!p1 || !p2) return null;
        if (p2.type === "conditional" && arePropositionsEqual(p1, p2.left))
          return p2.right;
        if (p1.type === "conditional" && arePropositionsEqual(p2, p1.left))
          return p1.right;
        return null;
      }

      function modusTollens(p1, p2) {
        if (!p1 || !p2) return null;
        const check = (c, o) => {
          if (c.type !== "conditional") return null;
          const consequent = c.right;
          let isContradiction = false;
          if (
            o.type === "negation" &&
            arePropositionsEqual(o.proposition, consequent)
          ) {
            isContradiction = true;
          }
          if (
            consequent.type === "negation" &&
            arePropositionsEqual(consequent.proposition, o)
          ) {
            isContradiction = true;
          }
          if (isContradiction) {
            return { type: "negation", proposition: c.left };
          }
          return null;
        };
        return check(p1, p2) || check(p2, p1);
      }

      function disjunctiveSyllogism(p1, p2) {
        /**
         * ë‘ ëª…ì œê°€ ì„œë¡œ ëª¨ìˆœ ê´€ê³„ì¸ì§€ í™•ì¸í•˜ëŠ” í—¬í¼ í•¨ìˆ˜.
         * ì˜ˆ: (P, ~P) ë˜ëŠ” (~P, P)ëŠ” ì°¸ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
         * @param {object} propA - ëª…ì œ ê°ì²´ 1
         * @param {object} propB - ëª…ì œ ê°ì²´ 2
         * @returns {boolean} ëª¨ìˆœ ê´€ê³„ì´ë©´ true
         */
        const areContradictory = (propA, propB) => {
          // propAê°€ ~Xì´ê³  propBê°€ Xì¸ ê²½ìš°
          if (
            propA.type === "negation" &&
            arePropositionsEqual(propA.proposition, propB)
          ) {
            return true;
          }
          // propBê°€ ~Xì´ê³  propAê°€ Xì¸ ê²½ìš°
          if (
            propB.type === "negation" &&
            arePropositionsEqual(propB.proposition, propA)
          ) {
            return true;
          }
          return false;
        };

        /**
         * ì„ ì–¸ì  ì‚¼ë‹¨ë…¼ë²•ì„ ì ìš©í•˜ëŠ” ë‚´ë¶€ í•¨ìˆ˜.
         * @param {object} d - disjunction íƒ€ì…ìœ¼ë¡œ ì¶”ì •ë˜ëŠ” ëª…ì œ
         * @param {object} o - ë‚˜ë¨¸ì§€ ëª…ì œ
         * @returns {object|null} ì¶”ë¡  ê²°ê³¼ ë˜ëŠ” null
         */
        const check = (d, o) => {
          if (d.type !== "disjunction") return null;

          // ë‹¤ë¥¸ ì „ì œ(o)ê°€ ì„ ì–¸ë¬¸ì˜ ì™¼ìª½ ë¶€ë¶„(d.left)ê³¼ ëª¨ìˆœ ê´€ê³„ì¼ ë•Œ
          // ì˜ˆ: (P âˆ¨ Q)ì™€ ~Pê°€ ì£¼ì–´ì§€ë©´ Që¥¼ ë°˜í™˜ (ì´ë•Œ ~PëŠ” ~~Pì™€ë„ ëª¨ìˆœ)
          if (areContradictory(d.left, o)) {
            return d.right;
          }

          // ë‹¤ë¥¸ ì „ì œ(o)ê°€ ì„ ì–¸ë¬¸ì˜ ì˜¤ë¥¸ìª½ ë¶€ë¶„(d.right)ê³¼ ëª¨ìˆœ ê´€ê³„ì¼ ë•Œ
          // ì˜ˆ: (P âˆ¨ Q)ì™€ ~Qê°€ ì£¼ì–´ì§€ë©´ Pë¥¼ ë°˜í™˜
          if (areContradictory(d.right, o)) {
            return d.left;
          }

          return null;
        };

        // p1, p2 ìˆœì„œì™€ p2, p1 ìˆœì„œ ëª¨ë‘ í™•ì¸
        return check(p1, p2) || check(p2, p1);
      }

      function conjunctionIntroduction(p1, p2) {
        if (!p1 || !p2) return null;
        return { type: "conjunction", left: p1, right: p2 };
      }

      function conjunctionElimination(p) {
        if (p && p.type === "conjunction") return [p.left, p.right];
        return null;
      }

      function doubleNegationElimination(p) {
        if (p && p.type === "negation" && p.proposition.type === "negation")
          return p.proposition.proposition;
        return null;
      }

      function hypotheticalSyllogism(p1, p2) {
        if (!p1 || !p2) return null;
        const check = (c1, c2) => {
          if (
            c1.type === "conditional" &&
            c2.type === "conditional" &&
            arePropositionsEqual(c1.right, c2.left)
          )
            return { type: "conditional", left: c1.left, right: c2.right };
          return null;
        };
        return check(p1, p2) || check(p2, p1);
      }

      function existentialInstantiation(p) {
        if (p && p.type === "universal") {
          return {
            type: "existential",
            entity: p.entity,
            predicate: p.predicate,
          };
        }
        return null;
      }

      function universalApplication(p1, p2) {
        if (!p1 || !p2) return null;
        const getBaseNoun = (text) => {
          if (currentLang.langCode === "ko") {
            return text.replace(/(ì´ë‹¤|ëŠ”|ì€)$/, "").trim();
          } else {
            return text.replace(/^is a /, "").trim();
          }
        };
        const check = (propA, propB) => {
          if (propA.type === "atomic" && propB.type === "universal") {
            const atomicPredicateBase = getBaseNoun(propA.predicate);
            const universalEntityBase = getBaseNoun(propB.entity);
            if (atomicPredicateBase === universalEntityBase) {
              return {
                type: "atomic",
                subject: propA.subject,
                predicate: propB.predicate,
              };
            }
          }
          if (propA.type === "existential" && propB.type === "universal") {
            const existentialPredicateBase = getBaseNoun(propA.predicate);
            const universalEntityBase = getBaseNoun(propB.entity);
            if (existentialPredicateBase === universalEntityBase) {
              return {
                type: "existential",
                entity: propA.entity,
                predicate: propB.predicate,
              };
            }
          }
          if (propA.type === "universal" && propB.type === "universal") {
            const propAPredicateBase = getBaseNoun(propA.predicate);
            const propBEntityBase = getBaseNoun(propB.entity);
            if (propAPredicateBase === propBEntityBase) {
              return {
                type: "universal",
                entity: propA.entity,
                predicate: propB.predicate,
              };
            }
          }
          return null;
        };
        return check(p1, p2) || check(p2, p1);
      }

      function reductioAdAbsurdum(p1, p2, assumption) {
        if (!p1 || !p2) return null;
        const isContradiction =
          (p1.type === "negation" &&
            arePropositionsEqual(p1.proposition, p2)) ||
          (p2.type === "negation" && arePropositionsEqual(p2.proposition, p1));
        if (isContradiction && assumption) {
          return { type: "negation", proposition: assumption };
        }
        return null;
      }

      function proofByCases(p1, p2, p3) {
        if (!p1 || !p2 || !p3) return null;
        const premises = [p1, p2, p3];
        const disjunction = premises.find((p) => p.type === "disjunction");
        if (!disjunction) return null;
        const conditionals = premises.filter((p) => p.type === "conditional");
        if (conditionals.length !== 2) return null;
        const p = disjunction.left;
        const q = disjunction.right;
        const cond1 = conditionals[0];
        const cond2 = conditionals[1];
        const caseA =
          arePropositionsEqual(cond1.left, p) &&
          arePropositionsEqual(cond2.left, q) &&
          arePropositionsEqual(cond1.right, cond2.right);
        const caseB =
          arePropositionsEqual(cond1.left, q) &&
          arePropositionsEqual(cond2.left, p) &&
          arePropositionsEqual(cond1.right, cond2.right);
        if (caseA || caseB) {
          return cond1.right;
        }
        return null;
      }

      function isContradictory(newProp, allTrueProps) {
        for (const trueProp of allTrueProps) {
          if (
            trueProp.type === "negation" &&
            arePropositionsEqual(newProp, trueProp.proposition)
          )
            return true;
          if (
            newProp.type === "negation" &&
            arePropositionsEqual(newProp.proposition, trueProp)
          )
            return true;
        }
        if (newProp.type === "atomic" || newProp.type === "universal") {
          const predicatePairs = currentLang.contradictoryPredicates;
          let oppositePredicate = null;
          for (const key in predicatePairs) {
            if (key === newProp.predicate) {
              oppositePredicate = predicatePairs[key];
              break;
            }
            if (predicatePairs[key] === newProp.predicate) {
              oppositePredicate = key;
              break;
            }
          }
          if (oppositePredicate) {
            for (const trueProp of allTrueProps) {
              if (trueProp.type === newProp.type) {
                const sameSubject =
                  (newProp.type === "atomic" &&
                    trueProp.subject === newProp.subject) ||
                  (newProp.type === "universal" &&
                    trueProp.entity === newProp.entity);
                if (sameSubject && trueProp.predicate === oppositePredicate) {
                  return true;
                }
              }
            }
          }
        }
        return false;
      }

      function verifyAndExpandTruths(newProposition) {
        const tempTruthSet = JSON.parse(JSON.stringify(internalTruthSet));
        const worklist = [];
        const addSafe = (prop, list) => {
          if (!prop) return true;
          if (isContradictory(prop, list)) return false;
          if (list.some((p) => arePropositionsEqual(p, prop))) return true;
          list.push(prop);
          worklist.push(prop);
          return true;
        };
        if (!addSafe(newProposition, tempTruthSet)) return { success: false };
        while (worklist.length > 0) {
          const currentProp = worklist.shift();
          if (!addSafe(doubleNegationElimination(currentProp), tempTruthSet))
            return { success: false };
          const conjuctElimResults = conjunctionElimination(currentProp);
          if (conjuctElimResults) {
            for (const p of conjuctElimResults) {
              if (!addSafe(p, tempTruthSet)) return { success: false };
            }
          }
          const currentFullSet = [...tempTruthSet];
          for (const existingProp of currentFullSet) {
            if (arePropositionsEqual(currentProp, existingProp)) continue;
            const rules = [
              modusPonens,
              modusTollens,
              hypotheticalSyllogism,
              disjunctiveSyllogism,
              universalApplication,
            ];
            for (const rule of rules) {
              const result = rule(currentProp, existingProp);
              if (!addSafe(result, tempTruthSet)) return { success: false };
            }
          }
        }
        return { success: true, expandedSet: tempTruthSet };
      }

      function isValidPlay(cardToPlay, proposition) {
        if (inTutorialMode) {
          const highlightedCard = document.querySelector(".tutorial-highlight");
          return (
            highlightedCard && highlightedCard.textContent === cardToPlay.text
          );
        }

        const propLength = proposition.length;
        const { if: ifKeyword, and, or, not } = currentLang.keywords;
        const isConnective = (card) => [ifKeyword, and, or].includes(card.text);
        const [properNoun, quantifier, entity, predicate, operator] =
          currentLang.cardTypes;

        if (propLength === 0) {
          return (
            cardToPlay.type === properNoun || cardToPlay.type === quantifier
          );
        }

        const lastCardInfo = proposition[propLength - 1];

        if (cardToPlay.text === not) {
          // 'ëŠ” ê±°ì§“ì´ë‹¤'ê°€ ì ìš©ë  ì ˆ(clause)ì„ ì°¾ìŠµë‹ˆë‹¤.
          const connectiveIndex = proposition
            .map((info) => info.card)
            .findIndex(isConnective);
          const clauseToNegate =
            connectiveIndex > -1
              ? proposition.slice(connectiveIndex + 1)
              : [...proposition];
          const newClauseWithNegation = [
            ...clauseToNegate,
            { card: cardToPlay, player: currentPlayer },
          ];
          return parsePropositionFromCards(newClauseWithNegation) !== null;
        }

        if (isConnective(cardToPlay)) {
          if (proposition.some((info) => isConnective(info.card))) return false;
          const connectiveIndex = proposition
            .map((info) => info.card)
            .findIndex(isConnective);
          const partToCheck =
            connectiveIndex > -1
              ? proposition.slice(connectiveIndex + 1)
              : proposition;
          return parsePropositionFromCards(partToCheck) !== null;
        }

        if (isConnective(lastCardInfo.card)) {
          return (
            cardToPlay.type === properNoun || cardToPlay.type === quantifier
          );
        }

        const connectiveIndex = proposition
          .map((info) => info.card)
          .findIndex(isConnective);
        const currentSimpleProp =
          connectiveIndex > -1
            ? proposition.slice(connectiveIndex + 1)
            : proposition;

        if (currentSimpleProp.length === 1) {
          const lastType = currentSimpleProp[0].card.type;
          if (lastType === properNoun) return cardToPlay.type === predicate;
          if (lastType === quantifier) return cardToPlay.type === entity;
        }
        if (currentSimpleProp.length === 2) {
          if (
            currentSimpleProp[0].card.type === quantifier &&
            currentSimpleProp[1].card.type === entity
          ) {
            return cardToPlay.type === predicate;
          }
        }
        return false;
      }

      function checkNextTurn() {
        if (gameIsOver || isThinkingTime || inTutorialMode) return;

        if (gameMode === "AI" && currentPlayer === aiPlayer) {
          render();
          if (aiTimeoutId) clearTimeout(aiTimeoutId);
          aiTimeoutId = setTimeout(aiTurn, 1500);
        } else {
          checkRoundEndConditions();
        }
      }

      function endTurn() {
        if (cardsPlayedThisTurn[currentPlayer] === 0) return;

        const playerWhoEndedTurn = currentPlayer;
        cardsPlayedThisTurn[playerWhoEndedTurn] = 0;

        currentPlayer = currentPlayer === "A" ? "B" : "A";

        render();
        checkNextTurn();
      }

      /**
       * ìƒëŒ€ë°©ì˜ ì†íŒ¨ë¥¼ ë¶„ì„í•˜ì—¬ ìœ„í˜‘ì ì¸ ì¹´ë“œ ì •ë³´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
       * @param {Array} opponentHand - ìƒëŒ€ë°©ì˜ ì¹´ë“œ ê°ì²´ ë°°ì—´.
       * @param {string} myCorePredicate - AIì˜ ìŠ¹ë¦¬ ì¡°ê±´ê³¼ ì§ê²°ëœ í•µì‹¬ ì„œìˆ ì–´.
       * @param {object} langData - í˜„ì¬ ì–¸ì–´ ì„¤ì • ë°ì´í„° (TEXTS.ko ë˜ëŠ” TEXTS.en).
       * @returns {{hasNegation: boolean, hasContradictoryToMyWinCon: boolean}}
       * - hasNegation: ë¶€ì • ì¹´ë“œ('ëŠ” ê±°ì§“ì´ë‹¤') ì¡´ì¬ ì—¬ë¶€
       * - hasContradictoryToMyWinCon: AIì˜ ìŠ¹ë¦¬ ì¡°ê±´ê³¼ ëª¨ìˆœë˜ëŠ” ì„œìˆ ì–´ ì¡´ì¬ ì—¬ë¶€
       */
      function analyzeOpponentThreats(opponentHand, myCorePredicate, langData) {
        const threats = {
          hasNegation: false,
          hasContradictoryToMyWinCon: false,
        };

        // AIì˜ í•µì‹¬ ì„œìˆ ì–´ì™€ ëª¨ìˆœë˜ëŠ” ì„œìˆ ì–´ ì°¾ê¸°
        let contradictoryPredicate = null;
        const predicatePairs = langData.contradictoryPredicates;
        for (const key in predicatePairs) {
          if (key === myCorePredicate) {
            contradictoryPredicate = predicatePairs[key];
            break;
          }
          if (predicatePairs[key] === myCorePredicate) {
            contradictoryPredicate = key;
            break;
          }
        }

        // ìƒëŒ€ë°© ì†íŒ¨ ìˆœíšŒ
        for (const card of opponentHand) {
          // ë¶€ì • ì¹´ë“œ í™•ì¸
          if (card.text === langData.keywords.not) {
            threats.hasNegation = true;
          }
          // AI ìŠ¹ë¦¬ ì¡°ê±´ê³¼ ëª¨ìˆœë˜ëŠ” ì„œìˆ ì–´ ì¹´ë“œ í™•ì¸
          if (
            card.type === langData.cardTypes[3] /* ì„œìˆ ì–´ or Predicate */ &&
            card.text === contradictoryPredicate
          ) {
            threats.hasContradictoryToMyWinCon = true;
          }
        }

        return threats;
      }

      /**
       * AIì˜ ìŠ¹ë¦¬ ì¡°ê±´ì„ ë‹¬ì„±í•˜ê¸° ìœ„í•œ ëª¨ë“  ì ì¬ì  'ê³„íš'ì„ ìƒì„±í•˜ê³  ì ìˆ˜ë¥¼ ë§¤ê¸°ëŠ” í•¨ìˆ˜
       * @returns {object | null} ê°€ì¥ ì ìˆ˜ê°€ ë†’ì€ ìµœì ì˜ ê³„íš ê°ì²´ ë˜ëŠ” null
       */
      function generateAndScorePlans() {
        const aiHand = aiPlayer === "A" ? playerA_Hand : playerB_Hand;
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === aiPlayer
        );
        if (!myVictoryData) return null;

        const ultimateGoal = myVictoryData.core_goal; // ì˜ˆ: { subject: 'ì†Œí¬ë¼í…ŒìŠ¤', predicate: 'ì§€í˜œë¡­ë‹¤' }
        const goalSubject = ultimateGoal.subject;
        const goalPredicate = ultimateGoal.predicate;

        let potentialPlans = [];

        let middleTermText; // â˜… 1. ifë¬¸ ë°–ì—ì„œ ë³€ìˆ˜ë¥¼ ë¨¼ì € ì„ ì–¸í•©ë‹ˆë‹¤.
        let middleTermAsPredicate;
        let subGoal1CardsNeeded;

        // 'A'ê°€ ë  ìˆ˜ ìˆëŠ” ëª¨ë“  ì¤‘ê°„ ê°œë…(ê°œì²´, ì„œìˆ ì–´)ì„ íƒìƒ‰í•©ë‹ˆë‹¤.
        const allMiddleTermCards = fullDeck.filter(
          (c) =>
            c.type === currentLang.cardTypes[2] || // ê°œì²´ (ìƒˆ, ë¬¼ê³ ê¸°, ê°œ)
            c.type === currentLang.cardTypes[3] // ì„œìˆ ì–´ (ì„ í•˜ë‹¤, ì•…í•˜ë‹¤ ë“±)
        );

        for (const middleTermCard of allMiddleTermCards) {
          // Aê°€ 'ìƒˆì´ë‹¤'ì™€ ê°™ì€ ì„œìˆ ì–´ í˜•íƒœì¼ ê²½ìš°, AëŠ” 'ìƒˆ'ê°€ ë©ë‹ˆë‹¤.
          let middleTermAsPredicate;
          let subGoal1CardsNeeded;

          // â˜…â˜…â˜… í•µì‹¬ ìˆ˜ì •: ì¤‘ê°„ í•­ì˜ íƒ€ì…('ê°œì²´'/'ì„œìˆ ì–´')ì— ë”°ë¼ ë¡œì§ì„ ë¶„ê¸°í•©ë‹ˆë‹¤.
          if (middleTermCard.type === currentLang.cardTypes[2]) {
            // íƒ€ì…ì´ 'ê°œì²´'(ìƒˆ, ë¬¼ê³ ê¸°, ê°œ)ì¸ ê²½ìš°
            middleTermText =
              currentLang.langCode === "ko"
                ? middleTermCard.text.replace(/ëŠ”$/, "")
                : middleTermCard.text;
            middleTermAsPredicate =
              currentLang.langCode === "ko"
                ? `${middleTermText}ì´ë‹¤`
                : `is a ${middleTermText}`;

            subGoal1CardsNeeded = [goalSubject, middleTermAsPredicate];
          } else {
            middleTermText = middleTermCard.text;
            middleTermAsPredicate = middleTermCard.text;
            subGoal1CardsNeeded = [goalSubject, middleTermCard.text];
            // íƒ€ì…ì´ 'ì„œìˆ ì–´'(ì„ í•˜ë‹¤, ì§€í˜œë¡­ë‹¤, ìŠ¹ë¦¬í•œë‹¤)ì¸ ê²½ìš°
            // 'ì´ë‹¤'ë¥¼ ë¶™ì´ì§€ ì•Šê³  ì„œìˆ ì–´ ì¹´ë“œì˜ í…ìŠ¤íŠ¸ë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.
            middleTermAsPredicate = middleTermCard.text;

            subGoal1CardsNeeded = [goalSubject, middleTermCard.text];
          }

          // ê³„íš A: ì‚¼ë‹¨ë…¼ë²• (ë³´í¸ ì ìš©)
          // 1. (ë‚˜ì˜ ì² í•™ì)ëŠ” Aì´ë‹¤.  (ì˜ˆ: ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìƒˆì´ë‹¤)
          // 2. ëª¨ë“  AëŠ” (ëª©í‘œ ì„œìˆ ì–´)ì´ë‹¤. (ì˜ˆ: ëª¨ë“  ìƒˆëŠ” ì§€í˜œë¡­ë‹¤)
          const plan = {
            name: `UA_${middleTermText}`, // Plan Name: e.g., UA_bird
            subGoal1: {
              text: `${goalSubject} ${middleTermAsPredicate}`,
              proposition: parsePropositionFromString(
                `${goalSubject} ${middleTermAsPredicate}`
              ),
              isAchieved: false,
              cardsNeeded: subGoal1CardsNeeded,
            },
            subGoal2: {
              text: `${currentLang.keywords.universal_q} ${middleTermCard.text} ${goalPredicate}`,
              proposition: parsePropositionFromString(
                `${currentLang.keywords.universal_q} ${middleTermCard.text} ${goalPredicate}`
              ),
              isAchieved: false,
              cardsNeeded: [
                currentLang.keywords.universal_q,
                middleTermCard.text,
                goalPredicate,
              ],
            },
            score: 0,
          };

          // ê° í•˜ìœ„ ëª©í‘œê°€ ì´ë¯¸ ë‹¬ì„±ë˜ì—ˆëŠ”ì§€ í™•ì¸ (ì°¸ ëª…ì œ ëª©ë¡ì— ìˆëŠ”ì§€)
          plan.subGoal1.isAchieved = internalTruthSet.some((p) =>
            arePropositionsEqual(p, plan.subGoal1.proposition)
          );
          plan.subGoal2.isAchieved = internalTruthSet.some((p) =>
            arePropositionsEqual(p, plan.subGoal2.proposition)
          );

          // ê³„íš ì ìˆ˜ ê³„ì‚°
          let score = 0;
          if (plan.subGoal1.isAchieved) score += 5000;
          if (plan.subGoal2.isAchieved) score += 5000;

          // ê³„íš ë‹¬ì„±ì— í•„ìš”í•œ ì¹´ë“œë¥¼ ì–¼ë§ˆë‚˜ ê°€ì§€ê³  ìˆëŠ”ì§€ í™•ì¸
          const needed = [
            ...plan.subGoal1.cardsNeeded,
            ...plan.subGoal2.cardsNeeded,
          ];
          const has = aiHand.map((c) => c.text);
          let cardsOwned = 0;
          needed.forEach((cardText) => {
            if (has.includes(cardText)) {
              cardsOwned++;
              score += 1000; // í•„ìš”í•œ ì¹´ë“œë¥¼ ê°€ì§€ê³  ìˆìœ¼ë©´ ì ìˆ˜ ì¶”ê°€
            }
          });

          // ì‹¤í˜„ ê°€ëŠ¥ì„±ì´ ìˆëŠ” ê³„íšë§Œ í›„ë³´ì— ì¶”ê°€ (í•„ìš”í•œ ì¹´ë“œë¥¼ í•˜ë‚˜ë¼ë„ ê°€ì¡Œê±°ë‚˜, ëª©í‘œ í•˜ë‚˜ê°€ ì´ë¯¸ ë‹¬ì„±ëœ ê²½ìš°)
          if (
            cardsOwned > 0 ||
            plan.subGoal1.isAchieved ||
            plan.subGoal2.isAchieved
          ) {
            plan.score = score;
            potentialPlans.push(plan);
          }
        }

        if (potentialPlans.length === 0) return null;

        // ê°€ì¥ ì ìˆ˜ê°€ ë†’ì€ ê³„íšì„ ë°˜í™˜
        potentialPlans.sort((a, b) => b.score - a.score);
        return potentialPlans[0];
      }

      function aiTurn() {
        if (gameIsOver || isThinkingTime) return;

        if (aiTimeoutId) clearTimeout(aiTimeoutId);
        aiTimeoutId = setTimeout(aiTurn, 1500);

        const opponentPlayer = aiPlayer === "A" ? "B" : "A";
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === aiPlayer
        );
        const opponentVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponentPlayer
        );

        // ìê¸° íŒ¨ë°°ë¡œ ì´ì–´ì§€ëŠ” ëª…ì œë¥¼ íƒì§€í•˜ëŠ” ë‚´ë¶€ í—¬í¼ í•¨ìˆ˜
        const selfDefeatingProp = (() => {
          if (!myVictoryData) return null;
          const { predicate } = myVictoryData.core_goal;
          const contradictoryPredicate = Object.keys(
            currentLang.contradictoryPredicates
          ).find(
            (key) =>
              currentLang.contradictoryPredicates[key] === predicate ||
              key === predicate
          );

          if (contradictoryPredicate && contradictoryPredicate !== predicate) {
            const oppositePredicate =
              currentLang.contradictoryPredicates[predicate] ||
              Object.keys(currentLang.contradictoryPredicates).find(
                (key) => currentLang.contradictoryPredicates[key] === predicate
              );
            return {
              type: "atomic",
              subject: myVictoryData.core_goal.subject,
              predicate: oppositePredicate,
            };
          }
          return null;
        })();

        if (aiDeclareEureka()) {
          return;
        }

        // ìš°ì„ ìˆœìœ„ 2: ì¥ê¸°ì ì¸ ìŠ¹ë¦¬ ê³„íšì„ ì„¸ìš°ê³  ì‹¤í–‰
        const bestPlan = generateAndScorePlans();
        if (bestPlan && bestPlan.score > 1000) {
          // ì¼ì • ì ìˆ˜ ì´ìƒì¸ 'ì¢‹ì€ ê³„íš'ì´ ìˆì„ ê²½ìš°
          console.log(
            `AI STRATEGY: Executing plan '${bestPlan.name}' with score ${bestPlan.score}`
          );

          // ì•„ì§ ë‹¬ì„±ë˜ì§€ ì•Šì€ í•˜ìœ„ ëª©í‘œ ì¤‘ í•˜ë‚˜ë¥¼ ì„ íƒ
          let targetSubGoal = null;
          if (!bestPlan.subGoal1.isAchieved) targetSubGoal = bestPlan.subGoal1;
          else if (!bestPlan.subGoal2.isAchieved)
            targetSubGoal = bestPlan.subGoal2;

          if (targetSubGoal) {
            // í•´ë‹¹ ëª©í‘œë¥¼ ë§Œë“¤ê¸° ìœ„í•œ ìµœì ì˜ ì¹´ë“œë¥¼ ì†ì—ì„œ ì°¾ì•„ì„œ ëƒ…ë‹ˆë‹¤.
            const aiHand = aiPlayer === "A" ? playerA_Hand : playerB_Hand;

            // í˜„ì¬ ëª…ì œíŒì— ë†“ì¸ ì¹´ë“œì™€ ì´ì–´ì§€ëŠ” ì¹´ë“œë¥¼ ìš°ì„ ì ìœ¼ë¡œ ì°¾ìŠµë‹ˆë‹¤.
            const possibleMoves = aiHand.filter((card) =>
              isValidPlay(card, currentProposition)
            );

            for (const move of possibleMoves) {
              // ë‚´ì•¼ í•  ì¹´ë“œê°€ ê³„íšì˜ ì¼ë¶€ë¼ë©´ ì¦‰ì‹œ ì‹¤í–‰
              if (targetSubGoal.cardsNeeded.includes(move.text)) {
                console.log(
                  `AI ACTION: Playing card '${move.text}' to advance the plan.`
                );
                playCard(aiPlayer, move);
                setTimeout(endTurn, 500);
                return; // ê³„íšì„ ì‹¤í–‰í–ˆìœ¼ë¯€ë¡œ í„´ ì¢…ë£Œ
              }
            }
          }
        }

        // --- â–²â–²â–²â–²â–² 'ê³„íš ê¸°ë°˜ í–‰ë™' ë¡œì§ ì¢…ë£Œ â–²â–²â–²â–²â–² ---

        // =======================================================================================
        // === ì œì•ˆëœ ìˆ˜ì • - ì‹œì‘: 'ì¶”ë¡  ê¸°ë°˜' ìœ„í˜‘ íƒì§€ ë° ë¬´ë ¥í™” ìš°ì„ ìˆœìœ„ ë¡œì§ ===
        // =======================================================================================

        const isBoardDangerous = () => {
          if (currentProposition.length === 0) return null;
          const parsedProp = parsePropositionFromCards(currentProposition);
          if (!parsedProp || !opponentVictoryData) return null;

          // ìœ„í˜‘ ìœ í˜• 1: ìƒëŒ€ì˜ í•µì‹¬ ìŠ¹ë¦¬ ì¡°ê±´ê³¼ 'ì§ì ‘ ì¼ì¹˜'í•˜ëŠ” ê²½ìš° (ê¸°ì¡´ ë¡œì§)
          if (arePropositionsEqual(parsedProp, opponentVictoryData.core_goal)) {
            console.log("Threat Detected (Type 1: Direct Match)");
            return parsedProp;
          }

          // ìœ„í˜‘ ìœ í˜• 2: ì´ ëª…ì œë¥¼ ì°¸ìœ¼ë¡œ ì¸ì •í•  ê²½ìš°, ìƒëŒ€ì˜ ìŠ¹ë¦¬ê°€ 'ì¶”ë¡  ê°€ëŠ¥'í•´ì§€ëŠ” ê²½ìš°
          // ì´ë¯¸ ì•Œë ¤ì§„ ì‚¬ì‹¤ì´ë©´ ì¤‘ë³µ ê³„ì‚° ë°©ì§€
          const isAlreadyKnown = internalTruthSet.some((p) =>
            arePropositionsEqual(p, parsedProp)
          );
          if (isAlreadyKnown) return null;

          // "ë§Œì•½ ì´ ëª…ì œê°€ ì°¸ì´ ëœë‹¤ë©´?" ì´ë¼ëŠ” ê°€ìƒ ì‹œë‚˜ë¦¬ì˜¤ ìƒì„±
          const simulatedTruths = [...internalTruthSet, parsedProp];

          // ì´ ì‹œë‚˜ë¦¬ì˜¤ì—ì„œ ìƒëŒ€ì˜ ìµœì¢… ìŠ¹ë¦¬ ì¡°ê±´(ultimate_target)ì´ ì¦ëª…ë˜ëŠ”ì§€ í™•ì¸
          if (
            aiFindProof(opponentVictoryData.ultimate_target, simulatedTruths)
          ) {
            console.log("Threat Detected (Type 2: Inferred Defeat)");
            return parsedProp;
          }

          return null;
        };

        const dangerousParsedProp = isBoardDangerous();

        if (dangerousParsedProp) {
          console.log(
            "AI ALERT: Dangerous proposition detected! Activating neutralization priority.",
            propositionToText(dangerousParsedProp)
          );

          const aiHand = aiPlayer === "A" ? playerA_Hand : playerB_Hand;
          const { not, if: ifKeyword, or } = currentLang.keywords;
          const neutralizationOrder = [not, ifKeyword, or];

          for (const cardText of neutralizationOrder) {
            const cardToPlay = aiHand.find((c) => c.text === cardText);
            if (cardToPlay && isValidPlay(cardToPlay, currentProposition)) {
              console.log(
                `AI STRATEGY: Neutralizing with '${cardText}' card (Priority: ${
                  neutralizationOrder.indexOf(cardText) + 1
                }).`
              );
              playCard(aiPlayer, cardToPlay);
              setTimeout(endTurn, 500);
              return; // ìš°ì„ ìˆœìœ„ í–‰ë™ì„ ìˆ˜í–‰í–ˆìœ¼ë¯€ë¡œ AI í„´ ì¦‰ì‹œ ì¢…ë£Œ
            }
          }

          console.log(
            "AI WARNING: Dangerous proposition on board, but no neutralization cards available. Falling back to default scoring."
          );
        }

        // =====================================================================================
        // === ì œì•ˆëœ ìˆ˜ì • - ë ===
        // =====================================================================================

        const isBoardCompletable =
          currentProposition.length > 0 &&
          parsePropositionFromCards(currentProposition) !== null;
        if (isBoardCompletable && lastCardPlayer !== aiPlayer) {
          const parsedProp = parsePropositionFromCards(currentProposition);
          if (parsedProp) {
            const isDuplicate = internalTruthSet.some((p) =>
              arePropositionsEqual(p, parsedProp)
            );
            const isDirectContradiction = isContradictory(
              parsedProp,
              internalTruthSet
            );

            if (isDuplicate) {
              console.log(
                "AI VETO: Refusing to complete a duplicate proposition."
              );
            } else if (isDirectContradiction) {
              console.log(
                "AI VETO: Refusing to complete a proposition that is a direct contradiction."
              );
            } else if (
              opponentVictoryData &&
              arePropositionsEqual(parsedProp, opponentVictoryData.core_goal)
            ) {
              console.log(
                "AI VETO: Refusing to complete opponent's core goal."
              );
            } else if (
              selfDefeatingProp &&
              arePropositionsEqual(parsedProp, selfDefeatingProp)
            ) {
              console.log(
                "AI VETO: Refusing to complete a self-defeating proposition."
              );
            } else {
              const verificationResult = verifyAndExpandTruths(parsedProp);
              // aiTurn í•¨ìˆ˜ ë‚´, if (verificationResult.success) { ... } ë¶€ë¶„ì„ ì•„ë˜ ì½”ë“œë¡œ ëŒ€ì²´

              if (verificationResult.success) {
                const simulatedTruthSet = verificationResult.expandedSet;

                // --- ê²€ì‚¬ ìš°ì„ ìˆœìœ„ 1: ë‚˜ì˜ ìŠ¹ë¦¬ ëª©í‘œë¥¼ ì§ì ‘ì ìœ¼ë¡œ ë°©í•´í•˜ëŠ”ê°€? (ìƒˆë¡œ ì¶”ê°€ëœ í•µì‹¬ ë¡œì§) ---
                const myVictoryData = truePropositions.find(
                  (p) => p.type === "victory" && p.owner === aiPlayer
                );
                let myCoreGoalIsUndermined = false;
                if (myVictoryData) {
                  const myCoreGoal = myVictoryData.core_goal;
                  const contradictoryPredicateText =
                    currentLang.contradictoryPredicates[myCoreGoal.predicate] ||
                    Object.keys(currentLang.contradictoryPredicates).find(
                      (key) =>
                        currentLang.contradictoryPredicates[key] ===
                        myCoreGoal.predicate
                    );
                  if (contradictoryPredicateText) {
                    const antiGoalProposition = {
                      type: "atomic",
                      subject: myCoreGoal.subject,
                      predicate: contradictoryPredicateText,
                    };
                    if (aiFindProof(antiGoalProposition, simulatedTruthSet)) {
                      myCoreGoalIsUndermined = true;
                    }
                  }
                }

                // --- ê²€ì‚¬ ìš°ì„ ìˆœìœ„ 2: ìƒëŒ€ë°©ì˜ ìŠ¹ë¦¬ë¡œ ì´ì–´ì§€ëŠ”ê°€? (ê¸°ì¡´ ë¡œì§) ---
                const opponentCanWin =
                  opponentVictoryData &&
                  aiFindProof(
                    opponentVictoryData.ultimate_target,
                    simulatedTruthSet
                  );

                // --- ìµœì¢… ê²°ì • ---
                if (myCoreGoalIsUndermined) {
                  console.log(
                    "AI VETO: Refusing to complete, it undermines my core victory condition."
                  );
                  // ëª…ì œë¥¼ ì™„ì„±í•˜ì§€ ì•Šê³ , ë‹¤ë¥¸ ì¹´ë“œë¥¼ ë‚´ëŠ” ë¡œì§ìœ¼ë¡œ ë„˜ì–´ê°
                } else if (opponentCanWin) {
                  console.log(
                    "AI VETO: Refusing to complete, it leads to opponent's victory."
                  );
                  // ëª…ì œë¥¼ ì™„ì„±í•˜ì§€ ì•Šê³ , ë‹¤ë¥¸ ì¹´ë“œë¥¼ ë‚´ëŠ” ë¡œì§ìœ¼ë¡œ ë„˜ì–´ê°
                } else {
                  // ëª¨ë“  ì¹˜ëª…ì ì¸ ìœ„í˜‘ì´ ì—†ë‹¤ê³  íŒë‹¨ë  ë•Œë§Œ ëª…ì œë¥¼ ì™„ì„±
                  console.log(
                    "AI Strategy: Completing opponent's proposition as it is safe."
                  );
                  completeProposition();
                  return; // ëª…ì œë¥¼ ì™„ì„±í–ˆìœ¼ë¯€ë¡œ AI í„´ ì¢…ë£Œ
                }
              }
            }
          }
        }

        const aiHand = aiPlayer === "A" ? playerA_Hand : playerB_Hand;
        const validMoves = aiHand.filter((card) =>
          isValidPlay(card, currentProposition)
        );

        if (validMoves.length > 0) {
          // --- 'ì „ëµì  ì ìˆ˜ ê³„ì‚°' ë¡œì§ ì‹œì‘ ---

          // 1. í˜„ì¬ ëª…ì œíŒì´ AIì—ê²Œ ìœ„í˜‘ì ì¸ì§€ ë¨¼ì € íŒë‹¨í•©ë‹ˆë‹¤.
          let isBoardThreatening = false;
          const currentParsedPropOnBoard =
            parsePropositionFromCards(currentProposition);
          if (currentParsedPropOnBoard) {
            if (myVictoryData) {
              const myCoreGoal = myVictoryData.core_goal;
              const contradictoryPredicateText =
                currentLang.contradictoryPredicates[myCoreGoal.predicate] ||
                Object.keys(currentLang.contradictoryPredicates).find(
                  (key) =>
                    currentLang.contradictoryPredicates[key] ===
                    myCoreGoal.predicate
                );
              if (contradictoryPredicateText) {
                const antiGoalProposition = {
                  type: "atomic",
                  subject: myCoreGoal.subject,
                  predicate: contradictoryPredicateText,
                };
                if (
                  aiFindProof(antiGoalProposition, [
                    ...internalTruthSet,
                    currentParsedPropOnBoard,
                  ])
                ) {
                  isBoardThreatening = true;
                }
              }
            }
          }

          const scoredMoves = validMoves.map((move) => {
            let score = 0;
            const { and, or, if: ifKeyword, not } = currentLang.keywords;

            // 2. ìœ„í˜‘ ìƒí™©ì¼ ê²½ìš°, 'ì „ëµì  ëŒ€ì‘' ì ìˆ˜ë¥¼ ë¶€ì—¬í•©ë‹ˆë‹¤.
            if (isBoardThreatening) {
              console.log(
                `AI ALERT: Board is threatening. Applying strategic scores for move '${move.text}'.`
              );
              switch (move.text) {
                case not:
                  // ìµœìš°ì„  ìˆœìœ„: ìœ„í˜‘ì„ ì§ì ‘ì ìœ¼ë¡œ ë¶€ì •
                  score += 20000;
                  break;
                case ifKeyword:
                  // ì°¨ì„ ì±…: ìœ„í˜‘ì„ 'ê°€ì •'ìœ¼ë¡œ ë§Œë“¤ì–´ í•œ ë‹¨ê³„ ì•½í™”ì‹œí‚´ (A ë¼ë©´ B)
                  score += 50000;
                  break;
                case or:
                  // ë‹¤ìŒ ì„ íƒ: 'ë˜ëŠ”'ìœ¼ë¡œ ì—°ê²°í•˜ì—¬ ìœ„í˜‘ì˜ ëª…í™•ì„±ì„ í¬ì„ì‹œí‚´ (A ë˜ëŠ” B)
                  score += 5000;
                  break;
                case and:
                  // ìµœì•…ì˜ ìˆ˜: ìœ„í—˜í•œ ëª…ì œë¥¼ ì‚¬ì‹¤ìƒ ì¸ì •í•˜ëŠ” í–‰ìœ„
                  score -= 100000;
                  break;
                default:
                  // ê¸°íƒ€ í–‰ë™ì€ ìƒí™©ì„ ë°”ê¾¸ì§€ ëª»í•˜ë¯€ë¡œ ê°ì 
                  score -= 1000;
                  break;
              }
            }
            // 3. ìœ„í˜‘ ìƒí™©ì´ ì•„ë‹ ê²½ìš°, 'ì¥ê¸° ê³„íš' ë˜ëŠ” 'ì¼ë°˜' ì ìˆ˜ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
            else {
              // (ì—¬ê¸°ì— ì´ì „ ë‹µë³€ì—ì„œ ì œì•ˆí•œ generateAndScorePlans() ê¸°ë°˜ì˜ ê³„íš ì‹¤í–‰ ì ìˆ˜ ë¡œì§ì´ë‚˜
              //  ê¸°ì¡´ì— ì‚¬ìš©í•˜ì‹œë˜ ê°„ë‹¨í•œ ì¼ë°˜ ì ìˆ˜ ê³„ì‚° ë¡œì§ì„ ë„£ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.)

              // ê°„ë‹¨í•œ ì˜ˆì‹œ:
              if (move.type === currentLang.cardTypes[3]) score += 10; // ì„œìˆ ì–´ì— ê¸°ë³¸ ì ìˆ˜
              if (
                !parsePropositionFromCards([
                  ...currentProposition,
                  { card: move, player: aiPlayer },
                ])
              ) {
                score += 5; // ë¯¸ì™„ì„± ëª…ì œê°€ ë˜ë©´ ì•½ê°„ì˜ ì ìˆ˜
              }
            }

            return { move, score };
          });
          // --- 'ì „ëµì  ì ìˆ˜ ê³„ì‚°' ë¡œì§ ì¢…ë£Œ ---

          scoredMoves.sort((a, b) => b.score - a.score);

          const bestScore = scoredMoves[0].score;
          const topMoves = scoredMoves.filter(
            (m) => m.score >= bestScore * 0.8 && m.score >= 0
          );

          let chosenMove;
          if (topMoves.length > 0) {
            chosenMove = topMoves[Math.floor(Math.random() * topMoves.length)];
          } else {
            chosenMove = scoredMoves[0];
          }

          console.log(
            `AI Strategy: Chose move '${chosenMove.move.text}' with score ${chosenMove.score}`
          );

          playCard(aiPlayer, chosenMove.move);
          setTimeout(endTurn, 500);
        } else {
          // =================================================================
          // â˜…â˜…â˜…â˜…â˜… ë²„ê·¸ ìˆ˜ì • ì§€ì  â˜…â˜…â˜…â˜…â˜…
          // =================================================================
          // AIê°€ ì†ì— ë‚¼ ìˆ˜ ìˆëŠ” ìœ íš¨í•œ ì¹´ë“œê°€ ì—†ì„ ë•Œì˜ ë¡œì§
          console.log("AI has no valid moves in hand.");
          const isBoardCompletableNow =
            currentProposition.length > 0 &&
            parsePropositionFromCards(currentProposition) !== null;

          // ë³´ë“œë¥¼ ì™„ì„±ì‹œí‚¤ëŠ” ê²ƒì´ ìœ ì¼í•˜ê²Œ ê°€ëŠ¥í•œ í–‰ë™ì´ë¼ë©´,
          // ì´ì „ì˜ ëª¨ë“  ì „ëµì  íŒë‹¨(Veto)ê³¼ ê´€ê³„ì—†ì´ ê·œì¹™ì— ë”°ë¼ ì™„ì„±ì„ ì‹œë„í•œë‹¤.
          // ì´ë¥¼ í†µí•´ ê²Œì„ì´ ë©ˆì¶”ëŠ” ë²„ê·¸ë¥¼ í•´ê²°í•œë‹¤.
          if (isBoardCompletableNow && lastCardPlayer !== aiPlayer) {
            console.log(
              "AI Forced Decision: No other options available. Attempting to complete the proposition."
            );
            // completeProposition í•¨ìˆ˜ ìì²´ì— ì¤‘ë³µ ë° ëª¨ìˆœ ê²€ì‚¬ ê¸°ëŠ¥ì´ ë‚´ì¥ë˜ì–´ ìˆìœ¼ë¯€ë¡œ
            // AIëŠ” ê·œì¹™ì— ë”°ë¼ ì¼ë‹¨ ì™„ì„±ì„ ì‹œë„í•˜ê³ , ê·¸ ê²°ê³¼(íŒ¨ë°° í¬í•¨)ë¥¼ ë°›ì•„ë“¤ì¸ë‹¤.
            completeProposition();
          } else {
            // ë³´ë“œë¥¼ ì™„ì„±ì‹œí‚¬ ìˆ˜ë„ ì—†ëŠ”, ì™„ì „íˆ í–‰ë™ì´ ë¶ˆê°€ëŠ¥í•œ ìƒíƒœì¼ ë•Œ
            console.log(
              "AI has no possible moves at all. Checking for round end."
            );
            checkRoundEndConditions();
          }
          // =================================================================
          // â˜…â˜…â˜…â˜…â˜… ë²„ê·¸ ìˆ˜ì • ë â˜…â˜…â˜…â˜…â˜…
          // =================================================================
        }
      }

      function playCard(player, cardToPlay) {
        if (
          gameMode === "AI" &&
          player !== aiPlayer &&
          player !== playerCharacter
        )
          return;
        if (player !== currentPlayer || gameIsOver || isThinkingTime) return;

        if (cardsPlayedThisTurn[player] >= 1) {
          showAlert(currentLang.alerts.oneCardPerTurn);
          return;
        }

        if (!isValidPlay(cardToPlay, currentProposition)) {
          if (player !== aiPlayer) {
            showAlert(currentLang.alerts.invalidCard);
          }
          return;
        }
        if (currentProposition.length === 0) propositionStarter = player;
        const hand = player === "A" ? playerA_Hand : playerB_Hand;
        const cardIndex = hand.findIndex(
          (card) =>
            card.text === cardToPlay.text && card.type === cardToPlay.type
        );
        if (cardIndex === -1) return;
        currentProposition.push({
          card: hand.splice(cardIndex, 1)[0],
          player: player,
        });
        lastCardPlayer = player;
        cardsPlayedThisTurn[player]++;

        render();
      }

      function completeProposition() {
        if (currentProposition.length === 0 || gameIsOver || isThinkingTime)
          return false;

        const parsedProp = parsePropositionFromCards([...currentProposition]);
        if (!parsedProp) {
          if (currentPlayer !== aiPlayer) {
            showAlert(currentLang.alerts.incompleteProposition);
          }
          return false;
        }

        const isAxiom = parsedAxioms.some((a) =>
          arePropositionsEqual(a.proposition, parsedProp)
        );
        const isAlreadyProven = truePropositions.some(
          (p) =>
            p.proposition && arePropositionsEqual(p.proposition, parsedProp)
        );

        if (isAxiom || isAlreadyProven) {
          if (currentPlayer !== aiPlayer) {
            showAlert(currentLang.alerts.duplicateProposition);
          }
          return false;
        }

        const verificationResult = verifyAndExpandTruths(parsedProp);
        if (verificationResult.success) {
          internalTruthSet = verificationResult.expandedSet;
          truePropositions.push({
            type: "user-made",
            round: currentRound,
            proposition: parsedProp,
            original_cards: [...currentProposition],
          });
          lastPropositionMaker =
            currentProposition[currentProposition.length - 1].player;
          currentPlayer = lastPropositionMaker === "A" ? "B" : "A";
          currentProposition = [];
          lastCardPlayer = null;
          cardsPlayedThisTurn = { A: 0, B: 0 };
          render();
          const truePropositionsEl =
            document.getElementById("true-propositions");
          truePropositionsEl.scrollTop = truePropositionsEl.scrollHeight;
          checkNextTurn();
          return true;
        } else {
          if (currentPlayer !== aiPlayer) {
            showAlert(currentLang.alerts.contradictionFound);
          }
          return false;
        }
      }

      function undoProposition() {
        if (gameIsOver || isThinkingTime) return;
        if (gameMode === "AI" && currentPlayer === aiPlayer) return;

        if (currentProposition.length > 0) {
          const lastPlayedInfo = currentProposition.pop();
          if (gameMode === "AI" && lastPlayedInfo.player === aiPlayer) {
            currentProposition.push(lastPlayedInfo);
            return;
          }
          const hand =
            lastPlayedInfo.player === "A" ? playerA_Hand : playerB_Hand;
          hand.push(lastPlayedInfo.card);
          cardsPlayedThisTurn[lastPlayedInfo.player]--;
          currentPlayer = lastPlayedInfo.player;

          if (currentProposition.length > 0) {
            lastCardPlayer =
              currentProposition[currentProposition.length - 1].player;
          } else {
            lastCardPlayer = null;
          }

          render();
        } else {
          let lastUserMadePropIndex = -1;
          for (let i = truePropositions.length - 1; i >= 0; i--) {
            if (truePropositions[i].type === "user-made") {
              lastUserMadePropIndex = i;
              break;
            }
          }
          if (lastUserMadePropIndex !== -1) {
            const propToUndo = truePropositions[lastUserMadePropIndex];
            const lastMaker =
              propToUndo.original_cards[propToUndo.original_cards.length - 1]
                .player;
            if (gameMode === "AI" && lastMaker === aiPlayer) {
              showAlert(currentLang.alerts.nothingToUndo);
              return;
            }
            truePropositions.splice(lastUserMadePropIndex, 1);
            let newTruthSet = parsedAxioms.map((a) => a.proposition);
            const propositionsToReverify = truePropositions
              .filter(
                (p) =>
                  p.type === "victory" ||
                  p.type === "theorem" ||
                  p.type === "user-made"
              )
              .map((p) => p.proposition);
            for (const prop of propositionsToReverify) {
              internalTruthSet = JSON.parse(JSON.stringify(newTruthSet));
              const verificationResult = verifyAndExpandTruths(prop);
              if (verificationResult.success) {
                newTruthSet = verificationResult.expandedSet;
              } else {
                console.error(
                  "Critical error: Inconsistency found while rebuilding truth set after undo.",
                  prop
                );
                showAlert(currentLang.alerts.criticalErrorUndo);
                truePropositions.splice(lastUserMadePropIndex, 0, propToUndo);
                return;
              }
            }
            internalTruthSet = newTruthSet;
            currentProposition = propToUndo.original_cards;
            currentPlayer =
              currentProposition[currentProposition.length - 1].player;
            lastCardPlayer =
              currentProposition[currentProposition.length - 1].player;
            cardsPlayedThisTurn = { A: 0, B: 0 };
            showAlert(currentLang.alerts.undoLastProposition);
            render();
          } else {
            showAlert(currentLang.alerts.nothingToUndo);
          }
        }
      }

      function declareEureka(player) {
        if (gameIsOver) return;
        if (gameMode === "AI" && player === aiPlayer) return;
        if (!isThinkingTime && player !== currentPlayer) return;
        openEurekaModal();
      }

      function aiDeclareEureka() {
        if (isThinkingTime) return false;

        const opponentPlayer = aiPlayer === "A" ? "B" : "A";
        const myVictoryCondition = truePropositions.find(
          (p) => p.type === "victory" && p.owner === aiPlayer
        );
        const opponentVictoryCondition = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponentPlayer
        );

        if (!myVictoryCondition || !opponentVictoryCondition) return false;

        const myGoal = myVictoryCondition.ultimate_target;
        const opponentGoal = {
          type: "negation",
          proposition: opponentVictoryCondition.ultimate_target,
        };

        if (aiFindProof(myGoal)) {
          console.log("AI Eureka! Proved own victory.");
          showAlert(currentLang.alerts.aiEurekaDeclared, () =>
            endGame(aiPlayer)
          );
          return true;
        }

        if (aiFindProof(opponentGoal)) {
          console.log("AI Eureka! Proved opponent's defeat.");
          showAlert(currentLang.alerts.aiEurekaDeclared, () =>
            endGame(aiPlayer)
          );
          return true;
        }

        return false;
      }

      function aiFindProof(
        targetProposition,
        initialTruths = internalTruthSet
      ) {
        let knownTruths = [...initialTruths];
        let newTruthsFoundInIteration = true;
        let iterations = 0;
        const maxIterations = 15; // ë¬´í•œ ë£¨í”„ ë°©ì§€

        while (newTruthsFoundInIteration && iterations < maxIterations) {
          newTruthsFoundInIteration = false;
          iterations++;

          const currentTruthsCount = knownTruths.length;
          let tempTruths = [...knownTruths];

          // ëª©í‘œë¥¼ ì´ë¯¸ ë‹¬ì„±í–ˆëŠ”ì§€ í™•ì¸
          if (
            tempTruths.some((p) => arePropositionsEqual(p, targetProposition))
          ) {
            return true;
          }

          // 1ê°œ ì „ì œ ê·œì¹™ ì ìš©
          for (const p of knownTruths) {
            const rules = [
              conjunctionElimination,
              doubleNegationElimination,
              existentialInstantiation,
            ];
            for (const rule of rules) {
              const result = rule(p);
              if (result) {
                const results = Array.isArray(result) ? result : [result];
                results.forEach((res) => {
                  if (!tempTruths.some((t) => arePropositionsEqual(t, res))) {
                    tempTruths.push(res);
                    newTruthsFoundInIteration = true;
                  }
                });
              }
            }
          }

          // 2ê°œ ì „ì œ ê·œì¹™ ì ìš©
          for (let i = 0; i < knownTruths.length; i++) {
            for (let j = 0; j < knownTruths.length; j++) {
              if (i === j) continue;
              const p1 = knownTruths[i];
              const p2 = knownTruths[j];
              const rules = [
                modusPonens,
                modusTollens,
                hypotheticalSyllogism,
                disjunctiveSyllogism,
                universalApplication,
              ];
              for (const rule of rules) {
                const result = rule(p1, p2);
                if (
                  result &&
                  !tempTruths.some((t) => arePropositionsEqual(t, result))
                ) {
                  tempTruths.push(result);
                  newTruthsFoundInIteration = true;
                }
              }
            }
          }

          // â˜…â˜…â˜… ìˆ˜ì •ëœ ë¶€ë¶„: ê²½ìš° ë…¼ì¦ (Proof by Cases) ìµœì í™” â˜…â˜…â˜…
          // 1. ëª¨ë“  'ë˜ëŠ”' ëª…ì œì™€ 'ë¼ë©´' ëª…ì œë¥¼ ë¯¸ë¦¬ ë¶„ë¥˜í•˜ì—¬ ê²€ìƒ‰ ë²”ìœ„ë¥¼ ì¤„ì…ë‹ˆë‹¤.
          const disjunctions = knownTruths.filter(
            (p) => p.type === "disjunction"
          );
          const conditionals = knownTruths.filter(
            (p) => p.type === "conditional"
          );

          // 2. 'ë˜ëŠ”' ëª…ì œë¥¼ ê¸°ì¤€ìœ¼ë¡œ íƒìƒ‰ì„ ì‹œì‘í•©ë‹ˆë‹¤.
          for (const disjunction of disjunctions) {
            // ì˜ˆ: (P âˆ¨ Q)
            const p = disjunction.left;
            const q = disjunction.right;

            // 3. Pë¡œ ì‹œì‘í•˜ëŠ” 'ë¼ë©´' ëª…ì œë“¤ (P â†’ R)ì„ ì°¾ìŠµë‹ˆë‹¤.
            const pConditionals = conditionals.filter((c) =>
              arePropositionsEqual(c.left, p)
            );
            if (pConditionals.length === 0) continue; // ì—†ìœ¼ë©´ ë‹¤ìŒ 'ë˜ëŠ”' ëª…ì œë¡œ ë„˜ì–´ê°

            // 4. Që¡œ ì‹œì‘í•˜ëŠ” 'ë¼ë©´' ëª…ì œë“¤ (Q â†’ R)ì„ ì°¾ìŠµë‹ˆë‹¤.
            const qConditionals = conditionals.filter((c) =>
              arePropositionsEqual(c.left, q)
            );
            if (qConditionals.length === 0) continue; // ì—†ìœ¼ë©´ ë‹¤ìŒ 'ë˜ëŠ”' ëª…ì œë¡œ ë„˜ì–´ê°

            // 5. ì°¾ì•„ë‚¸ ë‘ 'ë¼ë©´' ëª…ì œ ê·¸ë£¹ì„ ë¹„êµí•˜ì—¬ ê²°ë¡ (R)ì´ ê°™ì€ ìŒì„ ì°¾ìŠµë‹ˆë‹¤.
            for (const pCond of pConditionals) {
              for (const qCond of qConditionals) {
                // ê²°ë¡ (pCond.rightì™€ qCond.right)ì´ ë™ì¼í•œì§€ í™•ì¸
                if (arePropositionsEqual(pCond.right, qCond.right)) {
                  const result = pCond.right; // ìµœì¢… ê²°ë¡  R
                  // ìƒˆë¡œìš´ ê²°ë¡ ì´ë¼ë©´ ì°¸ ëª©ë¡ì— ì¶”ê°€
                  if (
                    result &&
                    !tempTruths.some((t) => arePropositionsEqual(t, result))
                  ) {
                    tempTruths.push(result);
                    newTruthsFoundInIteration = true;
                  }
                }
              }
            }
          }

          knownTruths = tempTruths;
        }

        // ìµœì¢…ì ìœ¼ë¡œ ëª©í‘œê°€ ë‹¬ì„±ë˜ì—ˆëŠ”ì§€ í™•ì¸
        return knownTruths.some((p) =>
          arePropositionsEqual(p, targetProposition)
        );
      }

      function endGame(winner, winningProposition) {
        gameIsOver = true;
        document.getElementById("eureka-modal").classList.remove("visible");
        const statusEl = document.getElementById("status");
        const winnerName =
          winner === "A"
            ? currentLang.ui.playerAName
            : currentLang.ui.playerBName;
        const victoryText = `${winnerName} ${currentLang.ui.victoryMessage}<br>${currentLang.ui.victorySubMessage}`;
        statusEl.innerHTML = `<span class="turn-indicator">${victoryText}</span>`;
        render();

        // 1. ëª¨ë“  ì˜¤ë²„ë ˆì´ ì´ë¯¸ì§€ë¥¼ ì¼ë‹¨ ìˆ¨ê¹ë‹ˆë‹¤.
        document.querySelectorAll(".overlay-image").forEach((img) => {
          img.classList.add("hidden");
        });

        // 2. â˜…â˜…â˜… ìˆ˜ì •ëœ í•µì‹¬ ë¡œì§ â˜…â˜…â˜…
        //    ìŠ¹ë¦¬í•œ ì² í•™ìì˜ 'ìŠ¹ë¦¬' ì˜¤ë²„ë ˆì´ë¥¼ ë…¼ë¦¬ ì¦ëª…ê³¼ ê´€ê³„ì—†ì´ ì¦‰ì‹œ í‘œì‹œí•©ë‹ˆë‹¤.
        const winnerOverlayId =
          winner === "A" ? "socrates-win-overlay" : "plato-win-overlay";
        const winnerOverlay = document.getElementById(winnerOverlayId);
        if (winnerOverlay) {
          winnerOverlay.classList.remove("hidden");
          // z-indexë¥¼ ë‹¤ë¥¸ ìŠ¹ë¦¬ ì´ë¯¸ì§€ë³´ë‹¤ ë†’ê²Œ ì„¤ì •í•˜ì—¬ í•­ìƒ ìœ„ì— ì˜¤ë„ë¡ ë³´ì¥í•©ë‹ˆë‹¤.
          // (CSSì—ì„œ ì´ë¯¸ z-index: 3ìœ¼ë¡œ ì„¤ì •í–ˆìœ¼ë¯€ë¡œ ì´ ì¤„ì€ ì„ íƒì ì…ë‹ˆë‹¤.)
          winnerOverlay.style.zIndex = "5";
        }

        // 3. 'ìŠ¹ë¦¬'ë¥¼ ì œì™¸í•œ ë‚˜ë¨¸ì§€ ìƒíƒœ ì˜¤ë²„ë ˆì´ë“¤ì€ ê¸°ì¡´ì²˜ëŸ¼ ë…¼ë¦¬ì  ì°¸/ê±°ì§“ì— ë”°ë¼ í‘œì‹œí•©ë‹ˆë‹¤.
        const characters = [
          currentLang.keywords.socrates,
          currentLang.keywords.plato,
        ];
        const predicates = [
          ...currentLang.cards
            .filter(
              (card) =>
                card.type === currentLang.cardTypes[3] ||
                card.type === "Predicate"
            )
            // â˜…â˜…â˜… 'ìŠ¹ë¦¬í•œë‹¤' ì„œìˆ ì–´ëŠ” ìœ„ì—ì„œ ìˆ˜ë™ìœ¼ë¡œ ì²˜ë¦¬í–ˆìœ¼ë¯€ë¡œ, ë°˜ë³µë¬¸ì—ì„œ ì œì™¸í•©ë‹ˆë‹¤.
            .filter(
              (card) =>
                card.text !== currentLang.keywords.wins &&
                card.text !== "ìŠ¹ë¦¬í•œë‹¤"
            )
            .map((card) => card.text),
        ];

        characters.forEach((subjectText) => {
          predicates.forEach((predicateText) => {
            const targetProposition = {
              type: "atomic",
              subject: subjectText,
              predicate: predicateText,
            };

            if (aiFindProof(targetProposition, internalTruthSet)) {
              const subjectId =
                subjectText === currentLang.keywords.socrates
                  ? "socrates"
                  : "plato";
              const predicateMap = {
                ì„ í•˜ë‹¤: "good",
                "is good": "good",
                ì•…í•˜ë‹¤: "evil",
                "is evil": "evil",
                ì§€í˜œë¡­ë‹¤: "wise",
                "is wise": "wise",
                ì–´ë¦¬ì„ë‹¤: "foolish",
                "is foolish": "foolish",
                ìƒˆì´ë‹¤: "bird",
                "is a bird": "bird",
                ë¬¼ê³ ê¸°ì´ë‹¤: "fish",
                "is a fish": "fish",
                ê°œì´ë‹¤: "dog",
                "is a dog": "dog",
              };
              const predicateId = predicateMap[predicateText];

              if (predicateId) {
                const overlayId = `${subjectId}-${predicateId}-overlay`;
                const overlayToShow = document.getElementById(overlayId);
                if (overlayToShow) {
                  overlayToShow.classList.remove("hidden");
                }
              }
            }
          });
        });

        const gameOverModal = document.getElementById("game-over-modal");
        gameOverModal.style.display = "flex";
      }
      function checkRoundEndConditions() {
        if (
          gameIsOver ||
          isThinkingTime ||
          cardsPlayedThisTurn[currentPlayer] > 0
        )
          return;

        const hand = currentPlayer === "A" ? playerA_Hand : playerB_Hand;
        const hasValidCardMove = hand.some((card) =>
          isValidPlay(card, currentProposition)
        );

        let canComplete = false;
        if (currentProposition.length > 0 && lastCardPlayer !== currentPlayer) {
          const parsedProp = parsePropositionFromCards(currentProposition);
          if (parsedProp) {
            const verificationResult = verifyAndExpandTruths(parsedProp);
            if (verificationResult.success) {
              canComplete = true;
            }
          }
        }

        if (!hasValidCardMove && !canComplete) {
          const playerName =
            currentPlayer === "A"
              ? currentLang.ui.playerAName
              : currentLang.ui.playerBName;
          showAlert(
            currentLang.alerts.roundEndNoMoves.replace("{player}", playerName)
          );
          startThinkingTime();
        }
      }

      function startThinkingTime() {
        currentProposition = [];
        lastCardPlayer = null;
        isThinkingTime = true;
        cardsPlayedThisTurn = { A: 0, B: 0 };
        document.getElementById("thinking-time-controls").style.display =
          "block";
        render();
      }

      function endThinkingTime() {
        isThinkingTime = false;
        document.getElementById("thinking-time-controls").style.display =
          "none";
        currentRound++;
        const nonPlayerCards = [currentLang.keywords.wins];
        playerA_Hand = JSON.parse(
          JSON.stringify(
            fullDeck.filter((c) => !nonPlayerCards.includes(c.text))
          )
        );
        playerB_Hand = JSON.parse(
          JSON.stringify(
            fullDeck.filter((c) => !nonPlayerCards.includes(c.text))
          )
        );
        currentPlayer = currentRound % 2 === 1 ? "A" : "B";
        render();
        checkNextTurn();
      }

      function openEurekaModal() {
        derivedPropositionsInModal = [];
        currentAssumption = null;
        const modal = document.getElementById("eureka-modal");
        const premiseList = document.getElementById("premise-list");
        premiseList.innerHTML = "";
        const allSelectablePropositions = [
          ...parsedAxioms,
          ...truePropositions
            .map((p) => ({ ...p, proposition: p.proposition }))
            .filter((p) => p.proposition),
        ];
        allSelectablePropositions.forEach((propData) => {
          let label;
          switch (propData.type) {
            case "axiom":
              label = currentLang.labels.axiom;
              break;
            case "victory":
              label = currentLang.labels.victory_condition;
              break;
            case "theorem":
              label = currentLang.labels.theorem;
              break;
            default:
              label = currentLang.labels.proposition;
          }
          addPremiseToWorkbench({
            proposition: propData.proposition,
            type: propData.type,
            dependsOnAssumption: false,
            isAssumption: false,
            label: label,
          });
        });
        const modalTitle = document.getElementById("eureka-title");
        const confirmBtn = document.getElementById("modal-confirm-btn");
        if (isThinkingTime) {
          modalTitle.textContent = currentLang.modals.eurekaTitleTheorem;
          confirmBtn.textContent = currentLang.modals.confirmTheoremButton;
          confirmBtn.onclick = addTheoremsToList;
        } else {
          modalTitle.textContent = currentLang.modals.eurekaTitleVictory;
          confirmBtn.textContent = currentLang.modals.confirmVictoryButton;
          confirmBtn.onclick = proveVictory;
        }
        renderModal();
        modal.classList.add("visible");
      }

      function addAssumption() {
        if (currentAssumption) {
          showAlert(currentLang.alerts.oneAssumptionOnly);
          return;
        }
        showPrompt(
          currentLang.modals.promptInputPlaceholder,
          (propositionText) => {
            if (propositionText) {
              const parsedProp = parsePropositionFromString(propositionText);
              if (parsedProp) {
                currentAssumption = parsedProp;
                addPremiseToWorkbench({
                  proposition: parsedProp,
                  type: "assumption",
                  dependsOnAssumption: true,
                  isAssumption: true,
                  label: currentLang.labels.assumption,
                });
                renderModal();
              } else {
                showAlert(currentLang.alerts.parsingFailed);
              }
            }
          }
        );
      }

      function cancelAssumption() {
        currentAssumption = null;
        derivedPropositionsInModal = derivedPropositionsInModal.filter(
          (p) => !p.dependsOnAssumption
        );
        renderModal();
      }

      function addPremiseToWorkbench(propObject) {
        const isDuplicate = derivedPropositionsInModal.some((p) =>
          arePropositionsEqual(p.proposition, propObject.proposition)
        );
        if (isDuplicate) return;
        derivedPropositionsInModal.push(propObject);
      }

      function applyRule() {
        const selectedLis = Array.from(
          document.querySelectorAll(
            '#premise-list input[type="checkbox"]:checked'
          )
        );
        const rule = document.getElementById("inference-rule-select").value;
        const premisesData = selectedLis.map((chk) =>
          JSON.parse(chk.parentElement.dataset.propObject)
        );
        const premises = premisesData.map((data) => data.proposition);
        let conclusions = [];
        const onePremiseRules = [
          "conjunctionElimination",
          "doubleNegationElimination",
          "conditionalIntroduction",
          "existentialInstantiation",
        ];
        const twoPremiseRules = [
          "modusPonens",
          "modusTollens",
          "hypotheticalSyllogism",
          "disjunctiveSyllogism",
          "universalApplication",
        ];
        const threePremiseRules = ["proofByCases"];
        if (rule === "conditionalIntroduction") {
          if (premises.length !== 1) {
            showAlert(currentLang.alerts.premiseNeededForIntro);
            return;
          }
          if (!currentAssumption) {
            showAlert(currentLang.alerts.assumptionNeededForIntro);
            return;
          }
          const conclusionData = premisesData[0];
          if (!conclusionData.dependsOnAssumption) {
            showAlert(currentLang.alerts.premiseNotFromAssumption);
            return;
          }
          const newConditional = {
            type: "conditional",
            left: currentAssumption,
            right: conclusionData.proposition,
          };
          derivedPropositionsInModal = derivedPropositionsInModal.filter(
            (p) => !p.dependsOnAssumption
          );
          currentAssumption = null;
          addPremiseToWorkbench({
            proposition: newConditional,
            type: "theorem",
            dependsOnAssumption: false,
            isAssumption: false,
            label: currentLang.labels.ci_theorem,
          });
        } else if (rule === "reductioAdAbsurdum") {
          if (premises.length !== 2) {
            showAlert(currentLang.alerts.contradictionNeededForRAA);
            return;
          }
          if (!currentAssumption) {
            showAlert(currentLang.alerts.assumptionNeededForRAA);
            return;
          }
          const result = reductioAdAbsurdum(
            premises[0],
            premises[1],
            currentAssumption
          );
          if (result) {
            derivedPropositionsInModal = derivedPropositionsInModal.filter(
              (p) => !p.dependsOnAssumption
            );
            currentAssumption = null;
            addPremiseToWorkbench({
              proposition: result,
              type: "theorem",
              dependsOnAssumption: false,
              isAssumption: false,
              label: currentLang.labels.raa_theorem,
            });
          } else {
            showAlert(currentLang.alerts.notAContradiction);
          }
        } else if (threePremiseRules.includes(rule)) {
          if (premises.length !== 3) {
            showAlert(
              currentLang.alerts.premiseCountError.replace("{count}", 3)
            );
            return;
          }
          const result = window[rule](premises[0], premises[1], premises[2]);
          if (result) conclusions.push(result);
        } else if (twoPremiseRules.includes(rule)) {
          if (premises.length !== 2) {
            showAlert(
              currentLang.alerts.premiseCountError.replace("{count}", 2)
            );
            return;
          }
          const result = window[rule](premises[0], premises[1]);
          if (result) conclusions.push(result);
        } else if (onePremiseRules.includes(rule)) {
          if (premises.length !== 1) {
            showAlert(
              currentLang.alerts.premiseCountError.replace("{count}", 1)
            );
            return;
          }
          const result = window[rule](premises[0]);
          if (result) {
            if (Array.isArray(result)) conclusions.push(...result);
            else conclusions.push(result);
          }
        }
        if (conclusions.length > 0 && conclusions[0] != null) {
          const isDependent = premisesData.some((p) => p.dependsOnAssumption);
          conclusions.forEach((conc) => {
            addPremiseToWorkbench({
              proposition: conc,
              type: "theorem",
              dependsOnAssumption: isDependent,
              isAssumption: false,
              label: currentLang.labels.theorem,
            });
          });
        } else if (
          rule !== "reductioAdAbsurdum" &&
          rule !== "conditionalIntroduction" &&
          conclusions.length === 0
        ) {
          showAlert(currentLang.alerts.ruleFailed);
        }
        renderModal();
      }

      function addTheoremsToList() {
        const selectedLis = Array.from(
          document.querySelectorAll(
            '#premise-list input[type="checkbox"]:checked'
          )
        );
        if (selectedLis.length === 0) {
          showAlert(currentLang.alerts.noTheoremsToAdd);
          return;
        }

        const selectedPropsData = selectedLis.map((chk) =>
          JSON.parse(chk.parentElement.dataset.propObject)
        );

        let potentialTheorems = selectedPropsData.filter(
          (p) => p.type === "theorem" && !p.dependsOnAssumption
        );

        const trulyNewTheorems = potentialTheorems.filter((theoremData) => {
          const isAxiom = parsedAxioms.some((a) =>
            arePropositionsEqual(a.proposition, theoremData.proposition)
          );
          const isAlreadyProven = truePropositions.some(
            (p) =>
              p.proposition &&
              arePropositionsEqual(p.proposition, theoremData.proposition)
          );
          return !isAxiom && !isAlreadyProven;
        });

        if (trulyNewTheorems.length === 0) {
          showAlert(currentLang.alerts.duplicateProposition);
          return;
        }

        let theoremsAdded = 0;
        for (const theoremData of trulyNewTheorems) {
          const verificationResult = verifyAndExpandTruths(
            theoremData.proposition
          );

          if (verificationResult.success) {
            truePropositions.push({
              type: "theorem",
              round: currentRound,
              proposition: theoremData.proposition,
            });
            internalTruthSet = verificationResult.expandedSet;
            theoremsAdded++;
          } else {
            console.error(
              "Contradiction detected while adding a new theorem.",
              theoremData.proposition
            );
            showAlert(currentLang.alerts.contradictionFound);
            break;
          }
        }

        if (theoremsAdded > 0) {
          document.getElementById("eureka-modal").classList.remove("visible");
          render();
        }
      }

      function proveVictory() {
        if (isThinkingTime) return;

        // í˜„ì¬ í”Œë ˆì´ì–´ì˜ ìŠ¹ë¦¬ ëª©í‘œì™€ ìƒëŒ€ì˜ íŒ¨ë°° ëª©í‘œë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
        const myVictoryCondition = truePropositions.find(
          (p) => p.type === "victory" && p.owner === currentPlayer
        );
        if (!myVictoryCondition) return;
        const myUltimateTarget = myVictoryCondition.ultimate_target;

        const opponentPlayer = currentPlayer === "A" ? "B" : "A";
        const opponentVictoryCondition = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponentPlayer
        );
        if (!opponentVictoryCondition) return;
        const opponentLossCondition = {
          type: "negation",
          proposition: opponentVictoryCondition.ultimate_target,
        };

        // ëª¨ë‹¬ì°½ ì•ˆì—ì„œ ìŠ¹ë¦¬ ë˜ëŠ” ìƒëŒ€ íŒ¨ë°°ê°€ ì¦ëª…ë˜ì—ˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
        const isMyVictoryProven = derivedPropositionsInModal.some(
          (p) =>
            !p.dependsOnAssumption &&
            arePropositionsEqual(p.proposition, myUltimateTarget)
        );
        const isOpponentLossProven = derivedPropositionsInModal.some(
          (p) =>
            !p.dependsOnAssumption &&
            arePropositionsEqual(p.proposition, opponentLossCondition)
        );

        if (isMyVictoryProven || isOpponentLossProven) {
          // â˜…â˜…â˜…â˜…â˜… ë²„ê·¸ ìˆ˜ì • ì‹œì‘ â˜…â˜…â˜…â˜…â˜…
          // ê²Œì„ì„ ì¢…ë£Œí•˜ê¸° ì „ì—, ëª¨ë‹¬ì—ì„œ íŒŒìƒëœ ëª¨ë“  ìƒˆë¡œìš´ ì •ë¦¬(theorem)ë“¤ì„
          // ê²Œì„ì˜ ì „ì²´ ì°¸ ëª©ë¡(internalTruthSet)ì— ë¨¼ì € ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.

          const newTheorems = derivedPropositionsInModal.filter(
            (p) =>
              p.type === "theorem" &&
              !p.dependsOnAssumption &&
              !truePropositions.some((existing) =>
                arePropositionsEqual(p.proposition, existing.proposition)
              )
          );

          for (const theoremData of newTheorems) {
            // ê° ì •ë¦¬ê°€ ê¸°ì¡´ ì§„ë¦¬ ì²´ê³„ì™€ ëª¨ìˆœë˜ì§€ ì•ŠëŠ”ì§€ ìµœì¢… ê²€ì¦í•©ë‹ˆë‹¤.
            const verificationResult = verifyAndExpandTruths(
              theoremData.proposition
            );
            if (verificationResult.success) {
              // â˜…â˜…â˜… í•µì‹¬ ìˆ˜ì • ì‚¬í•­ â˜…â˜…â˜…
              // í™”ë©´ ëª©ë¡(truePropositions)ì—ëŠ” ì¶”ê°€í•˜ì§€ ì•Šê³ ,
              // ë‚´ë¶€ ë…¼ë¦¬ ì§‘í•©(internalTruthSet)ë§Œ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
              // ì´ë ‡ê²Œ í•˜ë©´ ê²Œì„ ì¢…ë£Œ í™”ë©´ì˜ ë…¼ë¦¬ ì—°ì‚°ì—ëŠ” ì˜í–¥ì„ ì£¼ì§€ë§Œ
              // ë©”ì¸ í™”ë©´ ëª©ë¡ì—ëŠ” í‘œì‹œë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
              internalTruthSet = verificationResult.expandedSet;
            } else {
              // ë…¼ë¦¬ì ìœ¼ë¡œ ë°œìƒí•˜ê¸° ì–´ë µì§€ë§Œ, ë§Œì•½ì˜ ê²½ìš°ë¥¼ ëŒ€ë¹„í•œ ì—ëŸ¬ ì²˜ë¦¬
              console.error(
                "ì¹˜ëª…ì  ì˜¤ë¥˜: ìŠ¹ë¦¬ ì¦ëª…ì— ì‚¬ìš©ëœ ì •ë¦¬ê°€ ê¸°ì¡´ ì‚¬ì‹¤ê³¼ ëª¨ìˆœë©ë‹ˆë‹¤.",
                theoremData
              );
              showAlert(currentLang.alerts.criticalErrorUndo);
              return;
            }
          }
          // â˜…â˜…â˜…â˜…â˜… ë²„ê·¸ ìˆ˜ì • ë â˜…â˜…â˜…â˜…â˜…

          // ì´ì œ ëª¨ë“  ì‚¬ì‹¤ì´ ì—…ë°ì´íŠ¸ëœ ìƒíƒœì—ì„œ ê²Œì„ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.
          endGame(currentPlayer);
          return;
        }

        // ìŠ¹ë¦¬ê°€ ì¦ëª…ë˜ì§€ ì•Šì•˜ì„ ê²½ìš°, ì•ˆë‚´ ë©”ì‹œì§€ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
        showAlert(
          currentLang.alerts.proofIncomplete
            .replace("{myGoal}", propositionToText(myUltimateTarget))
            .replace("{opponentGoal}", propositionToText(opponentLossCondition))
        );
      }

      function render() {
        document.getElementById("round-display").textContent =
          currentLang.ui.roundDisplay.replace("{round}", currentRound);
        const handA_El = document.getElementById("player-a-hand"),
          handB_El = document.getElementById("player-b-hand");
        handA_El.innerHTML = "";
        handB_El.innerHTML = "";
        playerA_Hand.sort(
          (a, b) =>
            cardTypeOrder.indexOf(a.type) - cardTypeOrder.indexOf(b.type)
        );
        playerB_Hand.sort(
          (a, b) =>
            cardTypeOrder.indexOf(a.type) - cardTypeOrder.indexOf(b.type)
        );
        let lastTypeA = null;
        playerA_Hand.forEach((card) => {
          if (card.type !== lastTypeA) {
            if (lastTypeA !== null) {
              const br = document.createElement("div");
              br.style.flexBasis = "100%";
              br.style.height = "0";
              handA_El.appendChild(br);
            }
            lastTypeA = card.type;
          }
          const cardEl = document.createElement("div");
          cardEl.className = "card card-white";
          cardEl.textContent = card.text;
          if (gameMode === "AI" && aiPlayer === "A") {
            cardEl.classList.add("ai-hand");
          } else {
            cardEl.addEventListener("click", () => {
              if (!inTutorialMode) playCard("A", card);
            });
          }
          handA_El.appendChild(cardEl);
        });
        let lastTypeB = null;
        playerB_Hand.forEach((card) => {
          if (card.type !== lastTypeB) {
            if (lastTypeB !== null) {
              const br = document.createElement("div");
              br.style.flexBasis = "100%";
              br.style.height = "0";
              handB_El.appendChild(br);
            }
            lastTypeB = card.type;
          }
          const cardEl = document.createElement("div");
          cardEl.className = "card card-black";
          cardEl.textContent = card.text;
          if (gameMode === "AI" && aiPlayer === "B") {
            cardEl.classList.add("ai-hand");
          } else {
            cardEl.addEventListener("click", () => {
              if (!inTutorialMode) playCard("B", card);
            });
          }
          handB_El.appendChild(cardEl);
        });
        const propositionEl = document.getElementById("proposition-display");
        propositionEl.innerHTML = "";
        currentProposition.forEach((info) => {
          const cardEl = document.createElement("div");
          const colorClass = info.player === "A" ? "card-white" : "card-black";
          cardEl.className = `card ${colorClass}`;
          cardEl.textContent = info.card.text;
          propositionEl.appendChild(cardEl);
        });
        const trueList_El = document.getElementById("true-list");
        trueList_El.innerHTML = "";
        const liAxiom = document.createElement("li");
        liAxiom.className = "axiom-wrapper";
        const details = document.createElement("details");
        const summary = document.createElement("summary");
        summary.textContent = currentLang.ui.axiomTitle;
        details.appendChild(summary);
        const axiomContainer = document.createElement("div");
        axiomContainer.className = "axiom-list";

        currentAxioms.forEach((axiomText) => {
          const p = document.createElement("p");
          p.textContent = `â€¢ ${axiomText}`;
          axiomContainer.appendChild(p);
        });

        details.appendChild(axiomContainer);
        liAxiom.appendChild(details);
        trueList_El.appendChild(liAxiom);

        truePropositions.forEach((propData) => {
          const li = document.createElement("li");

          if (propData.type === "victory") {
            li.classList.add("victory-condition");
            const ownerName =
              propData.owner === "A"
                ? playerA_Data.name[currentLang.langCode]
                : playerB_Data.name[currentLang.langCode];
            const ownerPrefix =
              propData.owner === "A" ? `âšªï¸ ${ownerName}` : `âš«ï¸ ${ownerName}`;
            li.innerHTML = currentLang.labels.victory_text
              .replace("{owner}", ownerPrefix)
              .replace("{text}", propData.text);
          } else if (propData.type === "user-made") {
            if (propData.original_cards && propData.original_cards.length > 0) {
              propData.original_cards.forEach((info) => {
                const wordSpan = document.createElement("span");
                wordSpan.textContent = info.card.text + " ";
                wordSpan.className = info.player === "A" ? "word-a" : "word-b";
                li.appendChild(wordSpan);
              });
            } else if (propData.proposition) {
              li.textContent = propositionToNaturalText(propData.proposition);
            }
          } else if (propData.type === "theorem") {
            li.classList.add("theorem");
            li.textContent = currentLang.labels.theorem_source
              .replace("{text}", propositionToNaturalText(propData.proposition))
              .replace("{round}", propData.round);
          }
          trueList_El.appendChild(li);
        });

        const statusEl = document.getElementById("status");
        const mainCenter = document.querySelector(".main-center-bg");

        if (mainCenter && !mainCenter.classList.contains("hidden")) {
          statusEl.innerHTML = "";
        } else {
          const playerAreaA = document.getElementById("player-a-area"),
            playerAreaB = document.getElementById("player-b-area");
          const eurekaBtnA = document.getElementById("eureka-a"),
            eurekaBtnB = document.getElementById("eureka-b");
          const completeBtn = document.getElementById("complete-btn"),
            undoBtn = document.getElementById("undo-btn"),
            endTurnBtn = document.getElementById("end-turn-btn");

          let winnerName = "";
          if (gameIsOver) {
            winnerName =
              currentPlayer === "A" && playerA_Data
                ? playerA_Data.name[currentLang.langCode]
                : playerB_Data
                ? playerB_Data.name[currentLang.langCode]
                : "";
          }

          if (gameIsOver) {
            statusEl.innerHTML = `<span class="turn-indicator">${winnerName} ${currentLang.ui.victoryMessage}<br>${currentLang.ui.victorySubMessage}</span>`;
            statusEl.style.color = "#c0392b";
            playerAreaA.classList.add("disabled");
            playerAreaB.classList.add("disabled");
            eurekaBtnA.disabled = true;
            eurekaBtnB.disabled = true;
            completeBtn.disabled = true;
            undoBtn.disabled = true;
            endTurnBtn.disabled = true;
          } else if (isThinkingTime) {
            statusEl.innerHTML = `<span class="turn-indicator">${currentLang.ui.thinkingTimeStatus}</span>`;
            playerAreaA.classList.remove("disabled");
            playerAreaB.classList.remove("disabled");
            eurekaBtnA.disabled = gameMode === "AI" && aiPlayer === "A";
            eurekaBtnB.disabled = gameMode === "AI" && aiPlayer === "B";
            eurekaBtnA.textContent = currentLang.ui.addTheoremButton;
            eurekaBtnB.textContent = currentLang.ui.addTheoremButton;
            completeBtn.disabled = true;
            undoBtn.disabled = true;
            endTurnBtn.disabled = true;
          } else {
            statusEl.style.color = "#333";
            eurekaBtnA.textContent = currentLang.ui.eurekaButton;
            eurekaBtnB.textContent = currentLang.ui.eurekaButton;
            const isAITurn = gameMode === "AI" && currentPlayer === aiPlayer;
            const isCompletable =
              currentProposition.length > 0 &&
              parsePropositionFromCards(currentProposition) !== null;

            if (isAITurn) {
              statusEl.innerHTML = `<span class="turn-indicator">${currentLang.ui.statusAITurn}</span>`;
              playerAreaA.classList.add("disabled");
              playerAreaB.classList.add("disabled");
              eurekaBtnA.disabled = true;
              eurekaBtnB.disabled = true;
              completeBtn.disabled = true;
              undoBtn.disabled = true;
              endTurnBtn.disabled = true;
            } else {
              if (currentPlayer === "A") {
                const playerAName = playerA_Data
                  ? playerA_Data.name[currentLang.langCode]
                  : currentLang.ui.playerAName;
                statusEl.innerHTML = `<span class="turn-indicator">âšªï¸ ${playerAName} ${currentLang.ui.statusTurn}</span>`;
                playerAreaA.classList.remove("disabled");
                playerAreaB.classList.add("disabled");
                eurekaBtnA.disabled = false;
                eurekaBtnB.disabled = true;
              } else {
                const playerBName = playerB_Data
                  ? playerB_Data.name[currentLang.langCode]
                  : currentLang.ui.playerBName;
                statusEl.innerHTML = `<span class="turn-indicator">âš«ï¸ ${playerBName} ${currentLang.ui.statusTurn}</span>`;
                playerAreaB.classList.remove("disabled");
                playerAreaA.classList.add("disabled");
                eurekaBtnA.disabled = true;
                eurekaBtnB.disabled = false;
              }
              completeBtn.disabled =
                !isCompletable || lastCardPlayer === currentPlayer;
              undoBtn.disabled = cardsPlayedThisTurn[currentPlayer] === 0;
              endTurnBtn.disabled = cardsPlayedThisTurn[currentPlayer] === 0;
            }
          }
        }
      }

      function setupTutorialScenario(step) {
        if (step === 1) {
          playerA_Hand = [];
          playerB_Hand = [];
          truePropositions = [];

          const socratesSubject = currentLang.keywords.socrates;
          const platoSubject = currentLang.keywords.plato;
          currentAxioms = generateAxioms(
            socratesSubject,
            platoSubject,
            currentLang
          );

          parsedAxioms = currentAxioms
            .map((str) => ({
              type: "axiom",
              proposition: parsePropositionFromString(str),
            }))
            .filter((a) => a.proposition);

          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentProposition = [];
          currentPlayer = "A";
          propositionStarter = "A";
          gameIsOver = false;
          currentRound = 1;
          isThinkingTime = false;
          lastPropositionMaker = null;
          currentAssumption = null;
          lastCardPlayer = null;
          cardsPlayedThisTurn = { A: 0, B: 0 };
          gameMode = "2P";

          // íŠœí† ë¦¬ì–¼ì„ ìœ„í•œ ê¸°ë³¸ ì² í•™ì ë°ì´í„° ì„¤ì •
          playerA_Data = PHILOSOPHERS["socrates"];
          playerB_Data = PHILOSOPHERS["plato"];

          const socratesCardText = currentLang.keywords.socrates;
          const requiredA_CardTexts = [
            socratesCardText,
            currentLang.keywords.and,
            currentLang.keywords.or,
            currentLang.keywords.if,
            currentLang.keywords.not,
            currentLang.langCode === "ko" ? "ê°œëŠ”" : "dog",
            currentLang.langCode === "ko" ? "ìƒˆëŠ”" : "bird",
            currentLang.langCode === "ko" ? "ë¬¼ê³ ê¸°ëŠ”" : "fish",
            currentLang.keywords.universal_q,
            currentLang.keywords.existential_q,
          ];
          playerA_Hand = fullDeck.filter((c) =>
            requiredA_CardTexts.includes(c.text)
          );

          const wiseCardText =
            currentLang.langCode === "ko" ? "ì§€í˜œë¡­ë‹¤" : "is wise";
          const requiredB_CardTexts = [
            wiseCardText,
            currentLang.keywords.plato,
          ];
          playerB_Hand = fullDeck.filter((c) =>
            requiredB_CardTexts.includes(c.text)
          );
          playerB_Hand.push(
            ...fullDeck
              .filter(
                (c) =>
                  !requiredB_CardTexts.includes(c.text) &&
                  c.type ===
                    (currentLang.langCode === "ko" ? "ì„œìˆ ì–´" : "Predicate")
              )
              .slice(0, 2)
          );
        } else if (step === 2) {
          const socratesCardInfo = currentProposition.find(
            (info) => info.card.text === currentLang.keywords.socrates
          );
          const wiseCardText =
            currentLang.langCode === "ko" ? "ì§€í˜œë¡­ë‹¤" : "is wise";
          const wiseCardIndex = playerB_Hand.findIndex(
            (c) => c.text === wiseCardText
          );

          if (socratesCardInfo && wiseCardIndex > -1) {
            const [wiseCard] = playerB_Hand.splice(wiseCardIndex, 1);
            currentProposition = [
              socratesCardInfo,
              { card: wiseCard, player: "B" },
            ];
            lastCardPlayer = "B";
            currentPlayer = "A";
          }
        } else if (step === 4) {
          currentProposition = [];
          playerA_Hand = fullDeck.filter(
            (c) =>
              c.type ===
                (currentLang.langCode === "ko" ? "ì—°ì‚°ì" : "Operator") &&
              c.text !== currentLang.keywords.not
          );
          playerB_Hand = fullDeck.filter(
            (c) =>
              c.type ===
                (currentLang.langCode === "ko" ? "ì„œìˆ ì–´" : "Predicate") &&
              c.text !== (currentLang.langCode === "ko" ? "ê°œì´ë‹¤" : "is a dog")
          );

          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);

          const premises = [
            currentLang.langCode === "ko"
              ? "ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ê°œì´ë‹¤"
              : "Socrates is a dog",
            currentLang.langCode === "ko"
              ? "ëª¨ë“  ê°œëŠ” ì§€í˜œë¡­ë‹¤"
              : "Every dog is wise",
          ];
          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (parsed) {
              truePropositions.push({
                type: "user-made",
                text: pText,
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
          startThinkingTime();
        } else if (step === 5) {
          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentPlayer = "A";
          isThinkingTime = false;
          document.getElementById("thinking-time-controls").style.display =
            "none";

          const premises = [
            currentLang.langCode === "ko"
              ? "ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤"
              : "Socrates is good",
            currentLang.langCode === "ko"
              ? "(ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤) ë¼ë©´ (ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤)"
              : "(Socrates is good) then (Socrates wins)",
            currentLang.langCode === "ko"
              ? "í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤"
              : "Plato is wise is false",
            currentLang.langCode === "ko"
              ? "(í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤)"
              : "(Plato wins) then (Plato is wise)",
            currentLang.langCode === "ko"
              ? "(ì–´ë–¤ ìƒˆëŠ” ë¬¼ê³ ê¸°ì´ë‹¤) ë˜ëŠ” (ì–´ë–¤ ìƒˆëŠ” ìƒˆì´ë‹¤)"
              : "(Some bird is a fish) or (Some bird is a bird)",
            currentLang.langCode === "ko"
              ? "ì–´ë–¤ ìƒˆëŠ” ë¬¼ê³ ê¸°ì´ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤"
              : "Some bird is a fish is false",
            currentLang.langCode === "ko"
              ? "(í”Œë¼í†¤ì€ ê°œì´ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì„ í•˜ë‹¤)"
              : "(Plato is a dog) then (Plato is good)",
            currentLang.langCode === "ko"
              ? "(í”Œë¼í†¤ì€ ì„ í•˜ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤)"
              : "(Plato is good) then (Plato wins)",
            currentLang.langCode === "ko"
              ? "(ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì§€í˜œë¡­ë‹¤) ê·¸ë¦¬ê³  (í”Œë¼í†¤ì€ ì–´ë¦¬ì„ë‹¤)"
              : "(Socrates is wise) and (Plato is foolish)",
            currentLang.langCode === "ko"
              ? "ì–´ë–¤ ë¬¼ê³ ê¸°ëŠ” ì„ í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤"
              : "Some fish is good is false is false",
            currentLang.langCode === "ko"
              ? "ëª¨ë“  ìƒˆëŠ” ì„ í•˜ë‹¤"
              : "Every bird is good",
            currentLang.langCode === "ko"
              ? "í”Œë¼í†¤ì€ ìƒˆì´ë‹¤"
              : "Plato is a bird",
            currentLang.langCode === "ko"
              ? "ëª¨ë“  ê°œëŠ” ì„ í•˜ë‹¤"
              : "Every dog is good",
          ];

          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (
              parsed &&
              !internalTruthSet.some((p) => arePropositionsEqual(p, parsed))
            ) {
              truePropositions.push({
                type: "user-made",
                text: pText,
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
        } else if (step === 6) {
          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentPlayer = "A";
          isThinkingTime = false;
          document.getElementById("thinking-time-controls").style.display =
            "none";

          const premises =
            currentLang.langCode === "ko"
              ? [
                  "í”Œë¼í†¤ì€ ì„ í•˜ë‹¤ ë˜ëŠ” í”Œë¼í†¤ì€ ì•…í•˜ë‹¤",
                  "(í”Œë¼í†¤ì€ ì„ í•˜ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤)",
                  "(í”Œë¼í†¤ì€ ì•…í•˜ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤)",
                ]
              : [
                  "Plato is good or Plato is evil",
                  "(Plato is good) then (Plato is wise)",
                  "(Plato is evil) then (Plato is wise)",
                ];

          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (
              parsed &&
              !internalTruthSet.some((p) => arePropositionsEqual(p, parsed))
            ) {
              truePropositions.push({
                type: "user-made",
                text: pText,
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
          openEurekaModalTutorial();
        } else if (step === 7) {
          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentPlayer = "A";
          isThinkingTime = false;
          document.getElementById("thinking-time-controls").style.display =
            "none";
          const premises =
            currentLang.langCode === "ko"
              ? [
                  "(ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì§€í˜œë¡­ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ê°œì´ë‹¤)",
                  "(í”Œë¼í†¤ì€ ê°œì´ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì„ í•˜ë‹¤)",
                ]
              : [
                  "(Socrates is wise) then (Plato is a dog)",
                  "(Plato is a dog) then (Plato is good)",
                ];

          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (parsed) {
              truePropositions.push({
                type: "user-made",
                text: propositionToNaturalText(parsed),
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
          openEurekaModalTutorial();
        } else if (step === 8) {
          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentPlayer = "A";
          isThinkingTime = false;
          document.getElementById("thinking-time-controls").style.display =
            "none";
          const premises =
            currentLang.langCode === "ko"
              ? [
                  "(ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤)",
                  "í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
                ]
              : [
                  "(Socrates is evil is false) then (Plato is wise)",
                  "Plato is wise is false",
                ];

          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (
              parsed &&
              !internalTruthSet.some((p) => arePropositionsEqual(p, parsed))
            ) {
              truePropositions.push({
                type: "user-made",
                text: pText,
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
          openEurekaModalTutorial();
        }
        render();
      }

      function renderModal() {
        const premiseList = document.getElementById("premise-list");
        premiseList.innerHTML = "";

        const hasAssumption = !!currentAssumption;
        document.getElementById("add-assumption-btn").disabled = hasAssumption;
        document.getElementById("cancel-assumption-btn").style.display =
          hasAssumption ? "inline-block" : "none";

        derivedPropositionsInModal.forEach((propData) => {
          const li = document.createElement("li");
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          li.dataset.propObject = JSON.stringify(propData);

          if (propData.isAssumption) li.classList.add("assumption-itself");
          else if (propData.dependsOnAssumption)
            li.classList.add("assumption-dependent");

          li.appendChild(checkbox);
          li.append(
            ` ${propData.label} ${propositionToText(propData.proposition)}`
          );

          premiseList.appendChild(li);
        });
      }

      // --- ìœ ë ˆì¹´ ëª¨ë‹¬ ë¦¬ìŠ¤íŠ¸ í´ë¦­ í¸ì˜ì„± ê°œì„  ì½”ë“œ ---
      const eurekaPremiseList = document.getElementById("premise-list");

      if (eurekaPremiseList) {
        eurekaPremiseList.addEventListener("click", function (event) {
          // í´ë¦­ëœ ì§€ì ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ <li> ìš”ì†Œë¥¼ ì°¾ìŠµë‹ˆë‹¤.
          const targetLi = event.target.closest("li");

          // <li> ìš”ì†Œ ì•ˆì—ì„œ í´ë¦­ì´ ë°œìƒí–ˆë‹¤ë©´,
          if (targetLi) {
            // ê·¸ <li> ì•ˆì— ìˆëŠ” ì²´í¬ë°•ìŠ¤ë¥¼ ì°¾ìŠµë‹ˆë‹¤.
            const checkbox = targetLi.querySelector('input[type="checkbox"]');

            // ì²´í¬ë°•ìŠ¤ê°€ ì¡´ì¬í•œë‹¤ë©´,
            if (checkbox) {
              // ì¤‘ìš”: ì‹¤ì œ í´ë¦­ëœ ìš”ì†Œ(event.target)ê°€ ì²´í¬ë°•ìŠ¤ ìì²´ê°€ ì•„ë‹ ë•Œë§Œ ì½”ë“œë¡œ ìƒíƒœë¥¼ ë³€ê²½í•©ë‹ˆë‹¤.
              // ì´ë ‡ê²Œ í•´ì•¼ ì²´í¬ë°•ìŠ¤ë¥¼ ì§ì ‘ í´ë¦­í–ˆì„ ë•Œ ìƒíƒœê°€ ë‘ ë²ˆ ë°”ë€ŒëŠ” í˜„ìƒì„ ë§‰ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
              if (event.target !== checkbox) {
                checkbox.checked = !checkbox.checked;
              }
            }
          }
        });
        // --- ì „ì²´ í™”ë©´ ê¸°ëŠ¥ ë¡œì§ ---
        const fullscreenBtn = document.getElementById("fullscreen-btn");

        fullscreenBtn.addEventListener("click", toggleFullScreen);

        function toggleFullScreen() {
          if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch((err) => {
              alert(TEXTS.fullscreen_error + `: ${err.message} (${err.name})`);
            });
          } else {
            if (document.exitFullscreen) {
              document.exitFullscreen();
            }
          }
        }

        // --- UI í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ (ë‹¤êµ­ì–´ ì§€ì›) ---
        function updateUIText() {
          document.querySelectorAll("[data-i18n]").forEach((element) => {
            const key = element.getAttribute("data-i18n");
            if (TEXTS.hasOwnProperty(key)) {
              element.textContent =
                TEXTS[`${key}_${currentLanguage}`] || TEXTS[`${key}_ko`]; // í˜„ì¬ ì–¸ì–´ ì—†ìœ¼ë©´ í•œêµ­ì–´ ê¸°ë³¸
            }
          });
        }

        // ì´ˆê¸° ë¡œë“œ ì‹œ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
        updateUIText();

        // ì–¸ì–´ ë³€ê²½ ì‹œ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ í˜¸ì¶œ (ê¸°ì¡´ ì–¸ì–´ ë³€ê²½ ë¡œì§ì— ì¶”ê°€ í•„ìš”)
        // ì˜ˆì‹œ:
        // function changeLanguage(lang) {
        //     currentLanguage = lang;
        //     localStorage.setItem('languagePreference', lang);
        //     updateUIText(); // í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
        //     // ... ê¸°ì¡´ ì–¸ì–´ ë³€ê²½ ë¡œì§ ...
        // }
      }
      function adjustBottomBackground() {
        const statusBar = document.getElementById("status");
        const bottomBox = document.getElementById("bottom-background-box");

        if (statusBar && bottomBox) {
          // getBoundingClientRect()ë¥¼ ì‚¬ìš©í•´ status-barì˜ ì‹¤ì œ ìœ„ì¹˜ì™€ í¬ê¸° ì •ë³´ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
          const statusBarRect = statusBar.getBoundingClientRect();

          // status-barì˜ ì„¸ë¡œ ì¤‘ì•™ ìœ„ì¹˜ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
          const statusBarMidY = statusBarRect.top + statusBarRect.height / 2;

          // í™”ë©´ ì „ì²´ ë†’ì´ì—ì„œ status-bar ì¤‘ì•™ ìœ„ì¹˜ë¥¼ ëº€ ë§Œí¼ì„ bottom-boxì˜ ë†’ì´ë¡œ ì§€ì •í•©ë‹ˆë‹¤.
          const newHeight = window.innerHeight - statusBarMidY;

          // ê³„ì‚°ëœ ë†’ì´ê°€ 0ë³´ë‹¤ í´ ë•Œë§Œ ì ìš©í•˜ì—¬ ì˜¤ë¥˜ë¥¼ ë°©ì§€í•©ë‹ˆë‹¤.
          if (newHeight > 0) {
            bottomBox.style.height = `${newHeight}px`;
          }
        }
      }
      // ì°½ í¬ê¸°ê°€ ì¡°ì ˆë  ë•Œë§ˆë‹¤ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.
      window.addEventListener("resize", adjustBottomBackground);
      // ì „ì²´í™”ë©´ ìƒíƒœê°€ ë³€ê²½ë  ë•Œë§ˆë‹¤ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.
      document.addEventListener("fullscreenchange", adjustBottomBackground);

      // í˜ì´ì§€ê°€ ì²˜ìŒ ë¡œë“œë  ë•Œ í•œ ë²ˆ ì‹¤í–‰í•˜ì—¬ ì´ˆê¸° ë†’ì´ë¥¼ ë§ì¶¥ë‹ˆë‹¤.
      adjustBottomBackground();
      function closeGameOverModal() {
        const gameOverModal = document.getElementById("game-over-modal");
        gameOverModal.style.display = "none"; // ëª¨ë‹¬ì„ ìˆ¨ê¹€
      }
      document.getElementById("vs-player-btn").addEventListener("click", () => {
        if (inTutorialMode) return;
        document.querySelector(".main-center-bg").classList.add("hidden"); // ë©”ì¸ ì„¼í„° ìˆ¨ê¹€
        gameMode = "2P";
        aiPlayer = null;
        resetGame();
      });
      document.getElementById("vs-ai-btn").addEventListener("click", () => {
        if (inTutorialMode || gameMode === "AI") return;
        document.querySelector(".main-center-bg").classList.add("hidden"); // ë©”ì¸ ì„¼í„° ìˆ¨ê¹€
        document
          .getElementById("character-select-modal")
          .classList.add("visible");
      });
      document.getElementById("main-menu-btn").addEventListener("click", () => {
        // AI íƒ€ì´ë¨¸ ì •ë¦¬ ë° ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
        clearAllAITimeouts();
        aiPlayer = null; // AI í”Œë ˆì´ì–´ ì´ˆê¸°í™”
        gameMode = "2P"; // ê²Œì„ ëª¨ë“œ ì´ˆê¸°í™”
        gameIsOver = true; // ê²Œì„ ì¢…ë£Œ ìƒíƒœë¡œ ì„¤ì •

        // UI ì—…ë°ì´íŠ¸
        document.querySelector(".main-center-bg").classList.remove("hidden");
        updateMainMenuBtnVisibility();
        updateMainCenterVisibility();

        resetGame();
      });

      function updateMainMenuBtnVisibility() {
        const mainCenter = document.querySelector(".main-center-bg");
        const mainMenuBtn = document.getElementById("main-menu-btn");
        if (mainCenter && mainMenuBtn) {
          if (!mainCenter.classList.contains("hidden")) {
            mainMenuBtn.style.display = "none";
          } else {
            mainMenuBtn.style.display = "";
          }
        }
      }

      // ë©”ì¸ ì„¼í„° show/hide ì‹œë§ˆë‹¤ í˜¸ì¶œ
      document.getElementById("main-menu-btn").addEventListener("click", () => {
        document.querySelector(".main-center-bg").classList.remove("hidden");
        updateMainMenuBtnVisibility();
      });
      document.getElementById("vs-player-btn").addEventListener("click", () => {
        if (inTutorialMode) return;
        document.querySelector(".main-center-bg").classList.add("hidden");
        updateMainMenuBtnVisibility();
        gameMode = "2P";
        aiPlayer = null;
        resetGame();
      });
      document.getElementById("vs-ai-btn").addEventListener("click", () => {
        if (inTutorialMode || gameMode === "AI") return;
        document.querySelector(".main-center-bg").classList.add("hidden");
        updateMainMenuBtnVisibility();
        document
          .getElementById("character-select-modal")
          .classList.add("visible");
      });

      function updateMainCenterVisibility() {
        const mainCenter = document.querySelector(".main-center-bg");
        const hideList = [
          "#player-a-area .player-title-box",
          "#player-a-area .hand",
          "#player-a-area .eureka-btn",
          "#player-b-area .player-title-box",
          "#player-b-area .hand",
          "#player-b-area .eureka-btn",
          "#status > *", // status-barì˜ ìì‹(ë‚´ìš©ë¬¼)ë§Œ
          "#round-display",
          "#new-game-btn",
        ];
        const shouldHide = !mainCenter.classList.contains("hidden");
        hideList.forEach((sel) => {
          const el = document.querySelector(sel);
          if (el) el.style.display = shouldHide ? "none" : "";
        });
      }
      // ë©”ì¸ ì„¼í„° show/hide ì‹œë§ˆë‹¤ í˜¸ì¶œ
      document.getElementById("main-menu-btn").addEventListener("click", () => {
        document.querySelector(".main-center-bg").classList.remove("hidden");
        updateMainMenuBtnVisibility();
        updateMainCenterVisibility();
        if (inTutorialMode) {
          inTutorialMode = false;
          document.getElementById("tutorial-guide").classList.add("hidden");
          clearHighlights();
          // ë²„íŠ¼ ë³µêµ¬
          const tutorialBtn = document.getElementById("tutorial-btn");
          tutorialBtn.textContent = currentLang.ui.tutorialButton;
          tutorialBtn.removeEventListener("click", endTutorial);
          tutorialBtn.addEventListener("click", startTutorial);
          document
            .querySelectorAll(
              ".header-buttons-left button, .header-buttons-right button"
            )
            .forEach((btn) => {
              btn.disabled = false;
            });
          document.getElementById("eureka-modal").classList.remove("visible");
        }
        // AI íƒ€ì´ë¨¸ ì •ë¦¬ ë° ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
        clearAllAITimeouts();
        aiPlayer = null;
        gameMode = "2P";
        gameIsOver = true;

        // UI ì—…ë°ì´íŠ¸
        document.querySelector(".main-center-bg").classList.remove("hidden");
        updateMainMenuBtnVisibility();
        updateMainCenterVisibility();

        resetGame();
      });
      document.getElementById("vs-player-btn").addEventListener("click", () => {
        if (inTutorialMode) return;
        document.querySelector(".main-center-bg").classList.add("hidden");
        updateMainMenuBtnVisibility();
        updateMainCenterVisibility();
        gameMode = "2P";
        aiPlayer = null;
        resetGame();
      });
      document.getElementById("vs-ai-btn").addEventListener("click", () => {
        if (inTutorialMode || gameMode === "AI") return;
        document.querySelector(".main-center-bg").classList.add("hidden");
        updateMainMenuBtnVisibility();
        updateMainCenterVisibility();
        document
          .getElementById("character-select-modal")
          .classList.add("visible");
      });

      // ì´ˆê¸°í™” ì‹œì—ë„ í˜¸ì¶œ
      updateMainCenterVisibility();

      // ì´ˆê¸°í™” ì‹œì—ë„ í˜¸ì¶œ
      updateMainMenuBtnVisibility();

      function clearAllAITimeouts() {
        if (aiTimeoutId) {
          clearTimeout(aiTimeoutId);
          aiTimeoutId = null;
        }
      }
    </script>
  </body>
</html>
